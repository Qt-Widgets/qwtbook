{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Das Qwt (Hand-)Buch Copyright 2018-heute, Andreas Nicolai Qwt ( Qwt - Qt Widgets for Technical Applications , akt. Entwickler Uwe Rathmann ) ist eine open-source Bibliothek f\u00fcr technische Anwendungen und stellt bestimmte Widgets f\u00fcr Anzeigen und Kontrollkomponenten bereit. Die wohl wichtigste Komponente der Qwt Bibliothek ist das QwtPlot , eine sehr flexible und m\u00e4chtige Diagrammkomponente. Die Qwt Bibliothek steht unter einer OpenSource Lizenz und wird auf SourceForge.net gehostet: Qwt Webseite (englisch) Qwt SourceForge Projektseite Handbuchstruktur Das Handbuch ist in folgende Kapitel unterteilt: Allgemeine Einf\u00fchrung gibt einen Kurz\u00fcberblick \u00fcber die Bibliothek und deren Grundkonzepte Erstellen und Verwenden beschreibt die Konfiguration und Erstellung der Bibliothek, und die Verwendung in eigenen Programmen Das Kapitel Grundlagen beginnt mit einem einfachen Einf\u00fchrungsbeispiel, in welchem die einzelnen Schritte bis zum fertigen Diagramm beschrieben sind. Danach werden die einzelnen Anpassungsm\u00f6glichkeiten beschrieben. Diagramm-Interaktion beschreibt die Funktionen zur Nutzerinterkation mit dem Diagramm, z.B. Zoomen und Verschieben des Diagrammausschnitts, Anzeige von Werten unter dem Cursor, etc. Im Kapitel Fortgeschrittenes werden weiterf\u00fchrende Techniken zur Anpassung des Diagrammerscheinungsbildes beschrieben. Anpassungen beschreibt die Erweiterung der Diagrammfunktionalit\u00e4t durch eigenen Klassen, welche die eingebauten Qwt-Klassen durch \u00dcberladung erweitern Drucken/Exportieren behandelt das Thema des Diagrammexports als Bild oder Vektorgrafik, letzteres auch zum Drucken des Diagramms Im Anhangskapitel von Qwt 5.x zu 6.x werden typische Fragen und Problemstellungen bei der Portierung von Qwt 5 auf Qwt 6 beantwortet. Allgemeine Einf\u00fchrung \u00dcber die Bibliothek Entwicklungsgeschichte die erste Version der Qwt-Bibliothek stammt noch aus dem Jahr 1997 von Josef Wilgen seit 2002 wird die Bibliothek von Uwe Rathmann entwickelt und gepflegt Version 5 ist wohl am weitesten verbreitet (erstes Release vom 26.02.2007) Version 6 (erstes Release vom 15.04.2011, kein Qt3 Support mehr) enth\u00e4lt wesentliche API-\u00c4nderungen aktuelle stabile Version 6.1.4, im trunk gibt es bereits wesentlich mehr und fortgeschrittene Funktionen Download der Bibliothek Die Qwt Bibliothek kann von der Qwt SourceForge Projektseite als Quelltextarchiv geladen werden. Unter Linux wird Qwt bei vielen Distributionen als Paket gehalten. Genau genommen gibt es mehrere Pakete f\u00fcr die unterschiedlichen Qwt-Bibliotheksversionen bzw. Qt Versionen. Details zur Installation und Verwendung der Bibliothek gibt es im Abschnitt Erstellen und Verwenden . Widget-Konzept und Erscheinungsbild Die Qwt Bibliothek liefert Komponenten, welche analog zu den normalen Qt-Widgets in Deskopanwendungen verwendet werden k\u00f6nnen. Die Komponenten verwenden die vom jeweiligen Oberfl\u00e4chenstil definierten Paletteneinstellungen, sodass die Qwt-Widgets in die jeweilige Oberfl\u00e4che passen. Dadurch integrieren sich die Widgets nahtlos in Programmoberfl\u00e4chen. Abrundungseffekte beim Plot-Widget erm\u00f6glichen das Immitieren klassischer Anzeigen: Bei den Kontroll-Komponenten wird die Farbgebung \u00fcber Palettenrollen definiert, z.B. bei den Zeigerkontrollen ( QwtDial ) via QPalette::WindowText (der Hintergrund der inneren Fl\u00e4che) und QPalette::Base (die Grundfarbe des \u00e4u\u00dferen Ringes) und QPalette::Text (die Schriftfarbe): In \u00e4hnlicher Weise k\u00f6nnen auch Gradienten benutzt werden, um ein plastisches Erscheinungsbild zu erzeugen: Bei der QwtPlot -Komponente betrifft das alle Teile, die au\u00dferhalb der eigentlichen Zeichenfl\u00e4che liegen. Das hei\u00dft Titel, au\u00dfenliegende Legende, Achsen, und Diagrammrahmen (einschlie\u00dflich des m\u00f6glichen 3D Rahmeneffekts) werden durch die Paletten-Eigenschaften des Plotwidgets beeinflusst (siehe Beschreibung der relevanten Funktionen in Rahmen und Zeichenfl\u00e4che ) Besitzer/Eigent\u00fcmer-Konzept des QwtPlot-Widgets Eine grundlegende Eigenschaft der QwtPlot -Klasse ist die Besitz\u00fcbername hinzugef\u00fcgter Elemente. Dies gilt allgemein f\u00fcr Zeichenobjekte, die Legende etc. Einmal hinzugef\u00fcgte Elemente k\u00f6nnen nicht wieder losgel\u00f6st werden (bzw. nur \u00fcber einen Trick, wie im Kapitel Fortgeschrittenes beschrieben wird). Daher ist es sinnvoll bei ver\u00e4nderlichen Diagrammelementen einen Mechanismus zur jeweiligen Neuerstellung eines Zeichenobjekts vorzusehen (Factory-Konzept). Beispiel: void Plot::updateLegend() { QwtLegend * legend = new Qwtlegend(); // Legendeneigenschaften setzen ... // Legende in Diagramm ersetzen (alte Legende wird gel\u00f6scht) insertLegend(legend); } Zeichenobjekte und deren Achsenabh\u00e4ngigkeit Ein wesentliches Designmerkmal beim QwtPlot ist die M\u00f6glichkeit, beliebige Zeichenobjekte (Kurven, Marker, Legende, ...) dem Plot zu \u00fcbergeben. Damit sich diese Zeichenobjekte (engl. PlotItem ) am Koordinatengitter ausrichten k\u00f6nnen, wird ihnen eine Achsenabh\u00e4ngigkeit gegeben. Dadurch erhalten diese Zeichenobjekte eine Information, wann immer sich die Achsenskalierung \u00e4ndert (durch Zoomen, oder \u00c4nderung der Wertebereiche etc.). Diese Funktionalit\u00e4t definiert die zentrale Bedeutung der (bis zu) 4 Achsen im Diagramm. Deswegen sind diese auch fest im QwtPlot verankert und werden nicht wie andere Zeichenobjekte beliebig hinzugef\u00fcgt. Vererbungskonzept Grunds\u00e4tzlich ist das QwtPlot und die beteiligten Klassen auf maximale Anpassungsf\u00e4higkeit ausgelegt, d.h. es wird (fast) \u00fcberall Polymorphie unterst\u00fctzt. Wenn die eingebaute Funktionalit\u00e4t nicht zureichend ist, kann man einfach immer die entsprechende Klasse ableiten und die jeweils anzupassende Funktion re-implementieren und ver\u00e4ndern (siehe Kapitel Anpassungen ). Verwendung der Designer Plugins Die Qwt Bibliothek bringt Plugins f\u00fcr Qt Designer mit, welche das Einf\u00fcgen von Qwt-Komponenten in ui-Dateien erleichtert. Es lassen sich jedoch keine QwtPlot-Eigenschaften festlegen oder Kurven hinzuf\u00fcgen. Die eigentliche Anpassung und Ausgestaltung des Plots erfolgt im Quelltext. Deswegen wird die Konfiguration und Anpassung des QwtPlot in diesem Handbuch ausschlie\u00dflich durch normale API-Aufrufe demonstriert. Hinweis: Soll das QwtPlot auch ohne Designer-Plugins im grafischen QtDesigner-Editor eingef\u00fcgt werden, kann man einfach ein QWidget einf\u00fcgen und dieses als Platzhalter f\u00fcr die QwtPlot -Klasse definieren. Eine Beschreibung, wie Designer-plugins erstellt und in Qt Creator/Designer integriert werden ist am Abschnitt [Qwt Designer Plugins(building#qwt-designer-plugins)] beschrieben. Autoreninfo: Schreibkonventionen : QwtDial - Qwt-Klassen im Flie\u00dftext immer als Code-Schnipsel Quelltextbl\u00f6cke immer mit c++ Hervorhebung einf\u00fcgen (Dreifach schr\u00e4ges Hochkomma) Bilder ohne Skalierung einf\u00fcgen (Skalierung erfolgt durch CSS)","title":"Start"},{"location":"#das-qwt-hand-buch","text":"Copyright 2018-heute, Andreas Nicolai Qwt ( Qwt - Qt Widgets for Technical Applications , akt. Entwickler Uwe Rathmann ) ist eine open-source Bibliothek f\u00fcr technische Anwendungen und stellt bestimmte Widgets f\u00fcr Anzeigen und Kontrollkomponenten bereit. Die wohl wichtigste Komponente der Qwt Bibliothek ist das QwtPlot , eine sehr flexible und m\u00e4chtige Diagrammkomponente. Die Qwt Bibliothek steht unter einer OpenSource Lizenz und wird auf SourceForge.net gehostet: Qwt Webseite (englisch) Qwt SourceForge Projektseite","title":"Das Qwt (Hand-)Buch"},{"location":"#handbuchstruktur","text":"Das Handbuch ist in folgende Kapitel unterteilt: Allgemeine Einf\u00fchrung gibt einen Kurz\u00fcberblick \u00fcber die Bibliothek und deren Grundkonzepte Erstellen und Verwenden beschreibt die Konfiguration und Erstellung der Bibliothek, und die Verwendung in eigenen Programmen Das Kapitel Grundlagen beginnt mit einem einfachen Einf\u00fchrungsbeispiel, in welchem die einzelnen Schritte bis zum fertigen Diagramm beschrieben sind. Danach werden die einzelnen Anpassungsm\u00f6glichkeiten beschrieben. Diagramm-Interaktion beschreibt die Funktionen zur Nutzerinterkation mit dem Diagramm, z.B. Zoomen und Verschieben des Diagrammausschnitts, Anzeige von Werten unter dem Cursor, etc. Im Kapitel Fortgeschrittenes werden weiterf\u00fchrende Techniken zur Anpassung des Diagrammerscheinungsbildes beschrieben. Anpassungen beschreibt die Erweiterung der Diagrammfunktionalit\u00e4t durch eigenen Klassen, welche die eingebauten Qwt-Klassen durch \u00dcberladung erweitern Drucken/Exportieren behandelt das Thema des Diagrammexports als Bild oder Vektorgrafik, letzteres auch zum Drucken des Diagramms Im Anhangskapitel von Qwt 5.x zu 6.x werden typische Fragen und Problemstellungen bei der Portierung von Qwt 5 auf Qwt 6 beantwortet.","title":"Handbuchstruktur"},{"location":"#allgemeine-einfuhrung","text":"","title":"Allgemeine Einf\u00fchrung"},{"location":"#uber-die-bibliothek","text":"","title":"\u00dcber die Bibliothek"},{"location":"#entwicklungsgeschichte","text":"die erste Version der Qwt-Bibliothek stammt noch aus dem Jahr 1997 von Josef Wilgen seit 2002 wird die Bibliothek von Uwe Rathmann entwickelt und gepflegt Version 5 ist wohl am weitesten verbreitet (erstes Release vom 26.02.2007) Version 6 (erstes Release vom 15.04.2011, kein Qt3 Support mehr) enth\u00e4lt wesentliche API-\u00c4nderungen aktuelle stabile Version 6.1.4, im trunk gibt es bereits wesentlich mehr und fortgeschrittene Funktionen","title":"Entwicklungsgeschichte"},{"location":"#download-der-bibliothek","text":"Die Qwt Bibliothek kann von der Qwt SourceForge Projektseite als Quelltextarchiv geladen werden. Unter Linux wird Qwt bei vielen Distributionen als Paket gehalten. Genau genommen gibt es mehrere Pakete f\u00fcr die unterschiedlichen Qwt-Bibliotheksversionen bzw. Qt Versionen. Details zur Installation und Verwendung der Bibliothek gibt es im Abschnitt Erstellen und Verwenden .","title":"Download der Bibliothek"},{"location":"#widget-konzept-und-erscheinungsbild","text":"Die Qwt Bibliothek liefert Komponenten, welche analog zu den normalen Qt-Widgets in Deskopanwendungen verwendet werden k\u00f6nnen. Die Komponenten verwenden die vom jeweiligen Oberfl\u00e4chenstil definierten Paletteneinstellungen, sodass die Qwt-Widgets in die jeweilige Oberfl\u00e4che passen. Dadurch integrieren sich die Widgets nahtlos in Programmoberfl\u00e4chen. Abrundungseffekte beim Plot-Widget erm\u00f6glichen das Immitieren klassischer Anzeigen: Bei den Kontroll-Komponenten wird die Farbgebung \u00fcber Palettenrollen definiert, z.B. bei den Zeigerkontrollen ( QwtDial ) via QPalette::WindowText (der Hintergrund der inneren Fl\u00e4che) und QPalette::Base (die Grundfarbe des \u00e4u\u00dferen Ringes) und QPalette::Text (die Schriftfarbe): In \u00e4hnlicher Weise k\u00f6nnen auch Gradienten benutzt werden, um ein plastisches Erscheinungsbild zu erzeugen: Bei der QwtPlot -Komponente betrifft das alle Teile, die au\u00dferhalb der eigentlichen Zeichenfl\u00e4che liegen. Das hei\u00dft Titel, au\u00dfenliegende Legende, Achsen, und Diagrammrahmen (einschlie\u00dflich des m\u00f6glichen 3D Rahmeneffekts) werden durch die Paletten-Eigenschaften des Plotwidgets beeinflusst (siehe Beschreibung der relevanten Funktionen in Rahmen und Zeichenfl\u00e4che )","title":"Widget-Konzept und Erscheinungsbild"},{"location":"#besitzereigentumer-konzept-des-qwtplot-widgets","text":"Eine grundlegende Eigenschaft der QwtPlot -Klasse ist die Besitz\u00fcbername hinzugef\u00fcgter Elemente. Dies gilt allgemein f\u00fcr Zeichenobjekte, die Legende etc. Einmal hinzugef\u00fcgte Elemente k\u00f6nnen nicht wieder losgel\u00f6st werden (bzw. nur \u00fcber einen Trick, wie im Kapitel Fortgeschrittenes beschrieben wird). Daher ist es sinnvoll bei ver\u00e4nderlichen Diagrammelementen einen Mechanismus zur jeweiligen Neuerstellung eines Zeichenobjekts vorzusehen (Factory-Konzept). Beispiel: void Plot::updateLegend() { QwtLegend * legend = new Qwtlegend(); // Legendeneigenschaften setzen ... // Legende in Diagramm ersetzen (alte Legende wird gel\u00f6scht) insertLegend(legend); }","title":"Besitzer/Eigent\u00fcmer-Konzept des QwtPlot-Widgets"},{"location":"#zeichenobjekte-und-deren-achsenabhangigkeit","text":"Ein wesentliches Designmerkmal beim QwtPlot ist die M\u00f6glichkeit, beliebige Zeichenobjekte (Kurven, Marker, Legende, ...) dem Plot zu \u00fcbergeben. Damit sich diese Zeichenobjekte (engl. PlotItem ) am Koordinatengitter ausrichten k\u00f6nnen, wird ihnen eine Achsenabh\u00e4ngigkeit gegeben. Dadurch erhalten diese Zeichenobjekte eine Information, wann immer sich die Achsenskalierung \u00e4ndert (durch Zoomen, oder \u00c4nderung der Wertebereiche etc.). Diese Funktionalit\u00e4t definiert die zentrale Bedeutung der (bis zu) 4 Achsen im Diagramm. Deswegen sind diese auch fest im QwtPlot verankert und werden nicht wie andere Zeichenobjekte beliebig hinzugef\u00fcgt.","title":"Zeichenobjekte und deren Achsenabh\u00e4ngigkeit"},{"location":"#vererbungskonzept","text":"Grunds\u00e4tzlich ist das QwtPlot und die beteiligten Klassen auf maximale Anpassungsf\u00e4higkeit ausgelegt, d.h. es wird (fast) \u00fcberall Polymorphie unterst\u00fctzt. Wenn die eingebaute Funktionalit\u00e4t nicht zureichend ist, kann man einfach immer die entsprechende Klasse ableiten und die jeweils anzupassende Funktion re-implementieren und ver\u00e4ndern (siehe Kapitel Anpassungen ).","title":"Vererbungskonzept"},{"location":"#verwendung-der-designer-plugins","text":"Die Qwt Bibliothek bringt Plugins f\u00fcr Qt Designer mit, welche das Einf\u00fcgen von Qwt-Komponenten in ui-Dateien erleichtert. Es lassen sich jedoch keine QwtPlot-Eigenschaften festlegen oder Kurven hinzuf\u00fcgen. Die eigentliche Anpassung und Ausgestaltung des Plots erfolgt im Quelltext. Deswegen wird die Konfiguration und Anpassung des QwtPlot in diesem Handbuch ausschlie\u00dflich durch normale API-Aufrufe demonstriert. Hinweis: Soll das QwtPlot auch ohne Designer-Plugins im grafischen QtDesigner-Editor eingef\u00fcgt werden, kann man einfach ein QWidget einf\u00fcgen und dieses als Platzhalter f\u00fcr die QwtPlot -Klasse definieren. Eine Beschreibung, wie Designer-plugins erstellt und in Qt Creator/Designer integriert werden ist am Abschnitt [Qwt Designer Plugins(building#qwt-designer-plugins)] beschrieben. Autoreninfo: Schreibkonventionen : QwtDial - Qwt-Klassen im Flie\u00dftext immer als Code-Schnipsel Quelltextbl\u00f6cke immer mit c++ Hervorhebung einf\u00fcgen (Dreifach schr\u00e4ges Hochkomma) Bilder ohne Skalierung einf\u00fcgen (Skalierung erfolgt durch CSS)","title":"Verwendung der Designer Plugins"},{"location":"advanced/","text":"Spezifische Anpassungen Layout hints Render hints Performance-Optimierungen Punkte filtern (monotone x-Achsen) Antialiasing Overlays ... Spline-Interpolation von Kurven ab 6.3.x_trunk ... Zeichenreihenfolge wie kontrolliert man die Zeichenreihenfolge (zValues) Standardreihenfolge beim Zeichnen Tricks und Tipps Besitz\u00fcbernahme von Objekten des Plots Um einmal hinzugef\u00fcgte Elemente zu entnehmen, ohne dass diese gel\u00f6scht werden , muss man zuerst deren parent-Attribut \u00e4ndern. Dazu ben\u00f6tigt man Schreibzugriff auf das jeweilige Element, welchen man eventuell \u00fcber einen const_cast erhalten kann. Um z.B. ein Legendenobjekt zu entnehmen, um es sp\u00e4ter modifiziert wieder hinzuzuf\u00fcgen, kann man folgendes tun: QwtLegend * legend = const_cast QwtLegend * (plot- legend()); legend- setParent(anotherObject); plot- insertLegend(NULL); // remove legend from plot","title":"Fortgeschrittenes"},{"location":"advanced/#spezifische-anpassungen","text":"","title":"Spezifische Anpassungen"},{"location":"advanced/#layout-hints","text":"","title":"Layout hints"},{"location":"advanced/#render-hints","text":"","title":"Render hints"},{"location":"advanced/#performance-optimierungen","text":"Punkte filtern (monotone x-Achsen) Antialiasing","title":"Performance-Optimierungen"},{"location":"advanced/#overlays","text":"...","title":"Overlays"},{"location":"advanced/#spline-interpolation-von-kurven","text":"ab 6.3.x_trunk ...","title":"Spline-Interpolation von Kurven"},{"location":"advanced/#zeichenreihenfolge","text":"wie kontrolliert man die Zeichenreihenfolge (zValues) Standardreihenfolge beim Zeichnen","title":"Zeichenreihenfolge"},{"location":"advanced/#tricks-und-tipps","text":"","title":"Tricks und Tipps"},{"location":"advanced/#besitzubernahme-von-objekten-des-plots","text":"Um einmal hinzugef\u00fcgte Elemente zu entnehmen, ohne dass diese gel\u00f6scht werden , muss man zuerst deren parent-Attribut \u00e4ndern. Dazu ben\u00f6tigt man Schreibzugriff auf das jeweilige Element, welchen man eventuell \u00fcber einen const_cast erhalten kann. Um z.B. ein Legendenobjekt zu entnehmen, um es sp\u00e4ter modifiziert wieder hinzuzuf\u00fcgen, kann man folgendes tun: QwtLegend * legend = const_cast QwtLegend * (plot- legend()); legend- setParent(anotherObject); plot- insertLegend(NULL); // remove legend from plot","title":"Besitz\u00fcbernahme von Objekten des Plots"},{"location":"basics/","text":"Kleine Einf\u00fchrung ins QwtPlot Ein paar kleinere Beispiele sollen zun\u00e4chst die grundlegende Funktionalit\u00e4t und Benutzung des QwtPlot -Widgets zeigen. Hinweis: In den nachfolgenden Beispielen werden die in der Qwt-Bibliothek enthaltenen Klassen direkt verwendet und nur deren Attribute angepasst. Weiterf\u00fchrende Anpassungen durch Re-Implementierung von Funktionen in abgeleiteten Klassen werden im Kapitel Anpassungen beschrieben. Ein Kurvendiagramm Beginnen wir mit einem einfachen X-Y-Diagramm welches eine Linie darstellt: #include QApplication #include QwtPlot // oder qwt_plot.h #include QwtPlotCurve // oder qwt_plot_curve.h int main( int argc, char **argv ) { QApplication a( argc, argv ); // create plot as main widget QwtPlot plot; plot.setTitle( Plot Demo ); plot.setCanvasBackground( Qt::white ); // create a new curve to be shown in the plot and set some properties QwtPlotCurve *curve = new QwtPlotCurve(); curve- setTitle( Some Points ); // will later be used in legend curve- setPen( Qt::blue, 4 ), // color and thickness in pixels curve- setRenderHint( QwtPlotItem::RenderAntialiased, true ); // use antialiasing // data points QPolygonF points; points QPointF( 0.0, 4.4 ) QPointF( 1.0, 3.0 ) QPointF( 2.0, 4.5 ) QPointF( 3.0, 6.8 ) QPointF( 4.0, 7.9 ) QPointF( 5.0, 7.1 ); // give some points to the curve curve- setSamples( points ); // set the curve in the plot curve- attach( plot ); plot.resize( 600, 400 ); plot.show(); return a.exec(); } Dies ergibt ein (noch ziemlich langweiliges) Diagrammfenster: Include-Dateien Grunds\u00e4tzlich gibt es zwei unterschiedliche Varianten f\u00fcr Include-Dateinamen - entweder man verwendet die tats\u00e4chlichen Header-Dateinamen, also z.B. #include qwt_plot.h f\u00fcr die Klasse QwtPlot , oder man verwendet die klassenspezifischen Headerdateien #include QwtPlot (das sind Verweise auf die eigentlichen Headerdateien, wie bei Qt5 \u00fcblich). Da manche Headerdateien die Deklarationen f\u00fcr verschiedene Qwt-Klassen enthalten, ist es h\u00e4ufig einfacher bei Kenntniss des Klassennames auch einfach die entsprechend gleichnamigen Headerdateien zu verwenden. Hinweis: In den nachfolgenden Beispielen werden die neuen Headerdateinamen (=Klassennamen) verwendet. In den Beispielen im examples -Verzeichnis der Qwt-Bibliothek werden die eigentlichen Headerdateinamen eingebunden. Plot-Widget und Hintergrundfarbe der Zeichenfl\u00e4che Im obigen Quelltext wird zun\u00e4chst das QwtPlot Widget erstellt und erh\u00e4lt einen Titel. Der CanvasBackground ist der Hintergrund der Zeichenfl\u00e4che. Der Befehl: plot.setCanvasBackground( Qt::white ); legt nur die Hintergrundfarbe der eigentlichen Zeichenfl\u00e4che (engl. Canvas ) fest (siehe auch Erscheinungsbild des Plots anpassen ). Kurve als Zeichenobjekt hinzuf\u00fcgen Als n\u00e4chstes wird ein Zeichenobjekt (engl. PlotItem ) f\u00fcr eine Linie/Kurve erstellt und konfiguriert. Es gibt viele verschiedene Arten von Zeichenobjekten. Alle haben gemeinsam, dass sie auf der Zeichenfl\u00e4che gezeichnet werden. Die Reihenfolge des Zeichnens ist dabei f\u00fcr die Sichtbarkeit der einzelnen Zeichenobjekte wichtig (dazu sp\u00e4ter mehr, siehe Abschnitt Zeichenreihenfolge ). Grunds\u00e4tzlich werden alle Zeichenobjekte auf dem Heap (im Hauptspeicher) erstellt und sp\u00e4ter dem Plot \u00fcbereignet. Das passiert mit: curve- attach( plot ); wobei das Plot Besitzer des Zeichenobjekts (d.h. unserer Kurve) wird und sich sp\u00e4ter um das Speicheraufr\u00e4umen k\u00fcmmert. Zu den sinnvoll anzupassenden Eigenschaften einer Kurve geh\u00f6ren die Farbe und die Linienst\u00e4rke, siehe QwtPlotCurve::setPen() . Bei dicken Linien lohnt sich das Einschalten von Antialiasing f\u00fcr die Liniendarstellung. Hinweis: Das Setzen von Zeichenattributen via setRenderHint() wird von allen Zeichenobjekten unterst\u00fctzt. So kann man Eigenschaften wie Antialiasing individuell f\u00fcr verschiedene Zeichenobjekte setzen. Die hinzugef\u00fcgte Kurve ist standardm\u00e4\u00dfig der unteren X-Achse und der linken Y-Achse zugeordnet, sodass die Daten der Kurve gleichzeitig zur automatischen Skalierung der Achsen verwendet werden. Der Titel der Linie wird mittels QwtPlotCurve::setTitle() gesetzt und in der Legende verwendet, welche wir als n\u00e4chstes einf\u00fcgen (weitere Kurveneigenschaften werden sp\u00e4ter besprochen). Legende, Diagrammachsen und Hauptgitterlinien Legende hinzuf\u00fcgen Um eine Legende hinzuzuf\u00fcgen, braucht man lediglich eine Instanz der QwtLegend -Klasse erstellen und im Plot einf\u00fcgen: QwtLegend * legend = new QwtLegend(); plot.insertLegend( legend , QwtPlot::BottomLegend); Der dazugeh\u00f6riger Header wird mittels #include QwtLegend eingebunden. Wie auch beim Zeichenobjekt (Kurve) wird das Plot Besitzer der Legende und verwaltet die Resource. Hinweis: Wird eine andere Legende gesetzt, so wird die alte zuerst gel\u00f6scht. Es ist daher nicht erlaubt, auf eine ersetzte Legende weiterhin zuzugreifen (um das zu umgehen, siehe auch Besitz\u00fcbernahme von Objekten des Plots ). Weitere Eigenschaften der Legende werden im Kapitel zur Legendenformatierung erl\u00e4utert. Diagrammachsen konfigurieren Im Gegensatz zu Legende oder Kurven sind Achsen keine Zeichenobjekte sondern fest mit dem Diagramm verbunden. Die Sichtbarkeit der 4 Achsen (links, rechts, oben und unten) kann jedoch individuell festgelegt werden. Achseneigenschaften legt man direkt \u00fcber Zugriffsfunktionen der QwtPlot -Klasse fest, wie z.B. selbstgew\u00e4hlte min/max-Werte: plot.setAxisScale( QwtPlot::yLeft, 0.0, 10.0 ); Die Achsen werden durch QwtPlot::yLeft , QwtPlot::yRight , QwtPlot::xBottom und QwtPlot::xTop identifiziert. Gitterraster einf\u00fcgen Um in der Zeichenfl\u00e4che Gitterlinien zu zeichnen, f\u00fcgt man einfach ein entsprechendes Zeichenobjekt hinzu. QwtPlotGrid *grid = new QwtPlotGrid(); grid- setMajorPen(QPen(Qt::DotLine)); grid- attach( plot ); Wie schon bei der Legende wird die Instanz der Klasse QwtPlotGrid (einzubinden via #include QwtPlotGrid ) zun\u00e4chst im Hauptspeicher angelegt, konfiguriert (hier wird nur der QPen der Hauptgitterlinien ver\u00e4ndert) und schlie\u00dflich dem Plot hinzugef\u00fcgt. Liniensymbole hinzuf\u00fcgen Als ein Beispiel etwas weiterf\u00fchrender Konfiguration der Linien ( QwtPlotCurve ) wird hier ein Liniensymbol hinzugef\u00fcgt. Diese Eigenschaft (konkret das Zeichnen des Symbols) ist wieder anpassungsf\u00e4hig ausgelegt und nicht fest in der Klasse QwtPlotCurve integriert. F\u00fcr das Zeichnen von Symbolen existiert die Klasse QwtSymbol , welche nicht direkt als Zeichenobjekt verwendet wird, sondern eine Hilfsimplementierung f\u00fcr verschiedene Anwendungszwecke darstellt. Liniensymbole werden folgenderma\u00dfen erstellt: QwtSymbol *symbol = new QwtSymbol( QwtSymbol::Ellipse, // Form QBrush( Qt::yellow ), // F\u00fcllung QPen( Qt::red, 2 ), // Rand QSize( 8, 8 ) ); // Gr\u00f6\u00dfe in Pixel curve- setSymbol( symbol ); // Kurve wurde Besitzer Mit diesen Anpassungen sieht das Diagramm schon besser aus (siehe auch Beispiel examples/SimplePlot ) Diagrammtypen allgemeines zu PlotItems/Curves Liniendiagramme und Punktwolken Liniendiagramme, Punktwolken oder sonstige X-Y-Datenreihen werden mittels QwtPlotCurve Diagrammtypen gezeichnet. Wie im Beispiel oben wird eine Instanz einer solchen PlotCurve erstellt und dem Diagramm angehangen. Die Attribute einer QwtPlotCurve sind vielf\u00e4ltigt: CurveStyle - legt fest, wie die Datenpunkte gezeichnet werden sollen CurveAttribute - Zeichenattribute LegendAttribute - beinflusst die Darstellung der Legendensymbole PaintAttribute - Performance-bezogene Darstellungsoptionen Symbole (Marker) werden via QwtPlotCurve::setSymbol() hinzugef\u00fcgt. Entfernen von Kurven Kurven k\u00f6nnen Diagrammen entnommen oder nur ausgeblendet werden: mittels curve- detach() wird die Kurve dem Diagramm und der Legende entnommen (der Speicher der Kurve wird nicht freigegeben!), unsichtbar schalten mittels curve- setVisible(false) , oder alternativ Linientyp auf NoCurve und Symbol entfernen: curve- setStyle(QwtPlotCurve::NoCurve); curve- setSymbol(NULL); Bei Variante (2) und (3) bleibt der Legendeneintrag aber bestehen. Da kann man dann aber immer noch den Legendeneintrag ausblenden: // das LegendenWidget, d.h. Legendeneintrag von der Legende holen QWidget* legendWidget = d_legend- legendWidget(itemToInfo(plotCurve)); // Standardm\u00e4\u00dfig ist das Widget des Legendeneintrags vom Typ QwtLegendLabel QwtLegendLabel* label = qobject_cast QwtLegendLabel* (legendWidget); label- setVisible(true); Feststellen, ob eine Kurve hinzugef\u00fcgt ist QwtPlotCurve::plot() liefert einen Zeiger auf das Diagramm, dem die Kurve hinzugef\u00fcgt wurde, oder NULL , wenn die Kurven derzeit keinem Plot zugeordnet ist. Balkendiagramme Balkendiagramme zeigen Datenreihen als Balken, entweder horizontal oder vertikal. Dabei k\u00f6nnen die Balken groupiert oder aufeinandergestapelt angezeigt werden: Das Beispiel barchart demonstriert die Erstellung: // zuerst ein PlotItem f\u00fcr Balkendiagramme erstellen QwtPlotMultiBarChart * d_barChartItem = new QwtPlotMultiBarChart( Bar Chart ); // die Breite der Balken soll automatische anhand der Achsenskalierung // und Widgetbreite bestimmt werden d_barChartItem- setLayoutPolicy( QwtPlotMultiBarChart::AutoAdjustSamples ); // man kann die Abst\u00e4nde zwischen den Balken konfigurieren d_barChartItem- setSpacing( 20 ); d_barChartItem- setMargin( 3 ); // und wie immer wir zuletzt das PlotItem dem Diagramm hinzugef\u00fcgt d_barChartItem- attach( this ); Eine Legende wird genau wie bei anderen Diagrammtypen hinzugef\u00fcgt (siehe auch Legenden ). Es ist eventuell sinnvoll, die Legendenicongr\u00f6\u00dfe anzupassen. Da die Legendenicons vom jeweiligen Diagrammelement generiert werden (hier vom QwtPlotMultiBarChart), setzt man die Legendenicongr\u00f6\u00dfe auch dar\u00fcber: d_barChartItem- setLegendIconSize( QSize( 10, 14 ) ); Die Daten eines Balkendiagramms sind in Datenpunkte (engl. samples ) und Balken (engl. bars ) organisiert. Jeder Datenpunkt entspricht einem X-Achsenwert (bei vertikalen Balkendiagrammen) und f\u00fcr jeden Datenpunkt werden entsprechend viele Balken (nebeneinander/\u00fcbereinander) gezeichnet. Die Beschriftung auf der X-Achse (bzw. auf der Y-Achse bei horizontalen Balken) wird mit QwtPlotMultiBarChart::setTitles() gesetzt: QList QwtText titles; titles First group ; titles Second group ; titles Third group ; d_barChartItem- setBarTitles( titles ); Das Erscheinungsbild der Balken definiert man durch Erstellen und Setzen von QwtColumnSymbol Objekten: // Balkenfarben definieren static const char *colors[] = { DarkOrchid , SteelBlue , Gold }; const int numBars = 3; // F\u00fcr jeden Balken ein Symbol definieren for ( int i = 0; i numBars; i++ ) { QwtColumnSymbol *symbol = new QwtColumnSymbol( QwtColumnSymbol::Box ); // Die Konfiguration ist \u00e4hnlich der regul\u00e4rer Widgets symbol- setLineWidth( 2 ); // Pixel-Dimension symbol- setFrameStyle( QwtColumnSymbol::Raised ); symbol- setPalette( QPalette( colors[i] ) ); d_barChartItem- setSymbol( i, symbol ); } Die eigentlich Daten werden in einer Matrix definiert, welche zum Beispiel in einem Container QVector QVector double abgelegt werden k\u00f6nnen. Der erste Index ist die Nummer des \"Samples\" (der Gruppe), der zweite Index entspricht dem Balkenindex der jeweiligen Gruppe: int numSamples = 5; // 5 Gruppen QVector QVector double samples; for ( int i = 0; i numSamples; i++ ) { QVector double values(numBars); // setzen der Werte values[0] = barValue1; values[1] = barValue2; values[2] = barValue3; // ... // hinzuf\u00fcgen zur samples-Matrix samples.append(values); } // Abschlie\u00dfend werden dem BarPlot die Daten \u00fcbergeben d_barChartItem- setSamples( samples ); Ein derart erstelltes BarChart sieht zun\u00e4chst so aus: Die Samples sind standardm\u00e4\u00dfig ganzzahligen X-Koordinaten (0,1,2...) zugeordnet. Die Achsen werden ganz genauso wie bei anderen Diagrammtypen angepasst (siehe Achsen ). \u00dcblicherweise werden bei Balkendiagrammen jedoch keine Ticks und Ticklabels angezeigt. Daher kann man diese ausstellen: // Zugriff auf das Zeichenobjekt f\u00fcr die Achsen holen QwtScaleDraw *scaleDraw1 = plot- axisScaleDraw( QwtPlot::xBottom ); // Die Achsenlinie und die Ticks lassen sich individuell abschalten scaleDraw1- enableComponent( QwtScaleDraw::Backbone, false ); scaleDraw1- enableComponent( QwtScaleDraw::Ticks, false ); Die Balken jeder Gruppe werden zentriert um die zugeordnete Koordinate gezeichnet, wodurch effektiv eine Skale verwendet wird, die in den negativen Bereich geht. Wird die Zeichenfl\u00e4che auf die Koordinatenachse ausgerichtet, so werden die Balken am linken und rechten Rand abgeschnitten. F\u00fcr vertikale Balken l\u00e4sst sich das \u00fcber die folgenden Befehle ausschalten: // linksseitig nicht bei 0 abschneiden plotLayout()- setAlignCanvasToScale( QwtPlot::yLeft, false ); // rechtsseitig nicht beim Maximalwert der X-Achse aufh\u00f6ren plotLayout()- setAlignCanvasToScale( QwtPlot::yRight, false ); Spezielle Beschriftungen Manchmal m\u00f6chte man die Balkengruppe besonders beschriften, wie in folgendem Beispiel: Dieses ist mit Qwt 6.1.x und den eingebauten Eigenschaften so nicht m\u00f6glich. Kapitel Balkendiagramme mit Kategoriebeschriftungen beschreibt die Vorgehensweise, um mit eigens angepassten Klassen, diese Diagramme zu erstellen. Balken entfernen und wieder hinzuf\u00fcgen Balken k\u00f6nnen mittels QwtPlotMultiBarChart::setVisible() sichtbar oder unsichtbar geschaltet werden. Dabei bleibt jedoch der entsprechende Legendeneintrag in der Liste. M\u00f6chte man den Balken einschlie\u00dflich Legendenicon entfernen, so muss man das Balkendiagramm neu konfigurieren, d.h. neue Titel und neue Daten (mit passender Dimension des Samples-Matrix) setzen. TODO: eleganter Weg einzelne Balken auszublenden? Spektrogramme erste Anwendung der Re-Implementierungstechnik value() Berechnung spezielle Optimierungen Vektorfelder ab 6.3.x_trunk Eingangsdaten, Interpretation Konfiguration Erscheinungsbild des Plots anpassen Rahmen und Zeichenfl\u00e4che Beim QwtPlot k\u00f6nnen verschiedene Elemente angepasst werden. Nachfolgend ist ein QwtPlot zu sehen, welches in einem \u00e4u\u00dferen Widget (dunkelgray) eingebettet ist. Die hellgraue Fl\u00e4che ist das eigentliche QwtPlot : Im Screenshot sind die wichtigsten Attribute markiert: Innenabstand (siehe QWidget::setContentsMargins() ) Rahmen (haupts\u00e4chlich f\u00fcr den Druck wichtig) Hintergrund des Plot-Widgets Zeichenfl\u00e4che (engl. Canvas ) (betrifft Hintergrundfarbe und Rahmen) Farbe und Rahmen des Plots Die Farbe des \u00e4u\u00dferen Bereichs des Plots wird \u00fcber die Paletteneigenschaft des QwtPlot kontrolliert. Standardm\u00e4\u00dfig wird der \u00e4u\u00dfere Rand des Plot-Widgets transparant gezeichnet, d.h. die Farbe des darunterliegenden Widgets ist sichtbar. Um eine eigene Farbe zu setzen, muss daher setAutoFillBackground(true) aufgerufen werden: QPalette pal = plot.palette(); // Die QPalette::Window Farbrolle definiert die Einf\u00e4rbung // des \u00e4u\u00dferen Plotbereichs pal.setColor(QPalette::Window, QColor(196,196,220)); plot- setPalette(pal); // die Eigenschaft autoFillBackground muss daf\u00fcr eingeschaltet sein plot- setAutoFillBackground(true); Hinweis: In Abschnitt Gradient als Plot-Hintergrund wird beschrieben, wie man einen Farbverlauf im Plothintergrund umsetzt, und diesen bei Gr\u00f6\u00dfen\u00e4nderung entsprechend anpasst. Der Rahmen wird wie bei einem normalen Widget angepasst: plot- setFrameStyle(QFrame::Box | QFrame::Sunken); Normalerweise ist ein solcher Rahmen nicht notwendig f\u00fcr die Bildschirmdarstellung oder f\u00fcr das Einbetten des QwtPlot in eine Programmoberfl\u00e4che. Der Rahmen ist jedoch h\u00e4ufig beim Export/Druck des Widgets sinnvoll. Zeichenfl\u00e4che Die Zeichenfl\u00e4che kann eingef\u00e4rbt werden: plot- setCanvasBackground(Qt::darkGray); Der Randabstand zwischen Achsenbeschriftung und Titel zum Rand kann definiert werden: plot- setContentsMargins(15,10,35,5); Die Rahmen um die Zeichenfl\u00e4che kann durch Anpassen des Zeichenfl\u00e4chenobjekts ( QwtPlotCanvas ) ver\u00e4ndert werden. QwtPlotCanvas ist von QFrame abgeleitet, wodurch es entsprechend angepasst werden kann. Es wird einfach neues Objekt erstellt, konfiguriert und dem Plot \u00fcbergeben (das QwtPlot wird neuer Besitzer des Zeichenfl\u00e4chenobjekts): QwtPlotCanvas * canvas = new QwtPlotCanvas( plot); canvas- setPalette(Qt::white); canvas- setFrameStyle(QFrame::Box | QFrame::Plain ); canvas- setLineWidth(1); plot- setCanvas(canvas); Einfacher geht es durch Setzen des Stylesheets f\u00fcr das Canvas-Widget (siehe Qt-Widgets Dokumentation, welche Attribute unterst\u00fctzt werden): plot- canvas()- setStyleSheet( border: 1px solid Black; border-radius: 15px; background-color: qlineargradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 LemonChiffon, stop: 1 PaleGoldenrod ); ); Erweiterte Anpassungen Wie das Layout der Achsen, Legende, Titel, Kopf- und Fu\u00dfzeile und die jeweiligen Abst\u00e4nde zus\u00e4tzlich angepasst werden k\u00f6nnen, ist in Kapitel Das Layout-System beschrieben. Diagrammelemente Titel, Kopf- und Fu\u00dfzeile wo sind die RichText-Unterst\u00fctzung (HTML Tags) Kurven Attribute von Kurven Erscheinungsbild und Wirkung von RenderHints Zeichenreihenfolge (anpassen) Legenden Grunds\u00e4tzlich kann ein QwtPlot zwei Legenden haben, und diese sogar gleichzeitig: eine au\u00dfenliegende Legende, und/oder eine Legende innerhalb der Zeichenfl\u00e4che (\u00fcber oder unter den anderen Diagrammelementen) Die Eintr\u00e4ge der Legenden werden von den jeweiligen Diagrammtypen (Linen-, Balken-, Farbverlaufsdiagramme) beigesteuert und auch von diesen gezeichnet. Die Legende verwaltet nur deren Positionierung innerhalb der Legende. Au\u00dfenliegende Legenden Eine au\u00dfenliegende Legende bedeutet, dass ein regul\u00e4res Widget die Legende h\u00e4lt und seitlich (oben, unten, links oder rechts) der Zeichenfl\u00e4che angeordnet ist. Dieses Widget kann auch abseits des QwtPlot in einem anderen Teil des Layouts angeordnet werden. In diesem Fall spricht man von einer externen Legende . Dazu wird eine Instanz der Klasse QwtLegend erstellt und dem Diagramm hinzugef\u00fcgt: QwtLegend * d_legend = new QwtLegend; insertLegend(d_legend, QwtPlot::RightLegend); Dabei ist QwtLegend ein ganz regul\u00e4res Widget. Intern enthalten Sie ein dynamisches Rasterlayout (Klasse QwtDynGridLayout ), welches die Legendeneintr\u00e4ge je nach verf\u00fcgbarem Platz mehrspaltig auslegt. Maximale Anzahl der Spalten in der Legende Die Anzahl der maximal zu verwendenden Spalten wird mittels QwtLegend::setMaxColumns( uint numColums ) festgelegt. Ein Wert von 0 (Standard) definert keine Begrenzung. Das ist f\u00fcr Legenden unterhalb und oberhalb des Plots sinnvoll, da hier auch mitunter sehr viele Legendeneintr\u00e4ge nebeneinander gezeichnet werden sollen. Links- und rechtsseitig angeordnete Legenden haben aber \u00fcblicherweise nur eine Spalte: // links und rechtsseitige Legenden sollen nur eine Spalte verwenden d_legend- setMaxColumns(1); Positionierung der Legende Die Positionierung der Legende wird beim Einf\u00fcgen der Legende festgelegt. QwtPlot::insertLegend() erwartet einen der vier m\u00f6glichen Parameter: QwtPlot::BottomLegend , QwtPlot::TopLegend , QwtPlot::RightLegend , QwtPlot::LeftLegend . Wird die Funktion insertLegend() ein weiteres Mal aufgerufen, so wird zun\u00e4chst die alte Legende gel\u00f6scht (auch der Speicher wird freigegeben) und dann wird die neue Legende eingef\u00fcgt. Legende entfernen Ruft man QwtPlot::insertLegend() mit einem NULL-Zeiger auf, so wird die bisherige Legende gel\u00f6scht, aber keine neue eingef\u00fcgt. Damit entfernt das Plot auch das Legendenwidget. Hinweis : Der Abschnitt Besitz\u00fcbernahme von Objekten des Plots zeigt einen Trick, wie man z.B. eine Legende dem Plot tempor\u00e4r entnehmen kann und sp\u00e4ter wieder hinzuf\u00fcgen kann, ohne dass das Legendenobjekt neu im Speicher erstellt werden muss. Abst\u00e4nde zwischen Legendeneintr\u00e4gen Bei einer au\u00dfenliegende Legende sind die eigentlichen Legendeneintr\u00e4ge selbst Widgets die in einem dynamischen GridLayout angeordnet sind. Das dynamische GridLayout steckt selbst in einer QScrollArea-Widget, weswegen die Legende bei zu wenig Platz mit Scrollbalken ausgestattet wird. Auf dieses QScrollArea-Widget kann man mittels QwtLegend::contentsWidget() zugreifen, und dar\u00fcber auf das dynamische GridLayout. Wie bei anderen QLayout-Klassen lassen sich die Abst\u00e4nde zwischen den Widgets mit QLayout::setSpacing() anpassen. Interessant ist das vor allem bei umschaltbaren/anklickbaren Legendeneintr\u00e4gen : // verkleinern der Abst\u00e4nde zwischen den Legendeneintr\u00e4gen d_legend- contentsWidget()- layout()- setSpacing(1); So lassen sich auch Legenden mit vielen Eintr\u00e4gen recht kompakt anzeigen: Rahmen und farbiger Hintergrund bei der Legende Da QwtLegend-Objekte selber Widgets sind, l\u00e4sst sich das Erscheinungsbild entsprechend mit Qt-Standardmitteln anpassen, z.B. ein Rahmen setzen und die Hintergrundfarbe anpassen: // einfacher Rahmen d_legend- setFrameStyle(QFrame::Box|QFrame::Sunken); // Hintergrundfarbe anpassen QPalette pal = d_legend- palette(); pal.setColor(QPalette::Window, backgroundColor); d_legend- setPalette(pal); // Wichtig: Widget soll selbst den Hintergrund zeichnen d_legend- setAutoFillBackground(true); Gegen\u00fcber der Standardeinstellung (links) hebt sich die Legende dadurch optisch ab (rechts): TODO Ratio Parameter Legendensymbole Die LegendIcons bzw. allgemein die Eintr\u00e4ge in der Legende werden vom jeweiligen PlotItem bzw. der Kurve generiert. Entsprechende Anpassungsfunktionen sind daher f\u00fcr die jeweiligen Diagrammtypklassen verf\u00fcgbar, d.h. in QwtPlotCurve , QwtPlotSpectrogram und QwtPlotMultiBarChart definiert. Man kann die Legendeneintr\u00e4ge auch komplett selbst zeichnen, wie im Kapitel Eigene Legendeneintr\u00e4ge zeichnen beschrieben ist. Darstellung der Legendeneintr\u00e4ge bei Kurven: Linie, Rechteck oder Farbe? ... QwtPlotCurve::setLegendAttribute() Innenliegende Legenden Skizze mit relevanten Abmessungen Konfiguration Offset (Version 6.1.x und 6.3.x_trunk) Achsen allgemeines zum Zusammenspiel zwischen ScaleDiv und ScaleDraw, wie werden diese von Achsen verwendet woher erhalten Achsen die Werte Sichtbarkeit der Achsen Achsen k\u00f6nnen individuell sichtbar oder versteckt geschaltet werden. Standardm\u00e4\u00dfig sind die xBottom-Achse und die yLeft-Achse sichtbar. Die Sichtbarkeit wird mit QwtPlot::enableAxis(axisID, on) umgeschaltet. Achsentitel Achsentitel werden mittels QwtPlot::setAxisTitle(int axisId, const QwtText title) gesetzt. Achsentitel invertieren/von rechts lesbar machen Bei technischen Diagrammen ist es \u00fcblich, den Titel der rechten y-Achse von rechts lesbar zu zeichnen. Dies wird durch Setzen eines LayoutFlags des Achsenwidgets erreicht: plot- axisWidget(QwtPlot::yRight)- setLayoutFlag(QwtScaleWidget::TitleInverted, false); Achsenbeschriftung (Zahlen/Datum/Zeit) Die Achsentitel k\u00f6nnen ferner rotiert und positioniert werden, wof\u00fcr die Funktionen void setAxisLabelAlignment( int axisId, Qt::Alignment ); void setAxisLabelRotation( int axisId, double rotation ); verwendet werden. Der Rotationswinkel wird hierbei in Grad angegeben. Je nach Rotation muss man den Abstand zwischen Label und Achse anpassen, bzw. die Ausrichtung (Alignment) ver\u00e4ndern. F\u00fcr die untere X-Achse sind folgende Einstellungen sinnvoll: // Senkrechte Beschriftung, von rechts lesbar plot- setAxisLabelRotation(QwtPlot::xBottom, -90); plot- setAxisLabelAlignment(QwtPlot::xBottom, Qt::AlignLeft | Qt::AlignVCenter); // 45\u00b0 Beschriftung plot- setAxisLabelRotation(QwtPlot::xBottom, -45); plot- setAxisLabelAlignment(QwtPlot::xBottom, Qt::AlignLeft | Qt::AlignBottom); Lineare Achsen und deren Eigenschaften ... Logarithmische Achsen und andere Transformationen ... Beispiel: scaleengine Datums-/Zeit-Achsen Werte in ms (Epoche) Formatierung, Zoomstufen Bereichsmarkierungen Ein horizontales oder vertikales Band als Hervorherbung kann durch ein QwtPlotZoneItem erstellt werden: QwtPlotZoneItem* zone = new QwtPlotZoneItem(); zone- setPen( Qt::darkGray ); zone- setBrush( QColor( #834358 ) ); // Ausrichtung: vertikales oder horizontales Band zone- setOrientation( Qt::Horizontal ); // Der Bereich des Bandes in Koordinateneinheiten zone- setInterval( 3.8, 5.7 ); // Hinzuf\u00fcgen zum Diagramm zone- attach( this ); Zeichenreihenfolge Alle Elemente, die innerhalb der Zeichenfl\u00e4chte gezeichnet werden, sind von QwtPlotItem abgeleitet. Diese Klasse hat die Eigenschaft zValue, welche die Zeichenreihenfolge definiert. H\u00f6here Werte bedeuten wie kontrolliert man die Zeichenreihenfolge (zValues) Standardreihenfolge beim Zeichnen Basisdatentypen Die Qwt-Bibliothek bringt einige grundlegende Datentypen/Klassen mit, welche die Datentypen der Qt Bibliothek erweitert. QwtText Die Klasse QwtText ersetzt die QString Klasse und erlaubt die Definition von Texten, welche auf unterschiedliche Art und Weise interpretiert und damit gezeichnet werden k\u00f6nnen. Man kann mittels der QwtText Klasse unter anderem HTML-basierten RichText verwenden, z.B. f\u00fcr die Hoch- und Tiefstellung von Zahlen bei Einheiten: // Ein Achsentitel mit HTML-basierter Hochstellung QwtText axisTitle(tr( Area [m sup 2 /sup ] ), QwtText::RichText); Nat\u00fcrlich k\u00f6nnen auf diese Weise auch beliebig in HTML formatierte Texte verwendet werden. QwtText wird bei allen Zugriffsfunktionen verwendet, bei dehnen eine Zeichenkette verlangt wird. TextEngine PaintAttributes and LayoutAttributes Datenhalteklassen QwtRasterData QwtIntervalSample QwtSetSample QwtOHLCSample QwtVectorSample (ab Qwt 6.3.x)","title":"Grundlagen"},{"location":"basics/#kleine-einfuhrung-ins-qwtplot","text":"Ein paar kleinere Beispiele sollen zun\u00e4chst die grundlegende Funktionalit\u00e4t und Benutzung des QwtPlot -Widgets zeigen. Hinweis: In den nachfolgenden Beispielen werden die in der Qwt-Bibliothek enthaltenen Klassen direkt verwendet und nur deren Attribute angepasst. Weiterf\u00fchrende Anpassungen durch Re-Implementierung von Funktionen in abgeleiteten Klassen werden im Kapitel Anpassungen beschrieben.","title":"Kleine Einf\u00fchrung ins QwtPlot"},{"location":"basics/#ein-kurvendiagramm","text":"Beginnen wir mit einem einfachen X-Y-Diagramm welches eine Linie darstellt: #include QApplication #include QwtPlot // oder qwt_plot.h #include QwtPlotCurve // oder qwt_plot_curve.h int main( int argc, char **argv ) { QApplication a( argc, argv ); // create plot as main widget QwtPlot plot; plot.setTitle( Plot Demo ); plot.setCanvasBackground( Qt::white ); // create a new curve to be shown in the plot and set some properties QwtPlotCurve *curve = new QwtPlotCurve(); curve- setTitle( Some Points ); // will later be used in legend curve- setPen( Qt::blue, 4 ), // color and thickness in pixels curve- setRenderHint( QwtPlotItem::RenderAntialiased, true ); // use antialiasing // data points QPolygonF points; points QPointF( 0.0, 4.4 ) QPointF( 1.0, 3.0 ) QPointF( 2.0, 4.5 ) QPointF( 3.0, 6.8 ) QPointF( 4.0, 7.9 ) QPointF( 5.0, 7.1 ); // give some points to the curve curve- setSamples( points ); // set the curve in the plot curve- attach( plot ); plot.resize( 600, 400 ); plot.show(); return a.exec(); } Dies ergibt ein (noch ziemlich langweiliges) Diagrammfenster:","title":"Ein Kurvendiagramm"},{"location":"basics/#include-dateien","text":"Grunds\u00e4tzlich gibt es zwei unterschiedliche Varianten f\u00fcr Include-Dateinamen - entweder man verwendet die tats\u00e4chlichen Header-Dateinamen, also z.B. #include qwt_plot.h f\u00fcr die Klasse QwtPlot , oder man verwendet die klassenspezifischen Headerdateien #include QwtPlot (das sind Verweise auf die eigentlichen Headerdateien, wie bei Qt5 \u00fcblich). Da manche Headerdateien die Deklarationen f\u00fcr verschiedene Qwt-Klassen enthalten, ist es h\u00e4ufig einfacher bei Kenntniss des Klassennames auch einfach die entsprechend gleichnamigen Headerdateien zu verwenden. Hinweis: In den nachfolgenden Beispielen werden die neuen Headerdateinamen (=Klassennamen) verwendet. In den Beispielen im examples -Verzeichnis der Qwt-Bibliothek werden die eigentlichen Headerdateinamen eingebunden.","title":"Include-Dateien"},{"location":"basics/#plot-widget-und-hintergrundfarbe-der-zeichenflache","text":"Im obigen Quelltext wird zun\u00e4chst das QwtPlot Widget erstellt und erh\u00e4lt einen Titel. Der CanvasBackground ist der Hintergrund der Zeichenfl\u00e4che. Der Befehl: plot.setCanvasBackground( Qt::white ); legt nur die Hintergrundfarbe der eigentlichen Zeichenfl\u00e4che (engl. Canvas ) fest (siehe auch Erscheinungsbild des Plots anpassen ).","title":"Plot-Widget und Hintergrundfarbe der Zeichenfl\u00e4che"},{"location":"basics/#kurve-als-zeichenobjekt-hinzufugen","text":"Als n\u00e4chstes wird ein Zeichenobjekt (engl. PlotItem ) f\u00fcr eine Linie/Kurve erstellt und konfiguriert. Es gibt viele verschiedene Arten von Zeichenobjekten. Alle haben gemeinsam, dass sie auf der Zeichenfl\u00e4che gezeichnet werden. Die Reihenfolge des Zeichnens ist dabei f\u00fcr die Sichtbarkeit der einzelnen Zeichenobjekte wichtig (dazu sp\u00e4ter mehr, siehe Abschnitt Zeichenreihenfolge ). Grunds\u00e4tzlich werden alle Zeichenobjekte auf dem Heap (im Hauptspeicher) erstellt und sp\u00e4ter dem Plot \u00fcbereignet. Das passiert mit: curve- attach( plot ); wobei das Plot Besitzer des Zeichenobjekts (d.h. unserer Kurve) wird und sich sp\u00e4ter um das Speicheraufr\u00e4umen k\u00fcmmert. Zu den sinnvoll anzupassenden Eigenschaften einer Kurve geh\u00f6ren die Farbe und die Linienst\u00e4rke, siehe QwtPlotCurve::setPen() . Bei dicken Linien lohnt sich das Einschalten von Antialiasing f\u00fcr die Liniendarstellung. Hinweis: Das Setzen von Zeichenattributen via setRenderHint() wird von allen Zeichenobjekten unterst\u00fctzt. So kann man Eigenschaften wie Antialiasing individuell f\u00fcr verschiedene Zeichenobjekte setzen. Die hinzugef\u00fcgte Kurve ist standardm\u00e4\u00dfig der unteren X-Achse und der linken Y-Achse zugeordnet, sodass die Daten der Kurve gleichzeitig zur automatischen Skalierung der Achsen verwendet werden. Der Titel der Linie wird mittels QwtPlotCurve::setTitle() gesetzt und in der Legende verwendet, welche wir als n\u00e4chstes einf\u00fcgen (weitere Kurveneigenschaften werden sp\u00e4ter besprochen).","title":"Kurve als Zeichenobjekt hinzuf\u00fcgen"},{"location":"basics/#legende-diagrammachsen-und-hauptgitterlinien","text":"","title":"Legende, Diagrammachsen und Hauptgitterlinien"},{"location":"basics/#legende-hinzufugen","text":"Um eine Legende hinzuzuf\u00fcgen, braucht man lediglich eine Instanz der QwtLegend -Klasse erstellen und im Plot einf\u00fcgen: QwtLegend * legend = new QwtLegend(); plot.insertLegend( legend , QwtPlot::BottomLegend); Der dazugeh\u00f6riger Header wird mittels #include QwtLegend eingebunden. Wie auch beim Zeichenobjekt (Kurve) wird das Plot Besitzer der Legende und verwaltet die Resource. Hinweis: Wird eine andere Legende gesetzt, so wird die alte zuerst gel\u00f6scht. Es ist daher nicht erlaubt, auf eine ersetzte Legende weiterhin zuzugreifen (um das zu umgehen, siehe auch Besitz\u00fcbernahme von Objekten des Plots ). Weitere Eigenschaften der Legende werden im Kapitel zur Legendenformatierung erl\u00e4utert.","title":"Legende hinzuf\u00fcgen"},{"location":"basics/#diagrammachsen-konfigurieren","text":"Im Gegensatz zu Legende oder Kurven sind Achsen keine Zeichenobjekte sondern fest mit dem Diagramm verbunden. Die Sichtbarkeit der 4 Achsen (links, rechts, oben und unten) kann jedoch individuell festgelegt werden. Achseneigenschaften legt man direkt \u00fcber Zugriffsfunktionen der QwtPlot -Klasse fest, wie z.B. selbstgew\u00e4hlte min/max-Werte: plot.setAxisScale( QwtPlot::yLeft, 0.0, 10.0 ); Die Achsen werden durch QwtPlot::yLeft , QwtPlot::yRight , QwtPlot::xBottom und QwtPlot::xTop identifiziert.","title":"Diagrammachsen konfigurieren"},{"location":"basics/#gitterraster-einfugen","text":"Um in der Zeichenfl\u00e4che Gitterlinien zu zeichnen, f\u00fcgt man einfach ein entsprechendes Zeichenobjekt hinzu. QwtPlotGrid *grid = new QwtPlotGrid(); grid- setMajorPen(QPen(Qt::DotLine)); grid- attach( plot ); Wie schon bei der Legende wird die Instanz der Klasse QwtPlotGrid (einzubinden via #include QwtPlotGrid ) zun\u00e4chst im Hauptspeicher angelegt, konfiguriert (hier wird nur der QPen der Hauptgitterlinien ver\u00e4ndert) und schlie\u00dflich dem Plot hinzugef\u00fcgt.","title":"Gitterraster einf\u00fcgen"},{"location":"basics/#liniensymbole-hinzufugen","text":"Als ein Beispiel etwas weiterf\u00fchrender Konfiguration der Linien ( QwtPlotCurve ) wird hier ein Liniensymbol hinzugef\u00fcgt. Diese Eigenschaft (konkret das Zeichnen des Symbols) ist wieder anpassungsf\u00e4hig ausgelegt und nicht fest in der Klasse QwtPlotCurve integriert. F\u00fcr das Zeichnen von Symbolen existiert die Klasse QwtSymbol , welche nicht direkt als Zeichenobjekt verwendet wird, sondern eine Hilfsimplementierung f\u00fcr verschiedene Anwendungszwecke darstellt. Liniensymbole werden folgenderma\u00dfen erstellt: QwtSymbol *symbol = new QwtSymbol( QwtSymbol::Ellipse, // Form QBrush( Qt::yellow ), // F\u00fcllung QPen( Qt::red, 2 ), // Rand QSize( 8, 8 ) ); // Gr\u00f6\u00dfe in Pixel curve- setSymbol( symbol ); // Kurve wurde Besitzer Mit diesen Anpassungen sieht das Diagramm schon besser aus (siehe auch Beispiel examples/SimplePlot )","title":"Liniensymbole hinzuf\u00fcgen"},{"location":"basics/#diagrammtypen","text":"allgemeines zu PlotItems/Curves","title":"Diagrammtypen"},{"location":"basics/#liniendiagramme-und-punktwolken","text":"Liniendiagramme, Punktwolken oder sonstige X-Y-Datenreihen werden mittels QwtPlotCurve Diagrammtypen gezeichnet. Wie im Beispiel oben wird eine Instanz einer solchen PlotCurve erstellt und dem Diagramm angehangen. Die Attribute einer QwtPlotCurve sind vielf\u00e4ltigt: CurveStyle - legt fest, wie die Datenpunkte gezeichnet werden sollen CurveAttribute - Zeichenattribute LegendAttribute - beinflusst die Darstellung der Legendensymbole PaintAttribute - Performance-bezogene Darstellungsoptionen Symbole (Marker) werden via QwtPlotCurve::setSymbol() hinzugef\u00fcgt.","title":"Liniendiagramme und Punktwolken"},{"location":"basics/#entfernen-von-kurven","text":"Kurven k\u00f6nnen Diagrammen entnommen oder nur ausgeblendet werden: mittels curve- detach() wird die Kurve dem Diagramm und der Legende entnommen (der Speicher der Kurve wird nicht freigegeben!), unsichtbar schalten mittels curve- setVisible(false) , oder alternativ Linientyp auf NoCurve und Symbol entfernen: curve- setStyle(QwtPlotCurve::NoCurve); curve- setSymbol(NULL); Bei Variante (2) und (3) bleibt der Legendeneintrag aber bestehen. Da kann man dann aber immer noch den Legendeneintrag ausblenden: // das LegendenWidget, d.h. Legendeneintrag von der Legende holen QWidget* legendWidget = d_legend- legendWidget(itemToInfo(plotCurve)); // Standardm\u00e4\u00dfig ist das Widget des Legendeneintrags vom Typ QwtLegendLabel QwtLegendLabel* label = qobject_cast QwtLegendLabel* (legendWidget); label- setVisible(true);","title":"Entfernen von Kurven"},{"location":"basics/#feststellen-ob-eine-kurve-hinzugefugt-ist","text":"QwtPlotCurve::plot() liefert einen Zeiger auf das Diagramm, dem die Kurve hinzugef\u00fcgt wurde, oder NULL , wenn die Kurven derzeit keinem Plot zugeordnet ist.","title":"Feststellen, ob eine Kurve hinzugef\u00fcgt ist"},{"location":"basics/#balkendiagramme","text":"Balkendiagramme zeigen Datenreihen als Balken, entweder horizontal oder vertikal. Dabei k\u00f6nnen die Balken groupiert oder aufeinandergestapelt angezeigt werden: Das Beispiel barchart demonstriert die Erstellung: // zuerst ein PlotItem f\u00fcr Balkendiagramme erstellen QwtPlotMultiBarChart * d_barChartItem = new QwtPlotMultiBarChart( Bar Chart ); // die Breite der Balken soll automatische anhand der Achsenskalierung // und Widgetbreite bestimmt werden d_barChartItem- setLayoutPolicy( QwtPlotMultiBarChart::AutoAdjustSamples ); // man kann die Abst\u00e4nde zwischen den Balken konfigurieren d_barChartItem- setSpacing( 20 ); d_barChartItem- setMargin( 3 ); // und wie immer wir zuletzt das PlotItem dem Diagramm hinzugef\u00fcgt d_barChartItem- attach( this ); Eine Legende wird genau wie bei anderen Diagrammtypen hinzugef\u00fcgt (siehe auch Legenden ). Es ist eventuell sinnvoll, die Legendenicongr\u00f6\u00dfe anzupassen. Da die Legendenicons vom jeweiligen Diagrammelement generiert werden (hier vom QwtPlotMultiBarChart), setzt man die Legendenicongr\u00f6\u00dfe auch dar\u00fcber: d_barChartItem- setLegendIconSize( QSize( 10, 14 ) ); Die Daten eines Balkendiagramms sind in Datenpunkte (engl. samples ) und Balken (engl. bars ) organisiert. Jeder Datenpunkt entspricht einem X-Achsenwert (bei vertikalen Balkendiagrammen) und f\u00fcr jeden Datenpunkt werden entsprechend viele Balken (nebeneinander/\u00fcbereinander) gezeichnet. Die Beschriftung auf der X-Achse (bzw. auf der Y-Achse bei horizontalen Balken) wird mit QwtPlotMultiBarChart::setTitles() gesetzt: QList QwtText titles; titles First group ; titles Second group ; titles Third group ; d_barChartItem- setBarTitles( titles ); Das Erscheinungsbild der Balken definiert man durch Erstellen und Setzen von QwtColumnSymbol Objekten: // Balkenfarben definieren static const char *colors[] = { DarkOrchid , SteelBlue , Gold }; const int numBars = 3; // F\u00fcr jeden Balken ein Symbol definieren for ( int i = 0; i numBars; i++ ) { QwtColumnSymbol *symbol = new QwtColumnSymbol( QwtColumnSymbol::Box ); // Die Konfiguration ist \u00e4hnlich der regul\u00e4rer Widgets symbol- setLineWidth( 2 ); // Pixel-Dimension symbol- setFrameStyle( QwtColumnSymbol::Raised ); symbol- setPalette( QPalette( colors[i] ) ); d_barChartItem- setSymbol( i, symbol ); } Die eigentlich Daten werden in einer Matrix definiert, welche zum Beispiel in einem Container QVector QVector double abgelegt werden k\u00f6nnen. Der erste Index ist die Nummer des \"Samples\" (der Gruppe), der zweite Index entspricht dem Balkenindex der jeweiligen Gruppe: int numSamples = 5; // 5 Gruppen QVector QVector double samples; for ( int i = 0; i numSamples; i++ ) { QVector double values(numBars); // setzen der Werte values[0] = barValue1; values[1] = barValue2; values[2] = barValue3; // ... // hinzuf\u00fcgen zur samples-Matrix samples.append(values); } // Abschlie\u00dfend werden dem BarPlot die Daten \u00fcbergeben d_barChartItem- setSamples( samples ); Ein derart erstelltes BarChart sieht zun\u00e4chst so aus: Die Samples sind standardm\u00e4\u00dfig ganzzahligen X-Koordinaten (0,1,2...) zugeordnet. Die Achsen werden ganz genauso wie bei anderen Diagrammtypen angepasst (siehe Achsen ). \u00dcblicherweise werden bei Balkendiagrammen jedoch keine Ticks und Ticklabels angezeigt. Daher kann man diese ausstellen: // Zugriff auf das Zeichenobjekt f\u00fcr die Achsen holen QwtScaleDraw *scaleDraw1 = plot- axisScaleDraw( QwtPlot::xBottom ); // Die Achsenlinie und die Ticks lassen sich individuell abschalten scaleDraw1- enableComponent( QwtScaleDraw::Backbone, false ); scaleDraw1- enableComponent( QwtScaleDraw::Ticks, false ); Die Balken jeder Gruppe werden zentriert um die zugeordnete Koordinate gezeichnet, wodurch effektiv eine Skale verwendet wird, die in den negativen Bereich geht. Wird die Zeichenfl\u00e4che auf die Koordinatenachse ausgerichtet, so werden die Balken am linken und rechten Rand abgeschnitten. F\u00fcr vertikale Balken l\u00e4sst sich das \u00fcber die folgenden Befehle ausschalten: // linksseitig nicht bei 0 abschneiden plotLayout()- setAlignCanvasToScale( QwtPlot::yLeft, false ); // rechtsseitig nicht beim Maximalwert der X-Achse aufh\u00f6ren plotLayout()- setAlignCanvasToScale( QwtPlot::yRight, false );","title":"Balkendiagramme"},{"location":"basics/#spezielle-beschriftungen","text":"Manchmal m\u00f6chte man die Balkengruppe besonders beschriften, wie in folgendem Beispiel: Dieses ist mit Qwt 6.1.x und den eingebauten Eigenschaften so nicht m\u00f6glich. Kapitel Balkendiagramme mit Kategoriebeschriftungen beschreibt die Vorgehensweise, um mit eigens angepassten Klassen, diese Diagramme zu erstellen.","title":"Spezielle Beschriftungen"},{"location":"basics/#balken-entfernen-und-wieder-hinzufugen","text":"Balken k\u00f6nnen mittels QwtPlotMultiBarChart::setVisible() sichtbar oder unsichtbar geschaltet werden. Dabei bleibt jedoch der entsprechende Legendeneintrag in der Liste. M\u00f6chte man den Balken einschlie\u00dflich Legendenicon entfernen, so muss man das Balkendiagramm neu konfigurieren, d.h. neue Titel und neue Daten (mit passender Dimension des Samples-Matrix) setzen. TODO: eleganter Weg einzelne Balken auszublenden?","title":"Balken entfernen und wieder hinzuf\u00fcgen"},{"location":"basics/#spektrogramme","text":"erste Anwendung der Re-Implementierungstechnik value() Berechnung spezielle Optimierungen","title":"Spektrogramme"},{"location":"basics/#vektorfelder","text":"ab 6.3.x_trunk Eingangsdaten, Interpretation Konfiguration","title":"Vektorfelder"},{"location":"basics/#erscheinungsbild-des-plots-anpassen","text":"","title":"Erscheinungsbild des Plots anpassen"},{"location":"basics/#rahmen-und-zeichenflache","text":"Beim QwtPlot k\u00f6nnen verschiedene Elemente angepasst werden. Nachfolgend ist ein QwtPlot zu sehen, welches in einem \u00e4u\u00dferen Widget (dunkelgray) eingebettet ist. Die hellgraue Fl\u00e4che ist das eigentliche QwtPlot : Im Screenshot sind die wichtigsten Attribute markiert: Innenabstand (siehe QWidget::setContentsMargins() ) Rahmen (haupts\u00e4chlich f\u00fcr den Druck wichtig) Hintergrund des Plot-Widgets Zeichenfl\u00e4che (engl. Canvas ) (betrifft Hintergrundfarbe und Rahmen)","title":"Rahmen und Zeichenfl\u00e4che"},{"location":"basics/#farbe-und-rahmen-des-plots","text":"Die Farbe des \u00e4u\u00dferen Bereichs des Plots wird \u00fcber die Paletteneigenschaft des QwtPlot kontrolliert. Standardm\u00e4\u00dfig wird der \u00e4u\u00dfere Rand des Plot-Widgets transparant gezeichnet, d.h. die Farbe des darunterliegenden Widgets ist sichtbar. Um eine eigene Farbe zu setzen, muss daher setAutoFillBackground(true) aufgerufen werden: QPalette pal = plot.palette(); // Die QPalette::Window Farbrolle definiert die Einf\u00e4rbung // des \u00e4u\u00dferen Plotbereichs pal.setColor(QPalette::Window, QColor(196,196,220)); plot- setPalette(pal); // die Eigenschaft autoFillBackground muss daf\u00fcr eingeschaltet sein plot- setAutoFillBackground(true); Hinweis: In Abschnitt Gradient als Plot-Hintergrund wird beschrieben, wie man einen Farbverlauf im Plothintergrund umsetzt, und diesen bei Gr\u00f6\u00dfen\u00e4nderung entsprechend anpasst. Der Rahmen wird wie bei einem normalen Widget angepasst: plot- setFrameStyle(QFrame::Box | QFrame::Sunken); Normalerweise ist ein solcher Rahmen nicht notwendig f\u00fcr die Bildschirmdarstellung oder f\u00fcr das Einbetten des QwtPlot in eine Programmoberfl\u00e4che. Der Rahmen ist jedoch h\u00e4ufig beim Export/Druck des Widgets sinnvoll.","title":"Farbe und Rahmen des Plots"},{"location":"basics/#zeichenflache","text":"Die Zeichenfl\u00e4che kann eingef\u00e4rbt werden: plot- setCanvasBackground(Qt::darkGray); Der Randabstand zwischen Achsenbeschriftung und Titel zum Rand kann definiert werden: plot- setContentsMargins(15,10,35,5); Die Rahmen um die Zeichenfl\u00e4che kann durch Anpassen des Zeichenfl\u00e4chenobjekts ( QwtPlotCanvas ) ver\u00e4ndert werden. QwtPlotCanvas ist von QFrame abgeleitet, wodurch es entsprechend angepasst werden kann. Es wird einfach neues Objekt erstellt, konfiguriert und dem Plot \u00fcbergeben (das QwtPlot wird neuer Besitzer des Zeichenfl\u00e4chenobjekts): QwtPlotCanvas * canvas = new QwtPlotCanvas( plot); canvas- setPalette(Qt::white); canvas- setFrameStyle(QFrame::Box | QFrame::Plain ); canvas- setLineWidth(1); plot- setCanvas(canvas); Einfacher geht es durch Setzen des Stylesheets f\u00fcr das Canvas-Widget (siehe Qt-Widgets Dokumentation, welche Attribute unterst\u00fctzt werden): plot- canvas()- setStyleSheet( border: 1px solid Black; border-radius: 15px; background-color: qlineargradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 LemonChiffon, stop: 1 PaleGoldenrod ); );","title":"Zeichenfl\u00e4che"},{"location":"basics/#erweiterte-anpassungen","text":"Wie das Layout der Achsen, Legende, Titel, Kopf- und Fu\u00dfzeile und die jeweiligen Abst\u00e4nde zus\u00e4tzlich angepasst werden k\u00f6nnen, ist in Kapitel Das Layout-System beschrieben.","title":"Erweiterte Anpassungen"},{"location":"basics/#diagrammelemente","text":"","title":"Diagrammelemente"},{"location":"basics/#titel-kopf-und-fuzeile","text":"wo sind die RichText-Unterst\u00fctzung (HTML Tags)","title":"Titel, Kopf- und Fu\u00dfzeile"},{"location":"basics/#kurven","text":"Attribute von Kurven Erscheinungsbild und Wirkung von RenderHints Zeichenreihenfolge (anpassen)","title":"Kurven"},{"location":"basics/#legenden","text":"Grunds\u00e4tzlich kann ein QwtPlot zwei Legenden haben, und diese sogar gleichzeitig: eine au\u00dfenliegende Legende, und/oder eine Legende innerhalb der Zeichenfl\u00e4che (\u00fcber oder unter den anderen Diagrammelementen) Die Eintr\u00e4ge der Legenden werden von den jeweiligen Diagrammtypen (Linen-, Balken-, Farbverlaufsdiagramme) beigesteuert und auch von diesen gezeichnet. Die Legende verwaltet nur deren Positionierung innerhalb der Legende.","title":"Legenden"},{"location":"basics/#auenliegende-legenden","text":"Eine au\u00dfenliegende Legende bedeutet, dass ein regul\u00e4res Widget die Legende h\u00e4lt und seitlich (oben, unten, links oder rechts) der Zeichenfl\u00e4che angeordnet ist. Dieses Widget kann auch abseits des QwtPlot in einem anderen Teil des Layouts angeordnet werden. In diesem Fall spricht man von einer externen Legende . Dazu wird eine Instanz der Klasse QwtLegend erstellt und dem Diagramm hinzugef\u00fcgt: QwtLegend * d_legend = new QwtLegend; insertLegend(d_legend, QwtPlot::RightLegend); Dabei ist QwtLegend ein ganz regul\u00e4res Widget. Intern enthalten Sie ein dynamisches Rasterlayout (Klasse QwtDynGridLayout ), welches die Legendeneintr\u00e4ge je nach verf\u00fcgbarem Platz mehrspaltig auslegt.","title":"Au\u00dfenliegende Legenden"},{"location":"basics/#maximale-anzahl-der-spalten-in-der-legende","text":"Die Anzahl der maximal zu verwendenden Spalten wird mittels QwtLegend::setMaxColumns( uint numColums ) festgelegt. Ein Wert von 0 (Standard) definert keine Begrenzung. Das ist f\u00fcr Legenden unterhalb und oberhalb des Plots sinnvoll, da hier auch mitunter sehr viele Legendeneintr\u00e4ge nebeneinander gezeichnet werden sollen. Links- und rechtsseitig angeordnete Legenden haben aber \u00fcblicherweise nur eine Spalte: // links und rechtsseitige Legenden sollen nur eine Spalte verwenden d_legend- setMaxColumns(1);","title":"Maximale Anzahl der Spalten in der Legende"},{"location":"basics/#positionierung-der-legende","text":"Die Positionierung der Legende wird beim Einf\u00fcgen der Legende festgelegt. QwtPlot::insertLegend() erwartet einen der vier m\u00f6glichen Parameter: QwtPlot::BottomLegend , QwtPlot::TopLegend , QwtPlot::RightLegend , QwtPlot::LeftLegend . Wird die Funktion insertLegend() ein weiteres Mal aufgerufen, so wird zun\u00e4chst die alte Legende gel\u00f6scht (auch der Speicher wird freigegeben) und dann wird die neue Legende eingef\u00fcgt.","title":"Positionierung der Legende"},{"location":"basics/#legende-entfernen","text":"Ruft man QwtPlot::insertLegend() mit einem NULL-Zeiger auf, so wird die bisherige Legende gel\u00f6scht, aber keine neue eingef\u00fcgt. Damit entfernt das Plot auch das Legendenwidget. Hinweis : Der Abschnitt Besitz\u00fcbernahme von Objekten des Plots zeigt einen Trick, wie man z.B. eine Legende dem Plot tempor\u00e4r entnehmen kann und sp\u00e4ter wieder hinzuf\u00fcgen kann, ohne dass das Legendenobjekt neu im Speicher erstellt werden muss.","title":"Legende entfernen"},{"location":"basics/#abstande-zwischen-legendeneintragen","text":"Bei einer au\u00dfenliegende Legende sind die eigentlichen Legendeneintr\u00e4ge selbst Widgets die in einem dynamischen GridLayout angeordnet sind. Das dynamische GridLayout steckt selbst in einer QScrollArea-Widget, weswegen die Legende bei zu wenig Platz mit Scrollbalken ausgestattet wird. Auf dieses QScrollArea-Widget kann man mittels QwtLegend::contentsWidget() zugreifen, und dar\u00fcber auf das dynamische GridLayout. Wie bei anderen QLayout-Klassen lassen sich die Abst\u00e4nde zwischen den Widgets mit QLayout::setSpacing() anpassen. Interessant ist das vor allem bei umschaltbaren/anklickbaren Legendeneintr\u00e4gen : // verkleinern der Abst\u00e4nde zwischen den Legendeneintr\u00e4gen d_legend- contentsWidget()- layout()- setSpacing(1); So lassen sich auch Legenden mit vielen Eintr\u00e4gen recht kompakt anzeigen:","title":"Abst\u00e4nde zwischen Legendeneintr\u00e4gen"},{"location":"basics/#rahmen-und-farbiger-hintergrund-bei-der-legende","text":"Da QwtLegend-Objekte selber Widgets sind, l\u00e4sst sich das Erscheinungsbild entsprechend mit Qt-Standardmitteln anpassen, z.B. ein Rahmen setzen und die Hintergrundfarbe anpassen: // einfacher Rahmen d_legend- setFrameStyle(QFrame::Box|QFrame::Sunken); // Hintergrundfarbe anpassen QPalette pal = d_legend- palette(); pal.setColor(QPalette::Window, backgroundColor); d_legend- setPalette(pal); // Wichtig: Widget soll selbst den Hintergrund zeichnen d_legend- setAutoFillBackground(true); Gegen\u00fcber der Standardeinstellung (links) hebt sich die Legende dadurch optisch ab (rechts):","title":"Rahmen und farbiger Hintergrund bei der Legende"},{"location":"basics/#todo","text":"Ratio Parameter","title":"TODO"},{"location":"basics/#legendensymbole","text":"Die LegendIcons bzw. allgemein die Eintr\u00e4ge in der Legende werden vom jeweiligen PlotItem bzw. der Kurve generiert. Entsprechende Anpassungsfunktionen sind daher f\u00fcr die jeweiligen Diagrammtypklassen verf\u00fcgbar, d.h. in QwtPlotCurve , QwtPlotSpectrogram und QwtPlotMultiBarChart definiert. Man kann die Legendeneintr\u00e4ge auch komplett selbst zeichnen, wie im Kapitel Eigene Legendeneintr\u00e4ge zeichnen beschrieben ist.","title":"Legendensymbole"},{"location":"basics/#darstellung-der-legendeneintrage-bei-kurven-linie-rechteck-oder-farbe","text":"... QwtPlotCurve::setLegendAttribute()","title":"Darstellung der Legendeneintr\u00e4ge bei Kurven: Linie, Rechteck oder Farbe?"},{"location":"basics/#innenliegende-legenden","text":"Skizze mit relevanten Abmessungen Konfiguration Offset (Version 6.1.x und 6.3.x_trunk)","title":"Innenliegende Legenden"},{"location":"basics/#achsen","text":"allgemeines zum Zusammenspiel zwischen ScaleDiv und ScaleDraw, wie werden diese von Achsen verwendet woher erhalten Achsen die Werte","title":"Achsen"},{"location":"basics/#sichtbarkeit-der-achsen","text":"Achsen k\u00f6nnen individuell sichtbar oder versteckt geschaltet werden. Standardm\u00e4\u00dfig sind die xBottom-Achse und die yLeft-Achse sichtbar. Die Sichtbarkeit wird mit QwtPlot::enableAxis(axisID, on) umgeschaltet.","title":"Sichtbarkeit der Achsen"},{"location":"basics/#achsentitel","text":"Achsentitel werden mittels QwtPlot::setAxisTitle(int axisId, const QwtText title) gesetzt.","title":"Achsentitel"},{"location":"basics/#achsentitel-invertierenvon-rechts-lesbar-machen","text":"Bei technischen Diagrammen ist es \u00fcblich, den Titel der rechten y-Achse von rechts lesbar zu zeichnen. Dies wird durch Setzen eines LayoutFlags des Achsenwidgets erreicht: plot- axisWidget(QwtPlot::yRight)- setLayoutFlag(QwtScaleWidget::TitleInverted, false);","title":"Achsentitel invertieren/von rechts lesbar machen"},{"location":"basics/#achsenbeschriftung-zahlendatumzeit","text":"Die Achsentitel k\u00f6nnen ferner rotiert und positioniert werden, wof\u00fcr die Funktionen void setAxisLabelAlignment( int axisId, Qt::Alignment ); void setAxisLabelRotation( int axisId, double rotation ); verwendet werden. Der Rotationswinkel wird hierbei in Grad angegeben. Je nach Rotation muss man den Abstand zwischen Label und Achse anpassen, bzw. die Ausrichtung (Alignment) ver\u00e4ndern. F\u00fcr die untere X-Achse sind folgende Einstellungen sinnvoll: // Senkrechte Beschriftung, von rechts lesbar plot- setAxisLabelRotation(QwtPlot::xBottom, -90); plot- setAxisLabelAlignment(QwtPlot::xBottom, Qt::AlignLeft | Qt::AlignVCenter); // 45\u00b0 Beschriftung plot- setAxisLabelRotation(QwtPlot::xBottom, -45); plot- setAxisLabelAlignment(QwtPlot::xBottom, Qt::AlignLeft | Qt::AlignBottom);","title":"Achsenbeschriftung (Zahlen/Datum/Zeit)"},{"location":"basics/#lineare-achsen-und-deren-eigenschaften","text":"...","title":"Lineare Achsen und deren Eigenschaften"},{"location":"basics/#logarithmische-achsen-und-andere-transformationen","text":"... Beispiel: scaleengine","title":"Logarithmische Achsen und andere Transformationen"},{"location":"basics/#datums-zeit-achsen","text":"Werte in ms (Epoche) Formatierung, Zoomstufen","title":"Datums-/Zeit-Achsen"},{"location":"basics/#bereichsmarkierungen","text":"Ein horizontales oder vertikales Band als Hervorherbung kann durch ein QwtPlotZoneItem erstellt werden: QwtPlotZoneItem* zone = new QwtPlotZoneItem(); zone- setPen( Qt::darkGray ); zone- setBrush( QColor( #834358 ) ); // Ausrichtung: vertikales oder horizontales Band zone- setOrientation( Qt::Horizontal ); // Der Bereich des Bandes in Koordinateneinheiten zone- setInterval( 3.8, 5.7 ); // Hinzuf\u00fcgen zum Diagramm zone- attach( this );","title":"Bereichsmarkierungen"},{"location":"basics/#zeichenreihenfolge","text":"Alle Elemente, die innerhalb der Zeichenfl\u00e4chte gezeichnet werden, sind von QwtPlotItem abgeleitet. Diese Klasse hat die Eigenschaft zValue, welche die Zeichenreihenfolge definiert. H\u00f6here Werte bedeuten wie kontrolliert man die Zeichenreihenfolge (zValues) Standardreihenfolge beim Zeichnen","title":"Zeichenreihenfolge"},{"location":"basics/#basisdatentypen","text":"Die Qwt-Bibliothek bringt einige grundlegende Datentypen/Klassen mit, welche die Datentypen der Qt Bibliothek erweitert.","title":"Basisdatentypen"},{"location":"basics/#qwttext","text":"Die Klasse QwtText ersetzt die QString Klasse und erlaubt die Definition von Texten, welche auf unterschiedliche Art und Weise interpretiert und damit gezeichnet werden k\u00f6nnen. Man kann mittels der QwtText Klasse unter anderem HTML-basierten RichText verwenden, z.B. f\u00fcr die Hoch- und Tiefstellung von Zahlen bei Einheiten: // Ein Achsentitel mit HTML-basierter Hochstellung QwtText axisTitle(tr( Area [m sup 2 /sup ] ), QwtText::RichText); Nat\u00fcrlich k\u00f6nnen auf diese Weise auch beliebig in HTML formatierte Texte verwendet werden. QwtText wird bei allen Zugriffsfunktionen verwendet, bei dehnen eine Zeichenkette verlangt wird.","title":"QwtText"},{"location":"basics/#textengine","text":"","title":"TextEngine"},{"location":"basics/#paintattributes-and-layoutattributes","text":"","title":"PaintAttributes and LayoutAttributes"},{"location":"basics/#datenhalteklassen","text":"","title":"Datenhalteklassen"},{"location":"basics/#qwtrasterdata","text":"","title":"QwtRasterData"},{"location":"basics/#qwtintervalsample","text":"","title":"QwtIntervalSample"},{"location":"basics/#qwtsetsample","text":"","title":"QwtSetSample"},{"location":"basics/#qwtohlcsample","text":"","title":"QwtOHLCSample"},{"location":"basics/#qwtvectorsample-ab-qwt-63x","text":"","title":"QwtVectorSample (ab Qwt 6.3.x)"},{"location":"building/","text":"Verwendung der Bibliothek in eigenen Programmen Wie bei anderen externen Bibliotheken, gibt es grunds\u00e4tzlich zwei M\u00f6glichkeiten, die Qwt-Bibliothek in eigenen Projekten zu verwenden: Verwendung einer installierten, kompilierten Bibliothek unter Verwendung der installierten Headerdateien und Bibliotheken Verwendung der Qwt-Bibliothek im Quelltext innerhalb der eigenen Projektstruktur Unter Linux-Systemen (bzw. unter MacOSX, wenn Qwt \u00fcber Homebrew oder MacPorts installiert ist), wird zumeist die Variante 1 sinnvoll sein. Variante 2 ist stets dann sinnvoll, wenn man Zugriff auf die Implementierung der Qwt-Bibliothek haben m\u00f6chte und gegebenenfalls eigene \u00c4nderungen einbringen m\u00f6chte, oder wenn man mit einer noch nicht ver\u00f6ffentlichten Version aus einem Quelltextarchiv arbeiten will. Auch f\u00fcr die Verwendung von Visual Studio unter Windows ist die Variante 2 am sinnvollsten, da so flexibel zwischen Debug und Release-Builds umgeschaltet werden kann (siehe Visual Studio Projekte ). Installation von vorkompilierten Bibliotheken aus Linux-Paketrepositories Bei popul\u00e4ren Linux-Distributionen gibt es Pakete f\u00fcr die Qwt-Bibliothek. Bei Ubuntu sind das beispielsweise: Ubuntu 16.04 LTS : # Qwt 5.x unter Verwendung von qt4 (f\u00fcr Qwt 5.2.3-1) sudo apt install libqwt5-qt4-dev # Qwt 6.x unter Verwendung von qt5 (f\u00fcr Qwt 6.1.2-5) sudo apt install libqwt-qt5-dev Ubuntu 18.04 LTS : # Qwt 5.x unter Verwendung von qt4 (f\u00fcr Qwt 5.2.3-1) sudo apt install libqwt5-qt4-dev # Qwt 6.x unter Verwendung von qt4 (f\u00fcr Qwt 6.1.3-1) sudo apt install libqwt-dev # Qwt 6.x unter Verwendung von qt5 (f\u00fcr Qwt 6.1.3-1) sudo apt install libqwt-qt5-dev Bei anderen Linux-Distributionen ist das \u00e4hnlich. Installation mittels HomeBrew auf dem Mac F\u00fcr neuere Mac-Versionen (sierra bis mojave) kann man HomeBrew verwenden: brew install qwt F\u00fcr \u00e4ltere Versionen kann man Qwt aus dem Quelltextarchiv installieren (siehe unten). Installation vom Quelltextarchiv (alle Plattformen) Die jeweils aktuellste Qwt-Bibliothek kann vom SourceForge-Repository heruntergeladen werden: Qwt SourceForge Projektseite . Entweder man entpackt die zip-Datei eines Releases, oder man checkt the Quelltext des subversion-Repositories aus. Das Quelltextarchiv (aktueller Stand im Repository) enth\u00e4lt folgende Verzeichnisstruktur: admin # Deployment-Scripte, nur im Repository classincludes # Include-Dateien im Still von Qt5 Includes (ab Qwt 6.2) designer/ # Quelltext der Designer-Plugins doc/ # Doxygen Konfigurationsdateien examples/ # Beispiele playground/ # Zus\u00e4tzliche Tests/Beispiele, ab Qwt 6.2 src/ # Der eigentliche Quelltext tests/ # spez. Komponententests, ab Qwt 6.2 textengines/ # Zusatzkomponenten f\u00fcr Texte (MathML), ab Qwt 6.3 qwtbuild.pri # Grundlegende Kompilierungseinstellungen qwtconfig.pri # Auswahl der zu kompilierenden Teile qwt.pro # Haupt QMake-pro-Datei Im Verzeichnis gibt es die Datei qwtconfig.pri , welche gut dokumentiert ist und einige Anpassungen an den zu verwendenden/zu erstellenden Qwt-Komponenten erlaubt. Beispielsweise k\u00f6nnen durch Einschalten der Zeile die Beispiele erstellt werden. QWT_CONFIG += QwtExamples Nach der Anpassung der Konfigurationsdatei wird die Bibliothek erstellt. Erstellen und Installation der Bibliothek unter Linux/Mac MacOSX Anpassung : In der Datei designer/designer.pro den Text: target.path = $${QWT_INSTALL_PLUGINS} INSTALLS += target } else { TEMPLATE = subdirs # do nothing } mit target.path = $${QWT_INSTALL_PLUGINS} INSTALLS += target macx { contains(QWT_CONFIG, QwtFramework) { QWT_LIB = qwt.framework/Versions/$${QWT_VER_MAJ}/qwt } else { QWT_LIB = libqwt.$${QWT_VER_MAJ}.dylib } QMAKE_POST_LINK = install_name_tool -change $${QWT_LIB} $${QWT_INSTALL_LIBS}/$${QWT_LIB} $(DESTDIR)$(TARGET) } } else { TEMPLATE = subdirs # do nothing ersetzen. MacOSX Anpassung Ende Im Wurzelverzeichnis werden auf der Kommandozeile folgende Befehler ausgef\u00fchrt: qmake make # oder make -j4 sudo make install Standardm\u00e4\u00dfig wird Qwt in folgende Verzeichnisse installiert (weswegen sudo ben\u00f6tigt wird): /usr/local/qwt- version also z.B.: Include-Dateien in : /usr/local/qwt-6.1.4/include Bibliothek in : /usr/local/qwt-6.1.4/lib Dokumentation in : /usr/local/qwt-6.1.4/doc Erstellen und Installation der Bibliothek unter Windows Je nach verf\u00fcgbarem Compiler ist das Prozedere etwas anders, aber meist sehr \u00e4hnlich. Ist der Qt Creator samt Compiler bereits eingerichtet, kann man die qwt.pro -Datei einfach als Projekt in Qt Creator \u00f6ffnen und im Debug/Release-Modus erstellen. Man kann dann in den Projekteinstellungen einen Deployment -Schritt konfigurieren, und dar\u00fcber dann die Bibliothek installieren. Alternativ braucht man eine Kommandozeile mit entsprechend gesetzten Umgebungsvariablen zum \u00dcbersetzen von C++-Programmen (Beispielsweise bei Visual Studio die vcvarsall.bat aufrufen). Auch die Pfade zur Qt-Installation m\u00fcssen gesetzt sein, sodass qmake im Pfad ist. Beispiel: :: Entwicklungsumgebung f\u00fcr VC (x64) einrichten C:\\Downloads\\qwt-6.1.4 c:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\vcvarsall.bat x64 :: Pfad zu Qt setzen C:\\Downloads\\qwt-6.1.4 set PATH=%PATH%;C:\\Qt\\5.11.3\\msvc2015_64\\bin :: qmake ausf\u00fchren C:\\Downloads\\qwt-6.1.4 qmake Info: creating stash file C:\\Downloads\\qwt-6.1.4\\.qmake.stash :: erstellen C:\\Downloads\\qwt-6.1.4 nmake :: installieren C:\\Downloads\\qwt-6.1.4 nmake install Standardm\u00e4\u00dfig wird Qwt in folgende Verzeichnisse installiert: C:\\Qwt- version also z.B.: Include-Dateien in : C:\\Qwt-6.1.4\\include Bibliothek in : C:\\Qwt-6.1.4\\lib Dokumentation in : C:\\Qwt-6.1.4\\doc M\u00e4chte man \"am Ball\" bleiben und Qwt gelegentlich aktualisieren, so kann man das Verzeichnis nach C:\\Qwt-6.1 umbenennen, und so die Konfiguration abh\u00e4ngiger Projekte l\u00e4ngere Zeit unver\u00e4ndert lassen, auch wenn man zwischenzeitlich eine neue Qwt-Version installiert. Verwenden der installierten Bibliothek Typische Installationspfade bei vorkompilierten Bibliotheken aus dem Paketmanager Die Installationspfade sind von der jeweiligen Linux-Distribution abh\u00e4ngig, \u00fcblicherweise liegen die Bibliotheken und Include-Pfade jedoch in den systemweiten Standardsuchverzeichnissen. Das macht die Verwendung einfach. Bei manuell installierten Bibliotheken aus dem Quelltextarchiv, k\u00f6nnen die Pfade beliebig \u00fcber den Install-Prefix angepasst werden - oder man verwendet die oben aufgef\u00fchrten Standardpfade. Konfiguration von Projektdateien Unabh\u00e4ngig vom Buildsystem (qmake, cmake, Visual Studio, ...) muss der Pfad zur Datei qwt.h im Suchpfad stehen. Ebenso muss der Linker die libqwt-xxx.so -Datei finden (bzw. bei statisch erstellter Qwt-Bibliothek die Datei libqwt.a ). Beispielkonfiguration - Windows - Qmake INCLUDEPATH += C:\\Qwt-6.1.4\\include LIBS += -LC:\\Qwt-6.1.4\\lib -lqwt Im Debug-Modus kann auch -lqwtd verwendet werden. Beispielkonfiguration - Linux/Mac - Qmake - bei Installation aus Quelltextarchiv INCLUDEPATH += /usr/local/qwt-6.1.4/include LIBS += -L/usr/local/qwt-6.1.4/lib -lqwt Beispielkonfiguration - Linux/Mac - Qmake - bei Installation aus Paketquelle INCLUDEPATH += /usr/include/qwt LIBS += -L/usr/lib -lqwt-qt5 Der tats\u00e4chliche Bibliotheksname h\u00e4ngt von dem jeweiligen Paket der Linux-Distribution ab. Notfalls mal im Verzeichnis /usr/lib nachschauen, was da an libqwt.... -Dateien existiert. Suchpfade f\u00fcr Laufzeitbibliotheken Unter Windows muss man entweder den Pfad zur Qwt-DLL in die PATH-Variable eintragen, oder man kopiert einfach die DLL in das Verzeichnis der eigenen exe-Datei (das ist zumeist der einfachste Weg - hierbei je nach Debug/Release-Modus die passende qwtd.dll und qwt.dll linken und kopieren). Unter Linux kann man den LD_LIBRARY_PATH anpassen oder mittels RPATH den Laufzeitpfad in die Anwendung hineinkompilieren. Mehr dazu in der Qwt-Dokumentation unter doc/html/qwtinstall.html . Auch praktikabel ist unter beiden Plattformen die Erstellung und Verwendung von Qwt als statischer Bibliothek. Dies kann in der qwtconfig.pri eingestellt werden (Zeile QWT_CONFIG += QwtDll auskommentieren!). Erstellen mit Visual Studio ... TODO","title":"Erstellen und Verwenden"},{"location":"building/#verwendung-der-bibliothek-in-eigenen-programmen","text":"Wie bei anderen externen Bibliotheken, gibt es grunds\u00e4tzlich zwei M\u00f6glichkeiten, die Qwt-Bibliothek in eigenen Projekten zu verwenden: Verwendung einer installierten, kompilierten Bibliothek unter Verwendung der installierten Headerdateien und Bibliotheken Verwendung der Qwt-Bibliothek im Quelltext innerhalb der eigenen Projektstruktur Unter Linux-Systemen (bzw. unter MacOSX, wenn Qwt \u00fcber Homebrew oder MacPorts installiert ist), wird zumeist die Variante 1 sinnvoll sein. Variante 2 ist stets dann sinnvoll, wenn man Zugriff auf die Implementierung der Qwt-Bibliothek haben m\u00f6chte und gegebenenfalls eigene \u00c4nderungen einbringen m\u00f6chte, oder wenn man mit einer noch nicht ver\u00f6ffentlichten Version aus einem Quelltextarchiv arbeiten will. Auch f\u00fcr die Verwendung von Visual Studio unter Windows ist die Variante 2 am sinnvollsten, da so flexibel zwischen Debug und Release-Builds umgeschaltet werden kann (siehe Visual Studio Projekte ).","title":"Verwendung der Bibliothek in eigenen Programmen"},{"location":"building/#installation-von-vorkompilierten-bibliotheken-aus-linux-paketrepositories","text":"Bei popul\u00e4ren Linux-Distributionen gibt es Pakete f\u00fcr die Qwt-Bibliothek. Bei Ubuntu sind das beispielsweise: Ubuntu 16.04 LTS : # Qwt 5.x unter Verwendung von qt4 (f\u00fcr Qwt 5.2.3-1) sudo apt install libqwt5-qt4-dev # Qwt 6.x unter Verwendung von qt5 (f\u00fcr Qwt 6.1.2-5) sudo apt install libqwt-qt5-dev Ubuntu 18.04 LTS : # Qwt 5.x unter Verwendung von qt4 (f\u00fcr Qwt 5.2.3-1) sudo apt install libqwt5-qt4-dev # Qwt 6.x unter Verwendung von qt4 (f\u00fcr Qwt 6.1.3-1) sudo apt install libqwt-dev # Qwt 6.x unter Verwendung von qt5 (f\u00fcr Qwt 6.1.3-1) sudo apt install libqwt-qt5-dev Bei anderen Linux-Distributionen ist das \u00e4hnlich.","title":"Installation von vorkompilierten Bibliotheken aus Linux-Paketrepositories"},{"location":"building/#installation-mittels-homebrew-auf-dem-mac","text":"F\u00fcr neuere Mac-Versionen (sierra bis mojave) kann man HomeBrew verwenden: brew install qwt F\u00fcr \u00e4ltere Versionen kann man Qwt aus dem Quelltextarchiv installieren (siehe unten).","title":"Installation mittels HomeBrew auf dem Mac"},{"location":"building/#installation-vom-quelltextarchiv-alle-plattformen","text":"Die jeweils aktuellste Qwt-Bibliothek kann vom SourceForge-Repository heruntergeladen werden: Qwt SourceForge Projektseite . Entweder man entpackt die zip-Datei eines Releases, oder man checkt the Quelltext des subversion-Repositories aus. Das Quelltextarchiv (aktueller Stand im Repository) enth\u00e4lt folgende Verzeichnisstruktur: admin # Deployment-Scripte, nur im Repository classincludes # Include-Dateien im Still von Qt5 Includes (ab Qwt 6.2) designer/ # Quelltext der Designer-Plugins doc/ # Doxygen Konfigurationsdateien examples/ # Beispiele playground/ # Zus\u00e4tzliche Tests/Beispiele, ab Qwt 6.2 src/ # Der eigentliche Quelltext tests/ # spez. Komponententests, ab Qwt 6.2 textengines/ # Zusatzkomponenten f\u00fcr Texte (MathML), ab Qwt 6.3 qwtbuild.pri # Grundlegende Kompilierungseinstellungen qwtconfig.pri # Auswahl der zu kompilierenden Teile qwt.pro # Haupt QMake-pro-Datei Im Verzeichnis gibt es die Datei qwtconfig.pri , welche gut dokumentiert ist und einige Anpassungen an den zu verwendenden/zu erstellenden Qwt-Komponenten erlaubt. Beispielsweise k\u00f6nnen durch Einschalten der Zeile die Beispiele erstellt werden. QWT_CONFIG += QwtExamples Nach der Anpassung der Konfigurationsdatei wird die Bibliothek erstellt.","title":"Installation vom Quelltextarchiv (alle Plattformen)"},{"location":"building/#erstellen-und-installation-der-bibliothek-unter-linuxmac","text":"MacOSX Anpassung : In der Datei designer/designer.pro den Text: target.path = $${QWT_INSTALL_PLUGINS} INSTALLS += target } else { TEMPLATE = subdirs # do nothing } mit target.path = $${QWT_INSTALL_PLUGINS} INSTALLS += target macx { contains(QWT_CONFIG, QwtFramework) { QWT_LIB = qwt.framework/Versions/$${QWT_VER_MAJ}/qwt } else { QWT_LIB = libqwt.$${QWT_VER_MAJ}.dylib } QMAKE_POST_LINK = install_name_tool -change $${QWT_LIB} $${QWT_INSTALL_LIBS}/$${QWT_LIB} $(DESTDIR)$(TARGET) } } else { TEMPLATE = subdirs # do nothing ersetzen. MacOSX Anpassung Ende Im Wurzelverzeichnis werden auf der Kommandozeile folgende Befehler ausgef\u00fchrt: qmake make # oder make -j4 sudo make install Standardm\u00e4\u00dfig wird Qwt in folgende Verzeichnisse installiert (weswegen sudo ben\u00f6tigt wird): /usr/local/qwt- version also z.B.: Include-Dateien in : /usr/local/qwt-6.1.4/include Bibliothek in : /usr/local/qwt-6.1.4/lib Dokumentation in : /usr/local/qwt-6.1.4/doc","title":"Erstellen und Installation der Bibliothek unter Linux/Mac"},{"location":"building/#erstellen-und-installation-der-bibliothek-unter-windows","text":"Je nach verf\u00fcgbarem Compiler ist das Prozedere etwas anders, aber meist sehr \u00e4hnlich. Ist der Qt Creator samt Compiler bereits eingerichtet, kann man die qwt.pro -Datei einfach als Projekt in Qt Creator \u00f6ffnen und im Debug/Release-Modus erstellen. Man kann dann in den Projekteinstellungen einen Deployment -Schritt konfigurieren, und dar\u00fcber dann die Bibliothek installieren. Alternativ braucht man eine Kommandozeile mit entsprechend gesetzten Umgebungsvariablen zum \u00dcbersetzen von C++-Programmen (Beispielsweise bei Visual Studio die vcvarsall.bat aufrufen). Auch die Pfade zur Qt-Installation m\u00fcssen gesetzt sein, sodass qmake im Pfad ist. Beispiel: :: Entwicklungsumgebung f\u00fcr VC (x64) einrichten C:\\Downloads\\qwt-6.1.4 c:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\vcvarsall.bat x64 :: Pfad zu Qt setzen C:\\Downloads\\qwt-6.1.4 set PATH=%PATH%;C:\\Qt\\5.11.3\\msvc2015_64\\bin :: qmake ausf\u00fchren C:\\Downloads\\qwt-6.1.4 qmake Info: creating stash file C:\\Downloads\\qwt-6.1.4\\.qmake.stash :: erstellen C:\\Downloads\\qwt-6.1.4 nmake :: installieren C:\\Downloads\\qwt-6.1.4 nmake install Standardm\u00e4\u00dfig wird Qwt in folgende Verzeichnisse installiert: C:\\Qwt- version also z.B.: Include-Dateien in : C:\\Qwt-6.1.4\\include Bibliothek in : C:\\Qwt-6.1.4\\lib Dokumentation in : C:\\Qwt-6.1.4\\doc M\u00e4chte man \"am Ball\" bleiben und Qwt gelegentlich aktualisieren, so kann man das Verzeichnis nach C:\\Qwt-6.1 umbenennen, und so die Konfiguration abh\u00e4ngiger Projekte l\u00e4ngere Zeit unver\u00e4ndert lassen, auch wenn man zwischenzeitlich eine neue Qwt-Version installiert.","title":"Erstellen und Installation der Bibliothek unter Windows"},{"location":"building/#verwenden-der-installierten-bibliothek","text":"","title":"Verwenden der installierten Bibliothek"},{"location":"building/#typische-installationspfade-bei-vorkompilierten-bibliotheken-aus-dem-paketmanager","text":"Die Installationspfade sind von der jeweiligen Linux-Distribution abh\u00e4ngig, \u00fcblicherweise liegen die Bibliotheken und Include-Pfade jedoch in den systemweiten Standardsuchverzeichnissen. Das macht die Verwendung einfach. Bei manuell installierten Bibliotheken aus dem Quelltextarchiv, k\u00f6nnen die Pfade beliebig \u00fcber den Install-Prefix angepasst werden - oder man verwendet die oben aufgef\u00fchrten Standardpfade.","title":"Typische Installationspfade bei vorkompilierten Bibliotheken aus dem Paketmanager"},{"location":"building/#konfiguration-von-projektdateien","text":"Unabh\u00e4ngig vom Buildsystem (qmake, cmake, Visual Studio, ...) muss der Pfad zur Datei qwt.h im Suchpfad stehen. Ebenso muss der Linker die libqwt-xxx.so -Datei finden (bzw. bei statisch erstellter Qwt-Bibliothek die Datei libqwt.a ).","title":"Konfiguration von Projektdateien"},{"location":"building/#beispielkonfiguration-windows-qmake","text":"INCLUDEPATH += C:\\Qwt-6.1.4\\include LIBS += -LC:\\Qwt-6.1.4\\lib -lqwt Im Debug-Modus kann auch -lqwtd verwendet werden.","title":"Beispielkonfiguration - Windows - Qmake"},{"location":"building/#beispielkonfiguration-linuxmac-qmake-bei-installation-aus-quelltextarchiv","text":"INCLUDEPATH += /usr/local/qwt-6.1.4/include LIBS += -L/usr/local/qwt-6.1.4/lib -lqwt","title":"Beispielkonfiguration - Linux/Mac - Qmake - bei Installation aus Quelltextarchiv"},{"location":"building/#beispielkonfiguration-linuxmac-qmake-bei-installation-aus-paketquelle","text":"INCLUDEPATH += /usr/include/qwt LIBS += -L/usr/lib -lqwt-qt5 Der tats\u00e4chliche Bibliotheksname h\u00e4ngt von dem jeweiligen Paket der Linux-Distribution ab. Notfalls mal im Verzeichnis /usr/lib nachschauen, was da an libqwt.... -Dateien existiert.","title":"Beispielkonfiguration - Linux/Mac - Qmake - bei Installation aus Paketquelle"},{"location":"building/#suchpfade-fur-laufzeitbibliotheken","text":"Unter Windows muss man entweder den Pfad zur Qwt-DLL in die PATH-Variable eintragen, oder man kopiert einfach die DLL in das Verzeichnis der eigenen exe-Datei (das ist zumeist der einfachste Weg - hierbei je nach Debug/Release-Modus die passende qwtd.dll und qwt.dll linken und kopieren). Unter Linux kann man den LD_LIBRARY_PATH anpassen oder mittels RPATH den Laufzeitpfad in die Anwendung hineinkompilieren. Mehr dazu in der Qwt-Dokumentation unter doc/html/qwtinstall.html . Auch praktikabel ist unter beiden Plattformen die Erstellung und Verwendung von Qwt als statischer Bibliothek. Dies kann in der qwtconfig.pri eingestellt werden (Zeile QWT_CONFIG += QwtDll auskommentieren!).","title":"Suchpfade f\u00fcr Laufzeitbibliotheken"},{"location":"building/#erstellen-mit-visual-studio","text":"... TODO","title":"Erstellen mit Visual Studio"},{"location":"customization/","text":"Anpassung des QwtPlots durch \u00dcberladung Grundkonzepte: \u00dcberladung, Funktionalit\u00e4t anpassen durch Polymorphismus \u00dcberblick \u00fcber die API Wo finde ich was; welche Klasse ist wof\u00fcr zust\u00e4ndig (Liste) Das Layout-System Wie wird die konkrete Geometrie berechnet (Achsenlabels, Randabst\u00e4nde, Ticks, ...) Anpassung der Bildaufteilung QwtPlotLayout Zeichenfl\u00e4che hat Abst\u00e4nde zum Rand: wenn setAlignCanvasToScale() false ist Abstand entspricht: maximum aus canvasMargins (siehe setCanvasMargin) und borderDistHint des SkaleWidgets - damit Label noch hinpasst setAlignCanvasToScale() Achsen eigene ScaleDivs und ScaleDraws Balkendiagramme mit Kategoriebeschriftungen ... Proportionalit\u00e4t Proportionalit\u00e4t zweier Achsen einfordern Legenden -- Aktualisierung der Legende nach \u00c4nderungen: QwtPlotCurve::itemChanged() \u00c4u\u00dfere Legenden Platzierung, Spalteanzahl, Abst\u00e4nde, ... Kontrolle \u00fcber Sortierung der Eintr\u00e4ge Innere Legenden Formatierung Reagieren auf Klicks Verschieben der Legende implementieren Eigene Legendeneintr\u00e4ge zeichnen Linendiagramme (QwtPlotCurve) Wenn die eingebauten Legendenicon-Typen (Linie oder gef\u00fclltes Rechteck) nicht ausreichend sind, dann kann man einfach die Funktion QwtPlotCurve::legendItem() re-implementieren. Beispiel: Die Legende soll Linien mittels gef\u00fcllter Rechtecke zeigen, aber umrandet mit einem schwarzen Rahmen (links original, rechts mit angepasster Zeichenroutine) Quelltext: // Ableiten der QwtPlotCurve Klasse (z.B. direkt in der cpp-Datei, // wo die Instanzen der QwtPlotCurve erstellt werden) class PlotCurveWithBlackFrameInLegend : public QwtPlotCurve { public: PlotCurveWithBlackFrameInLegend(const QString desc) : QwtPlotCurve(desc) {} // Re-implementierung der legendIcon()-Funktion QwtGraphic legendIcon( int index, const QSizeF size) const { Q_UNUSED( index ); if ( size.isEmpty() ) return QwtGraphic(); QwtGraphic graphic; graphic.setDefaultSize( size ); graphic.setRenderHint( QwtGraphic::RenderPensUnscaled, true ); QPainter painter( graphic ); painter.setRenderHint( QPainter::Antialiasing, testRenderHint( QwtPlotItem::RenderAntialiased ) ); QRectF r( 0, 0, size.width(), size.height() ); // zeichne gef\u00fclltes Rechteck painter.setPen(Qt::black); painter.setBrush(pen().color()); painter.drawRect( r); return graphic; } }; Statt QwtPlotCurve Objekten kann man nun einfach Instanzen von PlotCurveWithBlackFrameInLegend erstellen und dem QwtPlot \u00fcbergeben. Picker/zoomer Pickertext anpassen Zoomrect anders zeichnen (Beispiel: \"marching ants\") Balkendiagramme anpassen Balken mit schwarzen Trennlinien zeichnen Erster Versuch: QwtColumnSymbol* symbol = new QwtColumnSymbol(QwtColumnSymbol::Box); symbol- setFrameStyle(QwtColumnSymbol::Plain); symbol- setLineWidth(1); QPalette palette; palette.setColor(QPalette::Window, barColor); // barColor ist die F\u00fcllfarbe palette.setBrush(QPalette::Dark, Qt::black); symbol- setPalette(palette); Aber: doppelte schwarze Linien sehen unelegant aus. Neue Variante: QwtPlotMultiBarChart::specialSymbol() F\u00fcr stacked bars - links und rechts eine Linie und nur oben eine Linie. In der Legende was anderes? Plot Darstellung Gradient als Plot-Hintergrund Beispiel: SinusPlot","title":"Anpassungen"},{"location":"customization/#anpassung-des-qwtplots-durch-uberladung","text":"Grundkonzepte: \u00dcberladung, Funktionalit\u00e4t anpassen durch Polymorphismus","title":"Anpassung des QwtPlots durch \u00dcberladung"},{"location":"customization/#uberblick-uber-die-api","text":"Wo finde ich was; welche Klasse ist wof\u00fcr zust\u00e4ndig (Liste)","title":"\u00dcberblick \u00fcber die API"},{"location":"customization/#das-layout-system","text":"Wie wird die konkrete Geometrie berechnet (Achsenlabels, Randabst\u00e4nde, Ticks, ...)","title":"Das Layout-System"},{"location":"customization/#anpassung-der-bildaufteilung","text":"QwtPlotLayout Zeichenfl\u00e4che hat Abst\u00e4nde zum Rand: wenn setAlignCanvasToScale() false ist Abstand entspricht: maximum aus canvasMargins (siehe setCanvasMargin) und borderDistHint des SkaleWidgets - damit Label noch hinpasst setAlignCanvasToScale()","title":"Anpassung der Bildaufteilung"},{"location":"customization/#achsen","text":"eigene ScaleDivs und ScaleDraws","title":"Achsen"},{"location":"customization/#balkendiagramme-mit-kategoriebeschriftungen","text":"...","title":"Balkendiagramme mit Kategoriebeschriftungen"},{"location":"customization/#proportionalitat","text":"Proportionalit\u00e4t zweier Achsen einfordern","title":"Proportionalit\u00e4t"},{"location":"customization/#legenden","text":"-- Aktualisierung der Legende nach \u00c4nderungen: QwtPlotCurve::itemChanged()","title":"Legenden"},{"location":"customization/#auere-legenden","text":"Platzierung, Spalteanzahl, Abst\u00e4nde, ... Kontrolle \u00fcber Sortierung der Eintr\u00e4ge","title":"\u00c4u\u00dfere Legenden"},{"location":"customization/#innere-legenden","text":"Formatierung Reagieren auf Klicks Verschieben der Legende implementieren","title":"Innere Legenden"},{"location":"customization/#eigene-legendeneintrage-zeichnen","text":"","title":"Eigene Legendeneintr\u00e4ge zeichnen"},{"location":"customization/#linendiagramme-qwtplotcurve","text":"Wenn die eingebauten Legendenicon-Typen (Linie oder gef\u00fclltes Rechteck) nicht ausreichend sind, dann kann man einfach die Funktion QwtPlotCurve::legendItem() re-implementieren. Beispiel: Die Legende soll Linien mittels gef\u00fcllter Rechtecke zeigen, aber umrandet mit einem schwarzen Rahmen (links original, rechts mit angepasster Zeichenroutine) Quelltext: // Ableiten der QwtPlotCurve Klasse (z.B. direkt in der cpp-Datei, // wo die Instanzen der QwtPlotCurve erstellt werden) class PlotCurveWithBlackFrameInLegend : public QwtPlotCurve { public: PlotCurveWithBlackFrameInLegend(const QString desc) : QwtPlotCurve(desc) {} // Re-implementierung der legendIcon()-Funktion QwtGraphic legendIcon( int index, const QSizeF size) const { Q_UNUSED( index ); if ( size.isEmpty() ) return QwtGraphic(); QwtGraphic graphic; graphic.setDefaultSize( size ); graphic.setRenderHint( QwtGraphic::RenderPensUnscaled, true ); QPainter painter( graphic ); painter.setRenderHint( QPainter::Antialiasing, testRenderHint( QwtPlotItem::RenderAntialiased ) ); QRectF r( 0, 0, size.width(), size.height() ); // zeichne gef\u00fclltes Rechteck painter.setPen(Qt::black); painter.setBrush(pen().color()); painter.drawRect( r); return graphic; } }; Statt QwtPlotCurve Objekten kann man nun einfach Instanzen von PlotCurveWithBlackFrameInLegend erstellen und dem QwtPlot \u00fcbergeben.","title":"Linendiagramme (QwtPlotCurve)"},{"location":"customization/#pickerzoomer","text":"Pickertext anpassen Zoomrect anders zeichnen (Beispiel: \"marching ants\")","title":"Picker/zoomer"},{"location":"customization/#balkendiagramme-anpassen","text":"","title":"Balkendiagramme anpassen"},{"location":"customization/#balken-mit-schwarzen-trennlinien-zeichnen","text":"Erster Versuch: QwtColumnSymbol* symbol = new QwtColumnSymbol(QwtColumnSymbol::Box); symbol- setFrameStyle(QwtColumnSymbol::Plain); symbol- setLineWidth(1); QPalette palette; palette.setColor(QPalette::Window, barColor); // barColor ist die F\u00fcllfarbe palette.setBrush(QPalette::Dark, Qt::black); symbol- setPalette(palette); Aber: doppelte schwarze Linien sehen unelegant aus. Neue Variante: QwtPlotMultiBarChart::specialSymbol() F\u00fcr stacked bars - links und rechts eine Linie und nur oben eine Linie. In der Legende was anderes?","title":"Balken mit schwarzen Trennlinien zeichnen"},{"location":"customization/#plot-darstellung","text":"","title":"Plot Darstellung"},{"location":"customization/#gradient-als-plot-hintergrund","text":"Beispiel: SinusPlot","title":"Gradient als Plot-Hintergrund"},{"location":"export/","text":"QwtPlot exportieren und drucken This section discusses various aspects related to exporting a QwtPlot to images (or image files) and printing charts with good quality to different sources. The basics The process of drawing the actual QwtPlot is called rendering the plot. There are several different functions available for that, which we discuss later. When a QwtPlot is rendered on a raster-based paint device (see QPaintDevice), the result will be a pixel buffer (e.g. image/pixmap), which can be stored, for example, in PNG files. When the plot is rendered on a vector paint device (PDF, SVG, ...) the result will be a vector graphic and it depends on the viewer (or printer) to show/print it. As a vector graphic, all items are drawn within some coordinate system which can represent either real distances (mm or inch) or pixels or anything. Conversion between these coordinate systems is typically done by some factor. Resolution A typical way to relate between real distances to pixels/points is the resolution, expressed as DotsPerInch (DPI). Printers have typically a resolution of 600 DPI or 1200 DPI. The resolution of a monitor depends on the screen resolution (e.g. FullHD 1920x1080) and the monitor size, with typical values between 72 and 120 DPI. Above that (for 4K laptop screens) such displays are sometimes termed HighDPI displays. It is important to keep this resolution in mind, because viewers of the plot have different expectations when whatching a plot on the monitor or on paper or in a PDF. Here, you can zoom in to see details (same as using magnifying glass for the printed plot). The equation for converting from distance in mm to pixel is: resolution / 25.4 mm/inch = pixel / mm sizePixel = sizeMM * resolution / 25.4 For example, on a monitor with resolution of 85 DPI a single pixel has a width of: 1 pixel * 25.4 / 85 = 0.3 mm Line widths and the 'cosmetic' property For example, if you have a 15'' screen with full HD resolution, you may want to use exactly 1 pixel-wide lines for the plot grid or the curves. Such a single pixel line then has about 0.2...0.3 mm width (see above) - good to see without too much effort. Using the same screen size but with 4k display, a single-pixel line may be already too thin to see. Still, 1 pixel wide lines are typically good for drawing on computer screens. Since drawing single-pixel lines is very common, Qt such lines can be drawn using a QPen with pen width of 0 (Note: in previous Qt versions this was the default, since Qt 5 the default is 1 pixel wide). A pen with 0 width is also termed a cosmetic pen, meaning that regardless on the resolution of the paint device, always only 1 pixel is used for drawing. However, the cosmetic property can be also set for pens with other widths: QPen::setCosmetic(bool) Generally, all lines with cosmetic pens shall be drawn with exactly the specified number of pixels, regardless of target paint device resolution and possible transformations . Transformations and their impact on plot items When rendering the plot to a painting device, the plot items are drawn with coordinates which are transformed to the target coordinate system. Part of this transformation is also the scaling of plot item properties, such as font sizes and line widths. Normally, all plot items are drawn scaled to the coordinate system (and resolution) of the target paint device. The scale factor is determined by various factors, as we will see below. Only cosmetic pens are exempt from the scaling. This may lead to surprising results, when a cosmetic pen with width of 1 is rendered onto a 1200 DPI printer page. Indeed, the printer will only print a single dot as line width, leading to a tiny and hard to see line. Apparently, the cosmetic pen size should somehow be aligned with the target resolution to get an expected physical width. Different options on how to do this are shown below. Exporting bitmaps Rendering a QwtPlot onto a bitmap is fairly easy. However, there are three different options to consider: hardcopy of the plot as shown on the screen rendering on different pixel size yet same scaling rendering on different pixel size yet keep appearance and simply scale chart Bitmap hardcopy Basically, the same as a screenshot, good for copying the QwtPlot to the clipboard, simply use: pixmap = plot- grab(); // Qt 5 or newer pixmap = QPixmap::grabWidget(plot); // Qt 4 Bitmap with different size yet same scaling This is basically the same as resizing a QwtPlot widget - there will be more space for the coordinate axes, there will be more canvas area for the plot items and more space for labels and text. Use: QwtPlotRenderer renderer; // the renderer QRect imageRect( 0.0, 0.0, imageWidth, imageHeight ); // target size in pixels QImage image( imageRect.size(), QImage::Format_ARGB32 ); image.fill( Qt::white ); // fill with uniform background color, usually white QPainter painter( image ); renderer.render( plot, painter, imageRect ); painter.end(); For this variant, all pens and fonts will remain exactly the same as in the QwtPlot widget. Export bitmap with proportional scaling This type of export can be thought of as method to shrink/expand the current plot to a new size. Major difference to the method above is that the proportions within the chart stay the same. For example, the ratio of grid lines distance to label text lengths and curve distances stays (approximately) the same. Use: QwtPlotRenderer renderer; // the renderer QRect imageRect( 0.0, 0.0, imageWidth, imageHeight ); // target size in pixels QImage image( imageRect.size(), QImage::Format_ARGB32 ); int resolution = 96; // in DPI, 24'' Monitor with 1920x1080 screen resolution const double mmToInch = 1.0 / 25.4; const int dotsPerMeter = qRound( resolution * mmToInch * 1000.0 ); image.setDotsPerMeterX( dotsPerMeter ); image.setDotsPerMeterY( dotsPerMeter ); image.fill( Qt::white ); // fill with uniform background color, usually white QPainter painter( image ); renderer.render( plot, painter, imageRect ); painter.end(); It is now possible to generate a bitmap with the same dimensions, yet different level of detail, by adjusting the resolution. Higher resolution means effectively more pixels per item , e.g larger fonts, larger line width etc. Note: The scaling properties (cosmetic!) have already an impact. When curve pens and grid pens have a cosmetic pen assigned (e.g. 1 or 2 pixels), they will be drawn with exactly this amount of pixels onto the bitmap. To summarize: when exporting bitmaps, use cosmetic pens Bitmap export for screen presentation When exporting bitmaps for use in a presentation and the resolution is known (e.g. 1024x786 on old projectors), typically the task is to generate a plot with a given maximum resolution (to fit on screen), without any scaling in the presentation software (pixel = pixel) when the presentation is shown on screen, and yet enough detail of the plot. Suppose your plot is configured to look nicely in the QwtPlot widget with a resolution of 1980x1080 pixels (full HD). In your presentation you have only about 600x450 pixels. When exporting, select the target size as image size and adjust the DPI value until you have a good compromise between level of detail and size of fonts in the diagram. Thanks to the cosmetic pens (if used), the lines and grid will always be drawn nicely with good contrast and without blurring. Exporting vector images/printing Exporting a vector image or printing a plot works essentially the same. The plot is simply rendered on a vector-based paint device. Such a paint device has properties such as size and resolution, something that is, for example, provided by a QPrinter. Expectations on plot results/differences to screen view When exporting a plot to a vector graphic, some expectations can be formulated: when looking at the vector graphic in a viewer (e.g. in a PDF viewer) it should look similar to the plot in the QwtPlot widget when zooming in, there should be more details visible; for example, when the original 100% view shows high frequency oscillations in the diagram such that many lines are drawn next to/over each other, zooming in into the vector graphic should reveal more details when looking at a PDF/Vector graphic in a viewer, some lines (grid, coordinates and label ticks) should be drawn with 1-pixel-wide lines, yet when printing the plot, the same lines should be drawn with a meaningful thickness (e.g. 0.2 mm thick lines), so that they appear nicely on the page exporting a plot with 40x30 mm size or 80x60 mm size should result in the same line ticknesses to be used (e.g. curve line thickness should be 0.6 mm as selected) Apparently, there is no single correct solution and different options have to be used depending on the desired scenario. Note: A general misconception may be, that a vector graphic output format can be used to emulate the zooming features of QwtPlot. Instead, the general purpose of a vector plot is to maintain the general appearance (incl. line thicknesses) regardless of target resolution. For example, when exploiting a PDF viewer to zoom into a chart, one may not expect the same functionality as zooming into a QwtPlot, i.e. more samples being drawn with line widths kept the same regardless of zoom level (see discussion of cosmetic property treatment below). Export formats PDF specifics A common understanding of the PDF requirement is, that zooming into the PDF scales all elements in correct proportions. Hence, if a plot shown at 100% zoom hides some details (because curve line thickness is too large), zooming in will not help at all, since curve line thicknesses scale just the same. For cosmetic pens the property has only an impact on the initial composition of the vector graphic. A viewer will nonetheless scale line width during zoom. Tricky is the situation for PDFs with cosmetic, 1-pixel wide lines (pen-width = 0). For viewing PDFs in a pdf viewer this may be quite neat, yet when printing such a PDF with 600 DPI or higher, the extremely thin lines will almost vanish. So when exporting, one should distinguish between \"screen viewing\" and \"printing\", which may be quite confusing to the user of the PDF. Therefore, for generally usable PDFs, it is recommended to avoid cosmetic 1-pixel lines (i.e. pen-width = 0) in PDFs , altogether. Note: for Qt 5.10 and probably other versions as well there appears to be a bug that prevents the pdf paint engine of Qt to consider the cosmetic property when a solid line with full opaque color is plotted with pen width != 0. Workaround is to set the alpha value of the curve pen to 254. However, there is generally a better way to handle line widths, see below. Do not use cosmetic pens for PDF export. SVG features SVG files (at least with SVG version 1.2 or newer) have a property for path elements vector-effect=\"non-scaling-stroke\" In a viewer that supports this feature (and with certain additional requirements: viewport attribute must exist, width and height attribute must not exist), the cosmetic lines will be shown indeed with constant width regardless of the zoom level. However, this feature is far from being universally supported. At the current state, using cosmetic pens will not even work for SVG export. Do not rely on the cosmetic property to work when exporting SVG images. PS/EPS export Postscript/Encapsulated Postscript export has been removed from Qt with version 5, so there is no paint device available anylonger that generates this. However, using a postscript printer driver and storing the result to file will generally work (see printing section below). EMF export EMF export is important for Windows users, but relies on translating Qt paint engine drawing commands into Windows drawing API commands. To export the plot to emf format (either cliboard or *.emf file), a third-party library (e.g. EmfLibary) is needed that generates EMF commands from paint device commands. Note: It is important that the EMF library implements a paint device, that is recognized by its type as a vector-based paint device (greater or equal to User-type). QwtPlot distinguishes between raster and vector based paint devices, so if characteristic steps appear in lines within the EMF output, it is likely that the paint device type is reported/recognized wrong. Target paint device resolution The target paint device resolution is usually given. A printer will report the resolution selected by the printer driver. For PDF or SVG export, the resolution can be arbitrarily selected. However, it should be selected such, that enough points remain to render a plot without data loss. For example, if 10000 samples/data points are equally spaced over the canvas area, the resulting width of generated plot (=total number of points) should be well above 10000, if chart should be plotted without data loss. If the line thickness is selected fine enough, zooming into the vector graphic will eventually yield Adjusting line width When configuring a QwtPlot for viewing a diagram in the widget, the curve pen widths are typically selected based on pixels on the screen. For FullHD displays, pen widths of 1-3 pixels are common, for 3K and 4K displays (HighDPI displays), pen widths up to 6 pixels are used. However, when printing charts, typical pen widths should in the magnitude of 0.2 ... 1 mm (where 1 mm is already a fairly thick line). Marker symbols are often drawn with less than 0.3 mm thick lines. There are generally two approaches on how to achieve this: select export DPI such, that the desired mm widths are achieved based on the current pen widths already used for the widget (requires non-cosmetic pens to be used) modify pen widths of all plot items prior to printing to get the desired width (this works with cosmetic and non-cosmetic pens, though the calculation of the actual pen width to use will be different) Adjusting DPI It is important to note that a change of the DPI settings will affect not only line width but also font heights. The required DPI can be calculated based on the equation shown above in section Print Resolution . \\subsubsection exportingVectorLineWidthPenAdjustment Adjusting pen width The advantage of this approach is, that the overall appearance of the vector image looks very close to that rendered on the QwtPlot widget. Suppose the resolution (in DPI) of the target device is known and a given, i.e. the plot should be rendered with exactly this resolution. This avoids print-time scaling and may give best quality (though I wonder if someone can really see the difference between a 300 DPI plot upscaled to 1200 DPI or a natively rendered 1200 DPI plot. The effect on antialiasing will be minor, but maybe worth a try). Again, we rearrage the equation from section \\ref printingResolution. Additional topics renderer.setLayoutFlag(QwtPlotRenderer::FrameWithScales, true); Sample reduction ... */","title":"Drucken/Exportieren"},{"location":"export/#qwtplot-exportieren-und-drucken","text":"This section discusses various aspects related to exporting a QwtPlot to images (or image files) and printing charts with good quality to different sources.","title":"QwtPlot exportieren und drucken"},{"location":"export/#the-basics","text":"The process of drawing the actual QwtPlot is called rendering the plot. There are several different functions available for that, which we discuss later. When a QwtPlot is rendered on a raster-based paint device (see QPaintDevice), the result will be a pixel buffer (e.g. image/pixmap), which can be stored, for example, in PNG files. When the plot is rendered on a vector paint device (PDF, SVG, ...) the result will be a vector graphic and it depends on the viewer (or printer) to show/print it. As a vector graphic, all items are drawn within some coordinate system which can represent either real distances (mm or inch) or pixels or anything. Conversion between these coordinate systems is typically done by some factor.","title":"The basics"},{"location":"export/#resolution","text":"A typical way to relate between real distances to pixels/points is the resolution, expressed as DotsPerInch (DPI). Printers have typically a resolution of 600 DPI or 1200 DPI. The resolution of a monitor depends on the screen resolution (e.g. FullHD 1920x1080) and the monitor size, with typical values between 72 and 120 DPI. Above that (for 4K laptop screens) such displays are sometimes termed HighDPI displays. It is important to keep this resolution in mind, because viewers of the plot have different expectations when whatching a plot on the monitor or on paper or in a PDF. Here, you can zoom in to see details (same as using magnifying glass for the printed plot). The equation for converting from distance in mm to pixel is: resolution / 25.4 mm/inch = pixel / mm sizePixel = sizeMM * resolution / 25.4 For example, on a monitor with resolution of 85 DPI a single pixel has a width of: 1 pixel * 25.4 / 85 = 0.3 mm","title":"Resolution"},{"location":"export/#line-widths-and-the-cosmetic-property","text":"For example, if you have a 15'' screen with full HD resolution, you may want to use exactly 1 pixel-wide lines for the plot grid or the curves. Such a single pixel line then has about 0.2...0.3 mm width (see above) - good to see without too much effort. Using the same screen size but with 4k display, a single-pixel line may be already too thin to see. Still, 1 pixel wide lines are typically good for drawing on computer screens. Since drawing single-pixel lines is very common, Qt such lines can be drawn using a QPen with pen width of 0 (Note: in previous Qt versions this was the default, since Qt 5 the default is 1 pixel wide). A pen with 0 width is also termed a cosmetic pen, meaning that regardless on the resolution of the paint device, always only 1 pixel is used for drawing. However, the cosmetic property can be also set for pens with other widths: QPen::setCosmetic(bool) Generally, all lines with cosmetic pens shall be drawn with exactly the specified number of pixels, regardless of target paint device resolution and possible transformations .","title":"Line widths and the 'cosmetic' property"},{"location":"export/#transformations-and-their-impact-on-plot-items","text":"When rendering the plot to a painting device, the plot items are drawn with coordinates which are transformed to the target coordinate system. Part of this transformation is also the scaling of plot item properties, such as font sizes and line widths. Normally, all plot items are drawn scaled to the coordinate system (and resolution) of the target paint device. The scale factor is determined by various factors, as we will see below. Only cosmetic pens are exempt from the scaling. This may lead to surprising results, when a cosmetic pen with width of 1 is rendered onto a 1200 DPI printer page. Indeed, the printer will only print a single dot as line width, leading to a tiny and hard to see line. Apparently, the cosmetic pen size should somehow be aligned with the target resolution to get an expected physical width. Different options on how to do this are shown below.","title":"Transformations and their impact on plot items"},{"location":"export/#exporting-bitmaps","text":"Rendering a QwtPlot onto a bitmap is fairly easy. However, there are three different options to consider: hardcopy of the plot as shown on the screen rendering on different pixel size yet same scaling rendering on different pixel size yet keep appearance and simply scale chart","title":"Exporting bitmaps"},{"location":"export/#bitmap-hardcopy","text":"Basically, the same as a screenshot, good for copying the QwtPlot to the clipboard, simply use: pixmap = plot- grab(); // Qt 5 or newer pixmap = QPixmap::grabWidget(plot); // Qt 4","title":"Bitmap hardcopy"},{"location":"export/#bitmap-with-different-size-yet-same-scaling","text":"This is basically the same as resizing a QwtPlot widget - there will be more space for the coordinate axes, there will be more canvas area for the plot items and more space for labels and text. Use: QwtPlotRenderer renderer; // the renderer QRect imageRect( 0.0, 0.0, imageWidth, imageHeight ); // target size in pixels QImage image( imageRect.size(), QImage::Format_ARGB32 ); image.fill( Qt::white ); // fill with uniform background color, usually white QPainter painter( image ); renderer.render( plot, painter, imageRect ); painter.end(); For this variant, all pens and fonts will remain exactly the same as in the QwtPlot widget.","title":"Bitmap with different size yet same scaling"},{"location":"export/#export-bitmap-with-proportional-scaling","text":"This type of export can be thought of as method to shrink/expand the current plot to a new size. Major difference to the method above is that the proportions within the chart stay the same. For example, the ratio of grid lines distance to label text lengths and curve distances stays (approximately) the same. Use: QwtPlotRenderer renderer; // the renderer QRect imageRect( 0.0, 0.0, imageWidth, imageHeight ); // target size in pixels QImage image( imageRect.size(), QImage::Format_ARGB32 ); int resolution = 96; // in DPI, 24'' Monitor with 1920x1080 screen resolution const double mmToInch = 1.0 / 25.4; const int dotsPerMeter = qRound( resolution * mmToInch * 1000.0 ); image.setDotsPerMeterX( dotsPerMeter ); image.setDotsPerMeterY( dotsPerMeter ); image.fill( Qt::white ); // fill with uniform background color, usually white QPainter painter( image ); renderer.render( plot, painter, imageRect ); painter.end(); It is now possible to generate a bitmap with the same dimensions, yet different level of detail, by adjusting the resolution. Higher resolution means effectively more pixels per item , e.g larger fonts, larger line width etc. Note: The scaling properties (cosmetic!) have already an impact. When curve pens and grid pens have a cosmetic pen assigned (e.g. 1 or 2 pixels), they will be drawn with exactly this amount of pixels onto the bitmap. To summarize: when exporting bitmaps, use cosmetic pens","title":"Export bitmap with proportional scaling"},{"location":"export/#bitmap-export-for-screen-presentation","text":"When exporting bitmaps for use in a presentation and the resolution is known (e.g. 1024x786 on old projectors), typically the task is to generate a plot with a given maximum resolution (to fit on screen), without any scaling in the presentation software (pixel = pixel) when the presentation is shown on screen, and yet enough detail of the plot. Suppose your plot is configured to look nicely in the QwtPlot widget with a resolution of 1980x1080 pixels (full HD). In your presentation you have only about 600x450 pixels. When exporting, select the target size as image size and adjust the DPI value until you have a good compromise between level of detail and size of fonts in the diagram. Thanks to the cosmetic pens (if used), the lines and grid will always be drawn nicely with good contrast and without blurring.","title":"Bitmap export for screen presentation"},{"location":"export/#exporting-vector-imagesprinting","text":"Exporting a vector image or printing a plot works essentially the same. The plot is simply rendered on a vector-based paint device. Such a paint device has properties such as size and resolution, something that is, for example, provided by a QPrinter.","title":"Exporting vector images/printing"},{"location":"export/#expectations-on-plot-resultsdifferences-to-screen-view","text":"When exporting a plot to a vector graphic, some expectations can be formulated: when looking at the vector graphic in a viewer (e.g. in a PDF viewer) it should look similar to the plot in the QwtPlot widget when zooming in, there should be more details visible; for example, when the original 100% view shows high frequency oscillations in the diagram such that many lines are drawn next to/over each other, zooming in into the vector graphic should reveal more details when looking at a PDF/Vector graphic in a viewer, some lines (grid, coordinates and label ticks) should be drawn with 1-pixel-wide lines, yet when printing the plot, the same lines should be drawn with a meaningful thickness (e.g. 0.2 mm thick lines), so that they appear nicely on the page exporting a plot with 40x30 mm size or 80x60 mm size should result in the same line ticknesses to be used (e.g. curve line thickness should be 0.6 mm as selected) Apparently, there is no single correct solution and different options have to be used depending on the desired scenario. Note: A general misconception may be, that a vector graphic output format can be used to emulate the zooming features of QwtPlot. Instead, the general purpose of a vector plot is to maintain the general appearance (incl. line thicknesses) regardless of target resolution. For example, when exploiting a PDF viewer to zoom into a chart, one may not expect the same functionality as zooming into a QwtPlot, i.e. more samples being drawn with line widths kept the same regardless of zoom level (see discussion of cosmetic property treatment below).","title":"Expectations on plot results/differences to screen view"},{"location":"export/#export-formats","text":"","title":"Export formats"},{"location":"export/#pdf-specifics","text":"A common understanding of the PDF requirement is, that zooming into the PDF scales all elements in correct proportions. Hence, if a plot shown at 100% zoom hides some details (because curve line thickness is too large), zooming in will not help at all, since curve line thicknesses scale just the same. For cosmetic pens the property has only an impact on the initial composition of the vector graphic. A viewer will nonetheless scale line width during zoom. Tricky is the situation for PDFs with cosmetic, 1-pixel wide lines (pen-width = 0). For viewing PDFs in a pdf viewer this may be quite neat, yet when printing such a PDF with 600 DPI or higher, the extremely thin lines will almost vanish. So when exporting, one should distinguish between \"screen viewing\" and \"printing\", which may be quite confusing to the user of the PDF. Therefore, for generally usable PDFs, it is recommended to avoid cosmetic 1-pixel lines (i.e. pen-width = 0) in PDFs , altogether. Note: for Qt 5.10 and probably other versions as well there appears to be a bug that prevents the pdf paint engine of Qt to consider the cosmetic property when a solid line with full opaque color is plotted with pen width != 0. Workaround is to set the alpha value of the curve pen to 254. However, there is generally a better way to handle line widths, see below. Do not use cosmetic pens for PDF export.","title":"PDF specifics"},{"location":"export/#svg-features","text":"SVG files (at least with SVG version 1.2 or newer) have a property for path elements vector-effect=\"non-scaling-stroke\" In a viewer that supports this feature (and with certain additional requirements: viewport attribute must exist, width and height attribute must not exist), the cosmetic lines will be shown indeed with constant width regardless of the zoom level. However, this feature is far from being universally supported. At the current state, using cosmetic pens will not even work for SVG export. Do not rely on the cosmetic property to work when exporting SVG images.","title":"SVG features"},{"location":"export/#pseps-export","text":"Postscript/Encapsulated Postscript export has been removed from Qt with version 5, so there is no paint device available anylonger that generates this. However, using a postscript printer driver and storing the result to file will generally work (see printing section below).","title":"PS/EPS export"},{"location":"export/#emf-export","text":"EMF export is important for Windows users, but relies on translating Qt paint engine drawing commands into Windows drawing API commands. To export the plot to emf format (either cliboard or *.emf file), a third-party library (e.g. EmfLibary) is needed that generates EMF commands from paint device commands. Note: It is important that the EMF library implements a paint device, that is recognized by its type as a vector-based paint device (greater or equal to User-type). QwtPlot distinguishes between raster and vector based paint devices, so if characteristic steps appear in lines within the EMF output, it is likely that the paint device type is reported/recognized wrong.","title":"EMF export"},{"location":"export/#target-paint-device-resolution","text":"The target paint device resolution is usually given. A printer will report the resolution selected by the printer driver. For PDF or SVG export, the resolution can be arbitrarily selected. However, it should be selected such, that enough points remain to render a plot without data loss. For example, if 10000 samples/data points are equally spaced over the canvas area, the resulting width of generated plot (=total number of points) should be well above 10000, if chart should be plotted without data loss. If the line thickness is selected fine enough, zooming into the vector graphic will eventually yield","title":"Target paint device resolution"},{"location":"export/#adjusting-line-width","text":"When configuring a QwtPlot for viewing a diagram in the widget, the curve pen widths are typically selected based on pixels on the screen. For FullHD displays, pen widths of 1-3 pixels are common, for 3K and 4K displays (HighDPI displays), pen widths up to 6 pixels are used. However, when printing charts, typical pen widths should in the magnitude of 0.2 ... 1 mm (where 1 mm is already a fairly thick line). Marker symbols are often drawn with less than 0.3 mm thick lines. There are generally two approaches on how to achieve this: select export DPI such, that the desired mm widths are achieved based on the current pen widths already used for the widget (requires non-cosmetic pens to be used) modify pen widths of all plot items prior to printing to get the desired width (this works with cosmetic and non-cosmetic pens, though the calculation of the actual pen width to use will be different)","title":"Adjusting line width"},{"location":"export/#adjusting-dpi","text":"It is important to note that a change of the DPI settings will affect not only line width but also font heights. The required DPI can be calculated based on the equation shown above in section Print Resolution . \\subsubsection exportingVectorLineWidthPenAdjustment Adjusting pen width The advantage of this approach is, that the overall appearance of the vector image looks very close to that rendered on the QwtPlot widget. Suppose the resolution (in DPI) of the target device is known and a given, i.e. the plot should be rendered with exactly this resolution. This avoids print-time scaling and may give best quality (though I wonder if someone can really see the difference between a 300 DPI plot upscaled to 1200 DPI or a natively rendered 1200 DPI plot. The effect on antialiasing will be minor, but maybe worth a try). Again, we rearrage the equation from section \\ref printingResolution.","title":"Adjusting DPI"},{"location":"export/#additional-topics","text":"renderer.setLayoutFlag(QwtPlotRenderer::FrameWithScales, true);","title":"Additional topics"},{"location":"export/#sample-reduction","text":"... */","title":"Sample reduction"},{"location":"interaction/","text":"Benutzer-Interaktion mit dem Diagramm Wenn ein Diagramm erstellt wurde, gibt es verschiedene M\u00f6glichkeiten f\u00fcr den Nutzer, mit dem Diagramm zu interagieren: Werte unter dem Mauskursor anzeigen Werte der n\u00e4chstgelegenen Kurve anzeigen Zoomen und Verschieben der Plotansicht und weitere... Um das umzusetzen, k\u00f6nnte man das QwtPlot ableiten und die entsprechenden Maus- und Tastaturevents von Qt in den jeweiligen Event-Funktionen behandelt. Die Qwt-Bibliothek bringt aber ein paar vorbereitete Funktionen mit. Diese registrieren sich \u00fcber EventFilter beim Diagramm und fangen entsprechende Ereignisse (Mausklick, Mausbewegungen, Tastaturanschl\u00e4ge,... ) ab. Die Implementierung erfolgt in den Interaktionskomponenten stets \u00e4hnlich - das entsprechende Objekt wird erstellt und im Konstruktor \u00fcbergibt man die Zeichenfl\u00e4che (canvas) des gew\u00e4hlten QwtPlot . Damit kann die Interaktionskomponente den EventFilter installieren. Hinweis: F\u00fcr die meisten Komponenten ist die Reihenfolge, in der die Events abgearbeitet werden, unwichtig. In manchen F\u00e4llen m\u00f6chte man jedoch Seiteneffekte vermeiden, d.h. eine Interaktionskomponente akzeptiert und verarbeitet das Ereignis und die nachgeordneten EventFilter erhalten das Ereignis gar nicht mehr. In diesem Fall muss man die Reihenfolge der Erstellung der Interaktionskomponenten beachten. Datenanzeige (Tracker) Die Basisklasse f\u00fcr Interaktionskomponenten ist die Klasse QwtPicker . Diese implementiert die Behandlung von Enter, Leave, Mouse und Keyboard-Ereignissen und transformiert diese in ausgew\u00e4hlte Punkte. Dabei gibt es verschiedene Zustandsautomaten, welche man nachnutzen kann. F\u00fcr die Anzeige von QwtPicker *picker = new QwtPicker(widget); Die Klasse QwtTracker wie funktioniert der Tracker punkt, vertikal, horizontal Verschieben der Plotfl\u00e4che Das Verschieben der aktuellen Ansichtsfl\u00e4che des Diagramms erfolgt mit dem QwtPlotPanner . // Erstelle Objekt, welches sich gleich bei der Zeichenfl\u00e4che des // Plot registriert d_panner = new QwtPlotPanner(plot- canvas()); d_panner- setMouseButton(Qt::MidButton); Kurvenverlauf abfahren (CurveTracker) wie funktioniert der Tracker Zoomen/Plotausschnitt verschieben (Zooming/Panning): zoomer einstellungen zoom rect Basiszoomstufe einstellen zoom base einstellen (maximale rauszoomgr\u00f6\u00dfe) Mehrere Achsen zoomen R\u00fccktransformation zeigen Legendeneintr\u00e4ge ein/ausschalten Bei einer au\u00dfenliegenden Legende sind die standardm\u00e4\u00dfig erstellen Legendeneintr\u00e4ge einfache Label vom Typ QwtLegendLabel . Diesen k\u00f6nnen an- und ausgeschaltet werden (checked). Ein typischer Anwendungsfall ist das Sichtbar-/Versteckt-Schalten von Diagrammkurven/Balken, um einen Teil der Informationen zu verbergen. Zun\u00e4chst muss die entsprechende Legendeneigenschaft eingeschaltet werden: // Legendeneintr\u00e4ge checkbar machen d_legend- setDefaultItemMode(QwtLegendData::Checkable); Auf Checked/Unchecked-Ereignisse reagieren Damit man auf das Umschalten der Legendeintr\u00e4ge reagieren kann, muss man eine Signal-Slot-Verbindung zwischen Signal QwtLegendLabel::checked(bool) und einer eigenen Funktion herstellen. Das zu einer Kurve geh\u00f6rige LegendLabel findet man \u00fcber die Funktion QwtLegend::legendWidget() (wobei das eigentlich das Widget eines einzelnen Legendeneintrags ist). Das kann man dann in ein Label casten und via mit der entsprechenden Funktion verkn\u00fcpfen: // das zu einer Kurve geh\u00f6rige LegendLabel findet man \u00fcber die Funktion QwtLegend::legendWidget() // 'plotCurve1' ist ein Zeiger zu einer hinzugef\u00fcgten QwtPlotCurve QWidget* legendWidget = d_legend- legendWidget(itemToInfo(plotCurve1)); QwtLegendLabel* label = qobject_cast QwtLegendLabel* (legendWidget); // das Signal verkn\u00fcpfen connect(label, SIGNAL(checked(bool)), this, SLOT(onCurveVisibilityChanged(bool)) ); Hinweis: Statt qobject_cast QwtLegendLabel* k\u00f6nnte man auch `dynamic_cast verwenden, ersteres ist aber schneller und daher besser bei QObject-abgeleiteten Klassentypen. Sichtbar/Unsichtbar-Schalten von Linien/Kurven im Diagramm (QwtPlotCurve) Die Implementierung bei Liniendiagrammen sieht so aus: void MyPlot::onCurveVisibilityChanged (bool on) { QObject * origin = sender(); // cast pointer to QwtLegendItem QwtLegendLabel * item = qobject_cast QwtLegendLabel * (origin); // check that is was a valid sender if (item == NULL) return; // invalid origin // now find out which curve belongs to this legend item for (unsigned int i=0; i NumCurves; ++i) { if (m_curves[i] == NULL) continue; // skip empty curves QWidget* legendWidget = m_legend- legendWidget(itemToInfo(m_curves[i])); QwtLegendLabel* label = qobject_cast QwtLegendLabel* (legendWidget); if (label == item) { // set visibility of curve based on function argument m_curves[i]- setVisible(on); replot(); break; } } } Legendeneintr\u00e4ge alternativ schalten Implement show curve function such: void CpuPlot::showCurve(QwtPlotItem *item, bool on) { // wenn eine Curve angeschaltet werden soll, vorher alle anderen ausschalten if (on) { const QwtPlotItemList list = this- itemList(); for (QwtPlotItemIterator it = list.begin();it!=list.end();++it) { QwtPlotItem *item2 = *it; if (item2- rtti() == QwtPlotItem::Rtti_PlotCurve) item2- setVisible(false); } } item- setVisible(on); // Legendenwidget aktualisieren QWidget *w = legend()- find(item); if ( w w- inherits( QwtLegendItem ) ) ((QwtLegendItem *)w)- setChecked(on); replot(); }","title":"Diagramm-Interaktion"},{"location":"interaction/#benutzer-interaktion-mit-dem-diagramm","text":"Wenn ein Diagramm erstellt wurde, gibt es verschiedene M\u00f6glichkeiten f\u00fcr den Nutzer, mit dem Diagramm zu interagieren: Werte unter dem Mauskursor anzeigen Werte der n\u00e4chstgelegenen Kurve anzeigen Zoomen und Verschieben der Plotansicht und weitere... Um das umzusetzen, k\u00f6nnte man das QwtPlot ableiten und die entsprechenden Maus- und Tastaturevents von Qt in den jeweiligen Event-Funktionen behandelt. Die Qwt-Bibliothek bringt aber ein paar vorbereitete Funktionen mit. Diese registrieren sich \u00fcber EventFilter beim Diagramm und fangen entsprechende Ereignisse (Mausklick, Mausbewegungen, Tastaturanschl\u00e4ge,... ) ab. Die Implementierung erfolgt in den Interaktionskomponenten stets \u00e4hnlich - das entsprechende Objekt wird erstellt und im Konstruktor \u00fcbergibt man die Zeichenfl\u00e4che (canvas) des gew\u00e4hlten QwtPlot . Damit kann die Interaktionskomponente den EventFilter installieren. Hinweis: F\u00fcr die meisten Komponenten ist die Reihenfolge, in der die Events abgearbeitet werden, unwichtig. In manchen F\u00e4llen m\u00f6chte man jedoch Seiteneffekte vermeiden, d.h. eine Interaktionskomponente akzeptiert und verarbeitet das Ereignis und die nachgeordneten EventFilter erhalten das Ereignis gar nicht mehr. In diesem Fall muss man die Reihenfolge der Erstellung der Interaktionskomponenten beachten.","title":"Benutzer-Interaktion mit dem Diagramm"},{"location":"interaction/#datenanzeige-tracker","text":"Die Basisklasse f\u00fcr Interaktionskomponenten ist die Klasse QwtPicker . Diese implementiert die Behandlung von Enter, Leave, Mouse und Keyboard-Ereignissen und transformiert diese in ausgew\u00e4hlte Punkte. Dabei gibt es verschiedene Zustandsautomaten, welche man nachnutzen kann. F\u00fcr die Anzeige von QwtPicker *picker = new QwtPicker(widget); Die Klasse QwtTracker wie funktioniert der Tracker punkt, vertikal, horizontal","title":"Datenanzeige (Tracker)"},{"location":"interaction/#verschieben-der-plotflache","text":"Das Verschieben der aktuellen Ansichtsfl\u00e4che des Diagramms erfolgt mit dem QwtPlotPanner . // Erstelle Objekt, welches sich gleich bei der Zeichenfl\u00e4che des // Plot registriert d_panner = new QwtPlotPanner(plot- canvas()); d_panner- setMouseButton(Qt::MidButton);","title":"Verschieben der Plotfl\u00e4che"},{"location":"interaction/#kurvenverlauf-abfahren-curvetracker","text":"wie funktioniert der Tracker","title":"Kurvenverlauf abfahren (CurveTracker)"},{"location":"interaction/#zoomenplotausschnitt-verschieben-zoomingpanning","text":"zoomer einstellungen zoom rect","title":"Zoomen/Plotausschnitt verschieben (Zooming/Panning):"},{"location":"interaction/#basiszoomstufe-einstellen","text":"zoom base einstellen (maximale rauszoomgr\u00f6\u00dfe)","title":"Basiszoomstufe einstellen"},{"location":"interaction/#mehrere-achsen-zoomen","text":"R\u00fccktransformation zeigen","title":"Mehrere Achsen zoomen"},{"location":"interaction/#legendeneintrage-einausschalten","text":"Bei einer au\u00dfenliegenden Legende sind die standardm\u00e4\u00dfig erstellen Legendeneintr\u00e4ge einfache Label vom Typ QwtLegendLabel . Diesen k\u00f6nnen an- und ausgeschaltet werden (checked). Ein typischer Anwendungsfall ist das Sichtbar-/Versteckt-Schalten von Diagrammkurven/Balken, um einen Teil der Informationen zu verbergen. Zun\u00e4chst muss die entsprechende Legendeneigenschaft eingeschaltet werden: // Legendeneintr\u00e4ge checkbar machen d_legend- setDefaultItemMode(QwtLegendData::Checkable);","title":"Legendeneintr\u00e4ge ein/ausschalten"},{"location":"interaction/#auf-checkedunchecked-ereignisse-reagieren","text":"Damit man auf das Umschalten der Legendeintr\u00e4ge reagieren kann, muss man eine Signal-Slot-Verbindung zwischen Signal QwtLegendLabel::checked(bool) und einer eigenen Funktion herstellen. Das zu einer Kurve geh\u00f6rige LegendLabel findet man \u00fcber die Funktion QwtLegend::legendWidget() (wobei das eigentlich das Widget eines einzelnen Legendeneintrags ist). Das kann man dann in ein Label casten und via mit der entsprechenden Funktion verkn\u00fcpfen: // das zu einer Kurve geh\u00f6rige LegendLabel findet man \u00fcber die Funktion QwtLegend::legendWidget() // 'plotCurve1' ist ein Zeiger zu einer hinzugef\u00fcgten QwtPlotCurve QWidget* legendWidget = d_legend- legendWidget(itemToInfo(plotCurve1)); QwtLegendLabel* label = qobject_cast QwtLegendLabel* (legendWidget); // das Signal verkn\u00fcpfen connect(label, SIGNAL(checked(bool)), this, SLOT(onCurveVisibilityChanged(bool)) ); Hinweis: Statt qobject_cast QwtLegendLabel* k\u00f6nnte man auch `dynamic_cast verwenden, ersteres ist aber schneller und daher besser bei QObject-abgeleiteten Klassentypen.","title":"Auf Checked/Unchecked-Ereignisse reagieren"},{"location":"interaction/#sichtbarunsichtbar-schalten-von-linienkurven-im-diagramm-qwtplotcurve","text":"Die Implementierung bei Liniendiagrammen sieht so aus: void MyPlot::onCurveVisibilityChanged (bool on) { QObject * origin = sender(); // cast pointer to QwtLegendItem QwtLegendLabel * item = qobject_cast QwtLegendLabel * (origin); // check that is was a valid sender if (item == NULL) return; // invalid origin // now find out which curve belongs to this legend item for (unsigned int i=0; i NumCurves; ++i) { if (m_curves[i] == NULL) continue; // skip empty curves QWidget* legendWidget = m_legend- legendWidget(itemToInfo(m_curves[i])); QwtLegendLabel* label = qobject_cast QwtLegendLabel* (legendWidget); if (label == item) { // set visibility of curve based on function argument m_curves[i]- setVisible(on); replot(); break; } } }","title":"Sichtbar/Unsichtbar-Schalten von Linien/Kurven im Diagramm (QwtPlotCurve)"},{"location":"interaction/#legendeneintrage-alternativ-schalten","text":"Implement show curve function such: void CpuPlot::showCurve(QwtPlotItem *item, bool on) { // wenn eine Curve angeschaltet werden soll, vorher alle anderen ausschalten if (on) { const QwtPlotItemList list = this- itemList(); for (QwtPlotItemIterator it = list.begin();it!=list.end();++it) { QwtPlotItem *item2 = *it; if (item2- rtti() == QwtPlotItem::Rtti_PlotCurve) item2- setVisible(false); } } item- setVisible(on); // Legendenwidget aktualisieren QWidget *w = legend()- find(item); if ( w w- inherits( QwtLegendItem ) ) ((QwtLegendItem *)w)- setChecked(on); replot(); }","title":"Legendeneintr\u00e4ge alternativ schalten"},{"location":"porting/","text":"Wesentliche \u00c4nderungen ... Legenden externe Legenden... Spektrogramme ColorMaps FactoryPattern verwenden","title":"von Qwt 5.x zu 6.x"},{"location":"porting/#wesentliche-anderungen","text":"...","title":"Wesentliche \u00c4nderungen"},{"location":"porting/#legenden","text":"externe Legenden...","title":"Legenden"},{"location":"porting/#spektrogramme","text":"","title":"Spektrogramme"},{"location":"porting/#colormaps","text":"FactoryPattern verwenden","title":"ColorMaps"}]}
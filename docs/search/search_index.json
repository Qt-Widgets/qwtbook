{
    "docs": [
        {
            "location": "/", 
            "text": "Das Qwt (Hand-)Buch\n\n\nCopyright 2018, Andreas Nicolai \n\n\n\n\n\nQwt (\nQwt - Qt Widgets for Technical Applications\n, akt. Entwickler \nUwe Rathmann\n) ist eine open-source Bibliothek f\u00fcr technische Anwendungen und stellt\nbestimmte Widgets f\u00fcr Anzeigen und Kontrollkomponenten bereit. Die wohl wichtigste Komponente der Qwt Bibliothek ist das \nQwtPlot\n,\neine sehr flexible und m\u00e4chtige Diagrammkomponente.\n\n\n\n\nDie Qwt Bibliothek steht unter einer OpenSource Lizenz und wird auf\nSourceForge.net gehostet:\n\n\n\n\nQwt Webseite (englisch)\n\n\nQwt SourceForge Projektseite\n\n\n\n\nHandbuchstruktur\n\n\nDas Handbuch ist in folgende Kapitel unterteilt:\n\n\n\n\nAllgemeine Einf\u00fchrung\n gibt einen Kurz\u00fcberblick \u00fcber die Bibliothek und deren Grundkonzepte\n\n\nErstellen und Verwenden\n beschreibt die Konfiguration und Erstellung der Bibliothek, und die Verwendung in eigenen Programmen\n\n\nDas Kapitel \nGrundlagen\n beginnt mit einem einfachen Einf\u00fchrungsbeispiel, in welchem die einzelnen Schritte bis zum fertigen Diagramm beschrieben sind. Danach werden die einzelnen Anpassungsm\u00f6glichkeiten beschrieben.\n\n\nDiagramm-Interaktion\n beschreibt die Funktionen zur Nutzerinterkation mit dem Diagramm, z.B. Zoomen und Verschieben des Diagrammausschnitts, Anzeige von Werten unter dem Cursor, etc.\n\n\nIm Kapitel \nFortgeschrittenes\n werden weiterf\u00fchrende Techniken zur Anpassung des Diagrammerscheinungsbildes beschrieben.\n\n\nAnpassungen\n beschreibt die Erweiterung der Diagrammfunktionalit\u00e4t durch eigenen Klassen, welche die eingebauten Qwt-Klassen durch \u00dcberladung erweitern\n\n\nDrucken/Exportieren\n behandelt das Thema des Diagrammexports als Bild oder Vektorgrafik, letzteres auch zum Drucken des Diagramms\n\n\nIm Anhangskapitel \nvon Qwt 5.x zu 6.x\n werden typische Fragen und Problemstellungen bei der Portierung von Qwt 5 auf Qwt 6 beantwortet.\n\n\n\n\nAllgemeine Einf\u00fchrung\n\n\n\u00dcber die Bibliothek\n\n\nEntwicklungsgeschichte\n\n\n\n\ndie erste Version der Qwt-Bibliothek stammt noch aus dem Jahr 1997 von Josef Wilgen\n\n\nseit 2002 wird die Bibliothek von \nUwe Rathmann\n entwickelt und gepflegt\n\n\nVersion 5 ist wohl am weitesten verbreitet (erstes Release vom 26.02.2007)\n\n\nVersion 6 (erstes Release vom 15.04.2011, kein Qt3 Support mehr) enth\u00e4lt wesentliche API-\u00c4nderungen\n\n\naktuelle stabile Version 6.1.3, im trunk gibt es bereits wesentlich mehr und fortgeschrittene Funktionen\n\n\n\n\nDownload der Bibliothek\n\n\nDie Qwt Bibliothek kann von der \nQwt SourceForge Projektseite\n als Quelltextarchiv\ngeladen werden. Unter Linux wird Qwt bei vielen Distributionen als Paket gehalten. Genau genommen gibt es mehrere Pakete f\u00fcr die unterschiedlichen Qwt-Bibliotheksversionen.\n\n\nUbuntu 16.04 LTS\n:\n\n\n# Qwt 5.x unter Verwendung von qt4 (f\u00fcr Qwt 5.2.3-1)\nsudo apt install libqwt5-qt4-dev\n\n# Qwt 6.x unter Verwendung von qt5 (f\u00fcr Qwt 6.1.2-5)\nsudo apt install libqwt-qt5-dev\n\n\n\n\nUbuntu 18.04 LTS\n:\n\n\n# Qwt 5.x unter Verwendung von qt4 (f\u00fcr Qwt 5.2.3-1)\nsudo apt install libqwt5-qt4-dev\n\n# Qwt 6.x unter Verwendung von qt4 (f\u00fcr Qwt 6.1.3-1)\nsudo apt install libqwt-dev\n\n# Qwt 6.x unter Verwendung von qt5 (f\u00fcr Qwt 6.1.3-1)\nsudo apt install libqwt-qt5-dev\n\n\n\n\nWidget-Konzept und Erscheinungsbild\n\n\nDie Qwt Bibliothek liefert Komponenten, welche analog zu den normalen Qt-Widgets in Deskopanwendungen verwendet werden k\u00f6nnen. Die Komponenten verwenden die vom jeweiligen Oberfl\u00e4chenstil definierten Paletteneinstellungen, sodass die Qwt-Widgets in die jeweilige Oberfl\u00e4che passen. Dadurch integrieren sich die Widgets nahtlos in Programmoberfl\u00e4chen. Abrundungseffekte beim Plot-Widget erm\u00f6glichen das Immitieren klassischer Anzeigen:\n\n\n\n\nBei den Kontroll-Komponenten wird die Farbgebung \u00fcber Palettenrollen definiert, z.B. bei den Zeigerkontrollen (\nQwtDial\n) via \nQPalette::WindowText\n (der Hintergrund der inneren Fl\u00e4che) und \nQPalette::Base\n (die Grundfarbe des \u00e4u\u00dferen Ringes) und \nQPalette::Text\n (die Schriftfarbe):\n\n\n\nIn \u00e4hnlicher Weise k\u00f6nnen auch Gradienten benutzt werden, um ein plastisches Erscheinungsbild zu erzeugen:\n\n\n\nBei der \nQwtPlot\n-Komponente betrifft das alle Teile, die au\u00dferhalb der eigentlichen Zeichenfl\u00e4che liegen. Das hei\u00dft\n\n\n\n\nTitel,\n\n\nau\u00dfenliegende Legende,\n\n\nAchsen, und\n\n\nDiagrammrahmen (einschlie\u00dflich des m\u00f6glichen 3D Rahmeneffekts)\n\n\n\n\nwerden durch die Paletten-Eigenschaften des Plotwidgets beeinflusst (siehe Beschreibung der relevanten Funktionen in \nRahmen und Zeichenfl\u00e4che\n)\n\n\nBesitzer/Eigent\u00fcmer-Konzept des QwtPlot-Widgets\n\n\nEine grundlegende Eigenschaft der \nQwtPlot\n-Klasse ist die Besitz\u00fcbername hinzugef\u00fcgter Elemente. Dies gilt allgemein f\u00fcr Zeichenobjekte, die Legende etc. Einmal hinzugef\u00fcgte Elemente k\u00f6nnen nicht wieder losgel\u00f6st werden (bzw. nur \u00fcber einen Trick, wie im Kapitel \nFortgeschrittenes\n beschrieben wird). Daher ist es sinnvoll bei ver\u00e4nderlichen Diagrammelementen einen Mechanismus zur jeweiligen Neuerstellung eines Zeichenobjekts  vorzusehen (Factory-Konzept).\n\n\nBeispiel:\n\n\nvoid Plot::updateLegend() {\n    QwtLegend * legend = new Qwtlegend();\n    // Legendeneigenschaften setzen\n    ...\n\n    // Legende in Diagramm ersetzen (alte Legende wird gel\u00f6scht)\n    insertLegend(legend);\n}\n\n\n\n\nZeichenobjekte und deren Achsenabh\u00e4ngigkeit\n\n\nEin wesentliches Designmerkmal beim \nQwtPlot\n ist die M\u00f6glichkeit, beliebige Zeichenobjekte (Kurven, Marker, Legende, ...) dem Plot zu \u00fcbergeben. Damit sich diese Zeichenobjekte (engl. \nPlotItem\n) am Koordinatengitter ausrichten k\u00f6nnen, wird ihnen eine Achsenabh\u00e4ngigkeit gegeben. Dadurch erhalten diese Zeichenobjekte eine Information, wann immer sich die Achsenskalierung \u00e4ndert (durch Zoomen, oder \u00c4nderung der Wertebereiche etc.).\n\n\nDiese Funktionalit\u00e4t definiert die zentrale Bedeutung der (bis zu) 4 Achsen im Diagramm. Deswegen sind diese auch fest im \nQwtPlot\n verankert und werden nicht wie andere Zeichenobjekte beliebig hinzugef\u00fcgt.\n\n\nVererbungskonzept\n\n\nGrunds\u00e4tzlich ist das \nQwtPlot\n und die beteiligten Klassen auf maximale Anpassungsf\u00e4higkeit ausgelegt, d.h. es wird (fast) \u00fcberall Polymorphie unterst\u00fctzt. Wenn die eingebaute Funktionalit\u00e4t nicht zureichend ist, kann man einfach immer die entsprechende Klasse ableiten und die jeweils anzupassende Funktion re-implementieren und ver\u00e4ndern (siehe Kapitel \nAnpassungen\n).\n\n\nVerwendung der Designer Plugins\n\n\nDie Qwt Bibliothek bringt Plugins f\u00fcr Qt Designer mit, welche das Einf\u00fcgen von Qwt-Komponenten in ui-Dateien erleichtert. Es lassen sich jedoch keine QwtPlot-Eigenschaften festlegen oder Kurven hinzuf\u00fcgen. Die eigentliche Anpassung und Ausgestaltung des Plots erfolgt im Quelltext. Deswegen wird die Konfiguration und Anpassung des \nQwtPlot\n in diesem Handbuch ausschlie\u00dflich durch normale API-Aufrufe demonstriert.\n\n\n\n\nHinweis:\n Soll das QwtPlot auch ohne Designer-Plugins im grafischen QtDesigner-Editor eingef\u00fcgt werden, kann man einfach ein QWidget einf\u00fcgen und dieses als Platzhalter f\u00fcr die \nQwtPlot\n-Klasse definieren.\n\n\n\n\nEine Beschreibung, wie Designer-plugins erstellt und in Qt Creator/Designer integriert werden ist am Abschnitt [Qwt Designer Plugins(building#qwt-designer-plugins)] beschrieben.\n\n\n\n\nAutoreninfo: Schreibkonventionen\n:\n\n\n\n\nQwtDial\n - Qwt-Klassen im Flie\u00dftext immer als Code-Schnipsel\n\n\nQuelltextbl\u00f6cke immer mit c++ Hervorhebung einf\u00fcgen (Dreifach schr\u00e4ges Hochkomma)\n\n\nBilder ohne Skalierung einf\u00fcgen (Skalierung erfolgt durch CSS)", 
            "title": "Start"
        }, 
        {
            "location": "/#das-qwt-hand-buch", 
            "text": "Copyright 2018, Andreas Nicolai    Qwt ( Qwt - Qt Widgets for Technical Applications , akt. Entwickler  Uwe Rathmann ) ist eine open-source Bibliothek f\u00fcr technische Anwendungen und stellt\nbestimmte Widgets f\u00fcr Anzeigen und Kontrollkomponenten bereit. Die wohl wichtigste Komponente der Qwt Bibliothek ist das  QwtPlot ,\neine sehr flexible und m\u00e4chtige Diagrammkomponente.   Die Qwt Bibliothek steht unter einer OpenSource Lizenz und wird auf\nSourceForge.net gehostet:   Qwt Webseite (englisch)  Qwt SourceForge Projektseite", 
            "title": "Das Qwt (Hand-)Buch"
        }, 
        {
            "location": "/#handbuchstruktur", 
            "text": "Das Handbuch ist in folgende Kapitel unterteilt:   Allgemeine Einf\u00fchrung  gibt einen Kurz\u00fcberblick \u00fcber die Bibliothek und deren Grundkonzepte  Erstellen und Verwenden  beschreibt die Konfiguration und Erstellung der Bibliothek, und die Verwendung in eigenen Programmen  Das Kapitel  Grundlagen  beginnt mit einem einfachen Einf\u00fchrungsbeispiel, in welchem die einzelnen Schritte bis zum fertigen Diagramm beschrieben sind. Danach werden die einzelnen Anpassungsm\u00f6glichkeiten beschrieben.  Diagramm-Interaktion  beschreibt die Funktionen zur Nutzerinterkation mit dem Diagramm, z.B. Zoomen und Verschieben des Diagrammausschnitts, Anzeige von Werten unter dem Cursor, etc.  Im Kapitel  Fortgeschrittenes  werden weiterf\u00fchrende Techniken zur Anpassung des Diagrammerscheinungsbildes beschrieben.  Anpassungen  beschreibt die Erweiterung der Diagrammfunktionalit\u00e4t durch eigenen Klassen, welche die eingebauten Qwt-Klassen durch \u00dcberladung erweitern  Drucken/Exportieren  behandelt das Thema des Diagrammexports als Bild oder Vektorgrafik, letzteres auch zum Drucken des Diagramms  Im Anhangskapitel  von Qwt 5.x zu 6.x  werden typische Fragen und Problemstellungen bei der Portierung von Qwt 5 auf Qwt 6 beantwortet.", 
            "title": "Handbuchstruktur"
        }, 
        {
            "location": "/#allgemeine-einfuhrung", 
            "text": "", 
            "title": "Allgemeine Einf\u00fchrung"
        }, 
        {
            "location": "/#uber-die-bibliothek", 
            "text": "", 
            "title": "\u00dcber die Bibliothek"
        }, 
        {
            "location": "/#entwicklungsgeschichte", 
            "text": "die erste Version der Qwt-Bibliothek stammt noch aus dem Jahr 1997 von Josef Wilgen  seit 2002 wird die Bibliothek von  Uwe Rathmann  entwickelt und gepflegt  Version 5 ist wohl am weitesten verbreitet (erstes Release vom 26.02.2007)  Version 6 (erstes Release vom 15.04.2011, kein Qt3 Support mehr) enth\u00e4lt wesentliche API-\u00c4nderungen  aktuelle stabile Version 6.1.3, im trunk gibt es bereits wesentlich mehr und fortgeschrittene Funktionen", 
            "title": "Entwicklungsgeschichte"
        }, 
        {
            "location": "/#download-der-bibliothek", 
            "text": "Die Qwt Bibliothek kann von der  Qwt SourceForge Projektseite  als Quelltextarchiv\ngeladen werden. Unter Linux wird Qwt bei vielen Distributionen als Paket gehalten. Genau genommen gibt es mehrere Pakete f\u00fcr die unterschiedlichen Qwt-Bibliotheksversionen.  Ubuntu 16.04 LTS :  # Qwt 5.x unter Verwendung von qt4 (f\u00fcr Qwt 5.2.3-1)\nsudo apt install libqwt5-qt4-dev\n\n# Qwt 6.x unter Verwendung von qt5 (f\u00fcr Qwt 6.1.2-5)\nsudo apt install libqwt-qt5-dev  Ubuntu 18.04 LTS :  # Qwt 5.x unter Verwendung von qt4 (f\u00fcr Qwt 5.2.3-1)\nsudo apt install libqwt5-qt4-dev\n\n# Qwt 6.x unter Verwendung von qt4 (f\u00fcr Qwt 6.1.3-1)\nsudo apt install libqwt-dev\n\n# Qwt 6.x unter Verwendung von qt5 (f\u00fcr Qwt 6.1.3-1)\nsudo apt install libqwt-qt5-dev", 
            "title": "Download der Bibliothek"
        }, 
        {
            "location": "/#widget-konzept-und-erscheinungsbild", 
            "text": "Die Qwt Bibliothek liefert Komponenten, welche analog zu den normalen Qt-Widgets in Deskopanwendungen verwendet werden k\u00f6nnen. Die Komponenten verwenden die vom jeweiligen Oberfl\u00e4chenstil definierten Paletteneinstellungen, sodass die Qwt-Widgets in die jeweilige Oberfl\u00e4che passen. Dadurch integrieren sich die Widgets nahtlos in Programmoberfl\u00e4chen. Abrundungseffekte beim Plot-Widget erm\u00f6glichen das Immitieren klassischer Anzeigen:   Bei den Kontroll-Komponenten wird die Farbgebung \u00fcber Palettenrollen definiert, z.B. bei den Zeigerkontrollen ( QwtDial ) via  QPalette::WindowText  (der Hintergrund der inneren Fl\u00e4che) und  QPalette::Base  (die Grundfarbe des \u00e4u\u00dferen Ringes) und  QPalette::Text  (die Schriftfarbe):  In \u00e4hnlicher Weise k\u00f6nnen auch Gradienten benutzt werden, um ein plastisches Erscheinungsbild zu erzeugen:  Bei der  QwtPlot -Komponente betrifft das alle Teile, die au\u00dferhalb der eigentlichen Zeichenfl\u00e4che liegen. Das hei\u00dft   Titel,  au\u00dfenliegende Legende,  Achsen, und  Diagrammrahmen (einschlie\u00dflich des m\u00f6glichen 3D Rahmeneffekts)   werden durch die Paletten-Eigenschaften des Plotwidgets beeinflusst (siehe Beschreibung der relevanten Funktionen in  Rahmen und Zeichenfl\u00e4che )", 
            "title": "Widget-Konzept und Erscheinungsbild"
        }, 
        {
            "location": "/#besitzereigentumer-konzept-des-qwtplot-widgets", 
            "text": "Eine grundlegende Eigenschaft der  QwtPlot -Klasse ist die Besitz\u00fcbername hinzugef\u00fcgter Elemente. Dies gilt allgemein f\u00fcr Zeichenobjekte, die Legende etc. Einmal hinzugef\u00fcgte Elemente k\u00f6nnen nicht wieder losgel\u00f6st werden (bzw. nur \u00fcber einen Trick, wie im Kapitel  Fortgeschrittenes  beschrieben wird). Daher ist es sinnvoll bei ver\u00e4nderlichen Diagrammelementen einen Mechanismus zur jeweiligen Neuerstellung eines Zeichenobjekts  vorzusehen (Factory-Konzept).  Beispiel:  void Plot::updateLegend() {\n    QwtLegend * legend = new Qwtlegend();\n    // Legendeneigenschaften setzen\n    ...\n\n    // Legende in Diagramm ersetzen (alte Legende wird gel\u00f6scht)\n    insertLegend(legend);\n}", 
            "title": "Besitzer/Eigent\u00fcmer-Konzept des QwtPlot-Widgets"
        }, 
        {
            "location": "/#zeichenobjekte-und-deren-achsenabhangigkeit", 
            "text": "Ein wesentliches Designmerkmal beim  QwtPlot  ist die M\u00f6glichkeit, beliebige Zeichenobjekte (Kurven, Marker, Legende, ...) dem Plot zu \u00fcbergeben. Damit sich diese Zeichenobjekte (engl.  PlotItem ) am Koordinatengitter ausrichten k\u00f6nnen, wird ihnen eine Achsenabh\u00e4ngigkeit gegeben. Dadurch erhalten diese Zeichenobjekte eine Information, wann immer sich die Achsenskalierung \u00e4ndert (durch Zoomen, oder \u00c4nderung der Wertebereiche etc.).  Diese Funktionalit\u00e4t definiert die zentrale Bedeutung der (bis zu) 4 Achsen im Diagramm. Deswegen sind diese auch fest im  QwtPlot  verankert und werden nicht wie andere Zeichenobjekte beliebig hinzugef\u00fcgt.", 
            "title": "Zeichenobjekte und deren Achsenabh\u00e4ngigkeit"
        }, 
        {
            "location": "/#vererbungskonzept", 
            "text": "Grunds\u00e4tzlich ist das  QwtPlot  und die beteiligten Klassen auf maximale Anpassungsf\u00e4higkeit ausgelegt, d.h. es wird (fast) \u00fcberall Polymorphie unterst\u00fctzt. Wenn die eingebaute Funktionalit\u00e4t nicht zureichend ist, kann man einfach immer die entsprechende Klasse ableiten und die jeweils anzupassende Funktion re-implementieren und ver\u00e4ndern (siehe Kapitel  Anpassungen ).", 
            "title": "Vererbungskonzept"
        }, 
        {
            "location": "/#verwendung-der-designer-plugins", 
            "text": "Die Qwt Bibliothek bringt Plugins f\u00fcr Qt Designer mit, welche das Einf\u00fcgen von Qwt-Komponenten in ui-Dateien erleichtert. Es lassen sich jedoch keine QwtPlot-Eigenschaften festlegen oder Kurven hinzuf\u00fcgen. Die eigentliche Anpassung und Ausgestaltung des Plots erfolgt im Quelltext. Deswegen wird die Konfiguration und Anpassung des  QwtPlot  in diesem Handbuch ausschlie\u00dflich durch normale API-Aufrufe demonstriert.   Hinweis:  Soll das QwtPlot auch ohne Designer-Plugins im grafischen QtDesigner-Editor eingef\u00fcgt werden, kann man einfach ein QWidget einf\u00fcgen und dieses als Platzhalter f\u00fcr die  QwtPlot -Klasse definieren.   Eine Beschreibung, wie Designer-plugins erstellt und in Qt Creator/Designer integriert werden ist am Abschnitt [Qwt Designer Plugins(building#qwt-designer-plugins)] beschrieben.   Autoreninfo: Schreibkonventionen :   QwtDial  - Qwt-Klassen im Flie\u00dftext immer als Code-Schnipsel  Quelltextbl\u00f6cke immer mit c++ Hervorhebung einf\u00fcgen (Dreifach schr\u00e4ges Hochkomma)  Bilder ohne Skalierung einf\u00fcgen (Skalierung erfolgt durch CSS)", 
            "title": "Verwendung der Designer Plugins"
        }, 
        {
            "location": "/building/", 
            "text": "Verwendung der Bibliothek in eigenen Programmen\n\n\nWie bei anderen externen Bibliotheken, gibt es grunds\u00e4tzlich zwei M\u00f6glichkeiten, die Qwt-Bibliothek in eigenen Projekten zu verwenden:\n\n\n\n\nVerwendung einer installierten, kompilierten Bibliothek unter Verwendung der installierten Headerdateien\n\n\nVerwendung der Qwt-Bibliothek im Quelltext innerhalb der eigenen Projektstruktur\n\n\n\n\nUnter Linux-Systemen (bzw. unter MacOSX, wenn Qwt \u00fcber Homebrew oder MacPorts installiert ist), wird zumeist die Variante 1 sinnvoll sein.\n\n\nVariante 2 ist stets dann sinnvoll, wenn man Zugriff auf die Implementierung der Qwt-Bibliothek haben m\u00f6chte und gegebenenfalls eigene \u00c4nderungen einbringen m\u00f6chte, oder wenn man mit einer noch nicht ver\u00f6ffentlichten Version aus einem Quelltextarchiv arbeiten will.\n\n\nAuch f\u00fcr die Verwendung von Visual Studio unter Windows ist die Variante 2 am sinnvollsten, da so flexibel zwischen Debug und Release-Builds umgeschaltet werden kann (siehe \nVisual Studio Projekte\n).\n\n\nVerwenden der vorkompilierten Bibliothek\n\n\n\n\ninclude Pfade\n\n\nlib-Dateinamen, statische/dynamische libs\n\n\n\n\nQMake und Qt Creator\n\n\n...\n\n\nCMake\n\n\n...\n\n\nVisual Studio\n\n\n...\n\n\nErstellung aus dem Quelltext\n\n\nDie Qwt-Bibliothek kann auch als Quelltext-Archiv heruntergeladen werden. In diesem Fall muss die Bibliothek zuerst erstellt und gegebenenfalls installiert werden. Letzteres kopiert Bibliothek und ben\u00f6tigte Headerdateien ins Installationsverzeichnis, sodass andere Bibliotheken/Programme darauf zugreifen k\u00f6nnen.\n\n\nJe nach Entwicklungsumgebung/Build-System kann man die Bibliothek auch ohne Installation verwenden (siehe \nVerwendung der vorkompilierten Bibliothek\n).\n\n\nQuelltext-Verzeichnisstruktur\n\n\nDas Quelltextarchiv enth\u00e4lt folgende Verzeichnisstruktur:\n\n\nadmin         # Deployment-Scripte, in trunk\nclassincludes # Include-Dateien im Still von Qt5 Includes\ndesigner/     # Quelltext der Designer-Plugins\ndoc/          # Doxygen Konfigurationsdateien\nexamples/     # Beispiele\nplayground/   # Zus\u00e4tzliche Tests/Beispiele, ab Qwt 6.2\nsrc/          # Der eigentliche Quelltext\ntests/        # spez. Komponententests, ab Qwt 6.2\ntextengines/  # Zusatzkomponenten f\u00fcr Texte (MathML), ab Qwt 6.3\n\nQwtbuild.pri      # Grundlegende Kompilierungseinstellungen\nQwtconfig.pri     # Auswahl der zu kompilierenden Teile\nQwt.pro           # Master QMake-Datei\n\n\n\n\nErstellen mit qmake\n\n\nKonfiguration\n\n\n\n\nTODO: QMake Build System und einflussreiche Dateien\n\n\nTODO: wo passe ich was an\n\n\nTODO: wie erstelle ich Beispiele (-\n Examples + Playground)\n\n\n\n\nErstellen und (optionale) Installation\n\n\nIm Basisverzeichnes des Qwt Quelltextarchivs (bezeichnet mit \nqwt-root\n) ist \nqmake\n aufzurufen und dann \nmake\n, bzw. unter Windows entsprechend \njom\n oder \nnmake\n.\n\n\nqmake\nmake\n\n\n\n\nDie Beispiele (sofern konfiguriert) werden in \nqwt-root\n/examples/bin\n erstellt.\n\n\n... TODO\n\n\nErstellen mit cmake\n\n\nVisual Studio Projektdateien\n\n\n\n\nmit Erstellen der Bibliothek (Qwt-vcproj)\n\n\n\n\nQwt Designer Plugins\n\n\n...", 
            "title": "Erstellen und Verwenden"
        }, 
        {
            "location": "/building/#verwendung-der-bibliothek-in-eigenen-programmen", 
            "text": "Wie bei anderen externen Bibliotheken, gibt es grunds\u00e4tzlich zwei M\u00f6glichkeiten, die Qwt-Bibliothek in eigenen Projekten zu verwenden:   Verwendung einer installierten, kompilierten Bibliothek unter Verwendung der installierten Headerdateien  Verwendung der Qwt-Bibliothek im Quelltext innerhalb der eigenen Projektstruktur   Unter Linux-Systemen (bzw. unter MacOSX, wenn Qwt \u00fcber Homebrew oder MacPorts installiert ist), wird zumeist die Variante 1 sinnvoll sein.  Variante 2 ist stets dann sinnvoll, wenn man Zugriff auf die Implementierung der Qwt-Bibliothek haben m\u00f6chte und gegebenenfalls eigene \u00c4nderungen einbringen m\u00f6chte, oder wenn man mit einer noch nicht ver\u00f6ffentlichten Version aus einem Quelltextarchiv arbeiten will.  Auch f\u00fcr die Verwendung von Visual Studio unter Windows ist die Variante 2 am sinnvollsten, da so flexibel zwischen Debug und Release-Builds umgeschaltet werden kann (siehe  Visual Studio Projekte ).", 
            "title": "Verwendung der Bibliothek in eigenen Programmen"
        }, 
        {
            "location": "/building/#verwenden-der-vorkompilierten-bibliothek", 
            "text": "include Pfade  lib-Dateinamen, statische/dynamische libs", 
            "title": "Verwenden der vorkompilierten Bibliothek"
        }, 
        {
            "location": "/building/#qmake-und-qt-creator", 
            "text": "...", 
            "title": "QMake und Qt Creator"
        }, 
        {
            "location": "/building/#cmake", 
            "text": "...", 
            "title": "CMake"
        }, 
        {
            "location": "/building/#visual-studio", 
            "text": "...", 
            "title": "Visual Studio"
        }, 
        {
            "location": "/building/#erstellung-aus-dem-quelltext", 
            "text": "Die Qwt-Bibliothek kann auch als Quelltext-Archiv heruntergeladen werden. In diesem Fall muss die Bibliothek zuerst erstellt und gegebenenfalls installiert werden. Letzteres kopiert Bibliothek und ben\u00f6tigte Headerdateien ins Installationsverzeichnis, sodass andere Bibliotheken/Programme darauf zugreifen k\u00f6nnen.  Je nach Entwicklungsumgebung/Build-System kann man die Bibliothek auch ohne Installation verwenden (siehe  Verwendung der vorkompilierten Bibliothek ).", 
            "title": "Erstellung aus dem Quelltext"
        }, 
        {
            "location": "/building/#quelltext-verzeichnisstruktur", 
            "text": "Das Quelltextarchiv enth\u00e4lt folgende Verzeichnisstruktur:  admin         # Deployment-Scripte, in trunk\nclassincludes # Include-Dateien im Still von Qt5 Includes\ndesigner/     # Quelltext der Designer-Plugins\ndoc/          # Doxygen Konfigurationsdateien\nexamples/     # Beispiele\nplayground/   # Zus\u00e4tzliche Tests/Beispiele, ab Qwt 6.2\nsrc/          # Der eigentliche Quelltext\ntests/        # spez. Komponententests, ab Qwt 6.2\ntextengines/  # Zusatzkomponenten f\u00fcr Texte (MathML), ab Qwt 6.3\n\nQwtbuild.pri      # Grundlegende Kompilierungseinstellungen\nQwtconfig.pri     # Auswahl der zu kompilierenden Teile\nQwt.pro           # Master QMake-Datei", 
            "title": "Quelltext-Verzeichnisstruktur"
        }, 
        {
            "location": "/building/#erstellen-mit-qmake", 
            "text": "", 
            "title": "Erstellen mit qmake"
        }, 
        {
            "location": "/building/#konfiguration", 
            "text": "TODO: QMake Build System und einflussreiche Dateien  TODO: wo passe ich was an  TODO: wie erstelle ich Beispiele (-  Examples + Playground)", 
            "title": "Konfiguration"
        }, 
        {
            "location": "/building/#erstellen-und-optionale-installation", 
            "text": "Im Basisverzeichnes des Qwt Quelltextarchivs (bezeichnet mit  qwt-root ) ist  qmake  aufzurufen und dann  make , bzw. unter Windows entsprechend  jom  oder  nmake .  qmake\nmake  Die Beispiele (sofern konfiguriert) werden in  qwt-root /examples/bin  erstellt.  ... TODO", 
            "title": "Erstellen und (optionale) Installation"
        }, 
        {
            "location": "/building/#erstellen-mit-cmake", 
            "text": "", 
            "title": "Erstellen mit cmake"
        }, 
        {
            "location": "/building/#visual-studio-projektdateien", 
            "text": "mit Erstellen der Bibliothek (Qwt-vcproj)", 
            "title": "Visual Studio Projektdateien"
        }, 
        {
            "location": "/building/#qwt-designer-plugins", 
            "text": "...", 
            "title": "Qwt Designer Plugins"
        }, 
        {
            "location": "/basics/", 
            "text": "Kleine Einf\u00fchrung ins QwtPlot\n\n\nEin paar kleinere Beispiele sollen zun\u00e4chst die grundlegende Funktionalit\u00e4t und Benutzung des \nQwtPlot\n-Widgets zeigen.\n\n\n\n\nHinweis:\n In den nachfolgenden Beispielen werden die in der Qwt-Bibliothek enthaltenen Klassen direkt verwendet und nur deren Attribute angepasst. Weiterf\u00fchrende Anpassungen durch Re-Implementierung von Funktionen in abgeleiteten Klassen werden im Kapitel \nAnpassungen\n beschrieben.\n\n\n\n\nEin Kurvendiagramm\n\n\nBeginnen wir mit einem einfachen X-Y-Diagramm welches eine Linie darstellt:\n\n\n#include \nQApplication\n\n#include \nQwtPlot\n         // oder \nqwt_plot.h\n\n#include \nQwtPlotCurve\n    // oder \nqwt_plot_curve.h\n\n\nint main( int argc, char **argv ) {\n    QApplication a( argc, argv );\n\n    // create plot as main widget\n    QwtPlot plot;\n    plot.setTitle( \nPlot Demo\n );\n    plot.setCanvasBackground( Qt::white );\n\n    // create a new curve to be shown in the plot and set some properties\n    QwtPlotCurve *curve = new QwtPlotCurve();\n    curve-\nsetTitle( \nSome Points\n ); // will later be used in legend\n    curve-\nsetPen( Qt::blue, 4 ), // color and thickness in pixels\n    curve-\nsetRenderHint( QwtPlotItem::RenderAntialiased, true ); // use antialiasing\n\n    // data points\n    QPolygonF points;\n    points \n QPointF( 0.0, 4.4 ) \n QPointF( 1.0, 3.0 )\n        \n QPointF( 2.0, 4.5 ) \n QPointF( 3.0, 6.8 )\n        \n QPointF( 4.0, 7.9 ) \n QPointF( 5.0, 7.1 );\n\n    // give some points to the curve\n    curve-\nsetSamples( points );\n\n    // set the curve in the plot\n    curve-\nattach( \nplot );\n\n    plot.resize( 600, 400 );\n    plot.show();\n\n    return a.exec();\n}\n\n\n\n\nDies ergibt ein (noch ziemlich langweiliges) Diagrammfenster:\n\n\n\n\nInclude-Dateien\n\n\nGrunds\u00e4tzlich gibt es zwei unterschiedliche Varianten f\u00fcr Include-Dateinamen - entweder man verwendet die tats\u00e4chlichen Header-Dateinamen, also z.B. \n#include \nqwt_plot.h\n f\u00fcr die Klasse \nQwtPlot\n, oder man verwendet die klassenspezifischen Headerdateien \n#include \nQwtPlot\n (das sind Verweise auf die eigentlichen Headerdateien, wie bei Qt5 \u00fcblich). Da manche Headerdateien die Deklarationen f\u00fcr verschiedene Qwt-Klassen enthalten, ist es h\u00e4ufig einfacher bei Kenntniss des Klassennames auch einfach die entsprechend gleichnamigen Headerdateien zu verwenden.\n\n\n\n\nHinweis:\n In den nachfolgenden Beispielen werden die \nneuen\n Headerdateinamen (=Klassennamen) verwendet. In den Beispielen im \nexamples\n-Verzeichnis der Qwt-Bibliothek werden die eigentlichen Headerdateinamen eingebunden.\n\n\n\n\nPlot-Widget und Hintergrundfarbe der Zeichenfl\u00e4che\n\n\nIm obigen Quelltext wird zun\u00e4chst das \nQwtPlot\n Widget erstellt und erh\u00e4lt einen Titel. Der  \nCanvasBackground\n ist der Hintergrund der Zeichenfl\u00e4che. Der Befehl:\n\n\nplot.setCanvasBackground( Qt::white );\n\n\n\n\nlegt nur die Hintergrundfarbe der eigentlichen Zeichenfl\u00e4che (engl. \nCanvas\n) fest (siehe auch \nErscheinungsbild des Plots anpassen\n).\n\n\nKurve als Zeichenobjekt hinzuf\u00fcgen\n\n\nAls n\u00e4chstes wird ein Zeichenobjekt (engl. \nPlotItem\n) f\u00fcr eine Linie/Kurve erstellt und konfiguriert.\n\n\nEs gibt viele verschiedene Arten von Zeichenobjekten. Alle haben gemeinsam, dass sie auf der Zeichenfl\u00e4che gezeichnet werden. Die Reihenfolge des Zeichnens ist dabei f\u00fcr die Sichtbarkeit der einzelnen Zeichenobjekte wichtig (dazu sp\u00e4ter mehr, siehe Abschnitt \nZeichenreihenfolge\n).\n\n\nGrunds\u00e4tzlich\n werden alle Zeichenobjekte \nauf dem Heap (im Hauptspeicher) erstellt\n und sp\u00e4ter dem Plot \u00fcbereignet. Das passiert mit:\n\n\ncurve-\nattach( \nplot );\n\n\n\n\nwobei das Plot Besitzer des Zeichenobjekts (d.h. unserer Kurve) wird und sich sp\u00e4ter um das Speicheraufr\u00e4umen k\u00fcmmert.\n\n\nZu den sinnvoll anzupassenden Eigenschaften einer Kurve geh\u00f6ren die Farbe und die Linienst\u00e4rke, siehe \nQwtPlotCurve::setPen()\n. Bei dicken Linien lohnt sich das Einschalten von Antialiasing f\u00fcr die Liniendarstellung.\n\n\n\n\nHinweis:\n Das Setzen von Zeichenattributen via \nsetRenderHint()\n wird von allen Zeichenobjekten unterst\u00fctzt. So kann man Eigenschaften wie Antialiasing individuell f\u00fcr verschiedene Zeichenobjekte setzen.\n\n\n\n\nDie hinzugef\u00fcgte Kurve ist standardm\u00e4\u00dfig der unteren X-Achse und der linken Y-Achse zugeordnet, sodass die Daten der Kurve gleichzeitig zur automatischen Skalierung der Achsen verwendet werden.\n\n\nDer Titel der Linie wird mittels \nQwtPlotCurve::setTitle()\n gesetzt und in der Legende verwendet, welche wir als n\u00e4chstes einf\u00fcgen (weitere Kurveneigenschaften werden sp\u00e4ter besprochen).\n\n\nLegende, Diagrammachsen und Hauptgitterlinien\n\n\nLegende hinzuf\u00fcgen\n\n\nUm eine Legende hinzuzuf\u00fcgen, braucht man lediglich eine Instanz der \nQwtLegend\n-Klasse erstellen und im Plot einf\u00fcgen:\n\n\nQwtLegend * legend = new QwtLegend();\nplot.insertLegend( legend , QwtPlot::BottomLegend);\n\n\n\n\nDer dazugeh\u00f6riger Header wird mittels \n#include \nQwtLegend\n eingebunden. Wie auch beim Zeichenobjekt (Kurve) wird das Plot Besitzer der Legende und verwaltet die Resource.\n\n\n\n\nHinweis:\n Wird eine andere Legende gesetzt, so wird die alte zuerst gel\u00f6scht. Es ist daher nicht erlaubt, auf eine ersetzte Legende weiterhin zuzugreifen (um das zu umgehen, siehe auch \nBesitz\u00fcbernahme von Objekten des Plots\n).\n\n\n\n\nWeitere Eigenschaften der Legende werden im Kapitel zur \nLegendenformatierung\n erl\u00e4utert.\n\n\nDiagrammachsen konfigurieren\n\n\nIm Gegensatz zu Legende oder Kurven sind Achsen keine Zeichenobjekte sondern fest mit dem Diagramm verbunden. Die Sichtbarkeit der 4 Achsen (links, rechts, oben und unten) kann jedoch individuell festgelegt werden.\n\n\nAchseneigenschaften legt man direkt \u00fcber Zugriffsfunktionen der \nQwtPlot\n-Klasse fest, wie z.B. selbstgew\u00e4hlte min/max-Werte:\n\n\nplot.setAxisScale( QwtPlot::yLeft, 0.0, 10.0 );\n\n\n\n\nDie Achsen werden durch \nQwtPlot::yLeft\n, \nQwtPlot::yRight\n, \nQwtPlot::xBottom\n und \nQwtPlot::xTop\n identifiziert.\n\n\nGitterraster einf\u00fcgen\n\n\nUm in der Zeichenfl\u00e4che Gitterlinien zu zeichnen, f\u00fcgt man einfach ein entsprechendes Zeichenobjekt hinzu.\n\n\nQwtPlotGrid *grid = new QwtPlotGrid();\ngrid-\nsetMajorPen(QPen(Qt::DotLine));\ngrid-\nattach( \nplot );\n\n\n\n\nWie schon bei der Legende wird die Instanz der Klasse \nQwtPlotGrid\n (einzubinden via \n#include \nQwtPlotGrid\n) zun\u00e4chst im Hauptspeicher angelegt, konfiguriert (hier wird nur der QPen der Hauptgitterlinien ver\u00e4ndert) und schlie\u00dflich dem Plot hinzugef\u00fcgt.\n\n\nLiniensymbole hinzuf\u00fcgen\n\n\nAls ein Beispiel etwas weiterf\u00fchrender Konfiguration der Linien (\nQwtPlotCurve\n) wird hier ein Liniensymbol hinzugef\u00fcgt. Diese Eigenschaft (konkret das Zeichnen des Symbols) ist wieder anpassungsf\u00e4hig ausgelegt und nicht fest in der Klasse \nQwtPlotCurve\n integriert.\n\n\nF\u00fcr das Zeichnen von Symbolen existiert die Klasse \nQwtSymbol\n, welche nicht direkt als Zeichenobjekt verwendet wird, sondern eine Hilfsimplementierung f\u00fcr verschiedene Anwendungszwecke darstellt. Liniensymbole werden folgenderma\u00dfen erstellt:\n\n\nQwtSymbol *symbol = new QwtSymbol(\n    QwtSymbol::Ellipse,    // Form\n    QBrush( Qt::yellow ),  // F\u00fcllung\n    QPen( Qt::red, 2 ),    // Rand\n    QSize( 8, 8 ) );       // Gr\u00f6\u00dfe in Pixel\n\ncurve-\nsetSymbol( symbol ); // Kurve wurde Besitzer\n\n\n\n\nMit diesen Anpassungen sieht das Diagramm schon besser aus (siehe auch Beispiel \nexamples/SimplePlot\n)\n\n\n\n\n\n\nDiagrammtypen\n\n\n\n\nallgemeines zu PlotItems/Curves\n\n\n\n\nLiniendiagramme und Punktwolken\n\n\nLiniendiagramme, Punktwolken oder sonstige X-Y-Datenreihen werden mittels \nQwtPlotCurve\n Diagrammtypen gezeichnet. Wie im Beispiel oben wird eine Instanz einer solchen PlotCurve erstellt und dem Diagramm angehangen. Die Attribute einer \nQwtPlotCurve\n sind vielf\u00e4ltigt:\n\n\n\n\nCurveStyle\n - legt fest, wie die Datenpunkte gezeichnet werden sollen\n\n\nCurveAttribute\n- Zeichenattribute\n\n\nLegendAttribute\n - beinflusst die Darstellung der Legendensymbole\n\n\nPaintAttribute\n - Performance-bezogene Darstellungsoptionen\n\n\n\n\nSymbole (Marker) werden via \nQwtPlotCurve::setSymbol()\n hinzugef\u00fcgt.\n\n\nEntfernen von Kurven\n\n\nKurven k\u00f6nnen Diagrammen entnommen oder nur ausgeblendet werden:\n\n\n\n\nmittels \ncurve-\ndetach()\n wird die Kurve dem Diagramm \nund\n der Legende entnommen (der Speicher der Kurve wird \nnicht\n freigegeben!),\n\n\nunsichtbar schalten mittels \ncurve-\nsetVisible(false)\n, oder\n\n\nalternativ Linientyp auf NoCurve und Symbol entfernen:\n\n\n\n\ncurve-\nsetStyle(QwtPlotCurve::NoCurve);\ncurve-\nsetSymbol(NULL);\n\n\n\n\nBei Variante (2) und (3) bleibt der Legendeneintrag aber bestehen. Da kann man dann aber immer noch den Legendeneintrag ausblenden:\n\n\n// das LegendenWidget, d.h. Legendeneintrag von der Legende holen\nQWidget* legendWidget = d_legend-\nlegendWidget(itemToInfo(plotCurve));\n// Standardm\u00e4\u00dfig ist das Widget des Legendeneintrags vom Typ QwtLegendLabel\nQwtLegendLabel* label = qobject_cast\nQwtLegendLabel*\n(legendWidget);\nlabel-\nsetVisible(true);\n\n\n\n\nFeststellen, ob eine Kurve hinzugef\u00fcgt ist\n\n\nQwtPlotCurve::plot()\n liefert einen Zeiger auf das Diagramm, dem die Kurve hinzugef\u00fcgt wurde, oder \nNULL\n, wenn die Kurven derzeit keinem Plot zugeordnet ist.\n\n\n\n\nBalkendiagramme\n\n\nBalkendiagramme zeigen Datenreihen als Balken, entweder horizontal oder vertikal. Dabei k\u00f6nnen die Balken groupiert oder aufeinandergestapelt angezeigt werden:\n\n\n\n\nDas Beispiel \nbarchart\n demonstriert die Erstellung:\n\n\n// zuerst ein PlotItem f\u00fcr Balkendiagramme erstellen\nQwtPlotMultiBarChart * d_barChartItem = new QwtPlotMultiBarChart( \nBar Chart \n );\n// die Breite der Balken soll automatische anhand der Achsenskalierung\n// und Widgetbreite bestimmt werden\nd_barChartItem-\nsetLayoutPolicy( QwtPlotMultiBarChart::AutoAdjustSamples );\n// man kann die Abst\u00e4nde zwischen den Balken konfigurieren\nd_barChartItem-\nsetSpacing( 20 );\nd_barChartItem-\nsetMargin( 3 );\n// und wie immer wir zuletzt das PlotItem dem Diagramm hinzugef\u00fcgt\nd_barChartItem-\nattach( this );\n\n\n\n\nEine Legende wird genau wie bei anderen Diagrammtypen hinzugef\u00fcgt (siehe auch \nLegenden\n). Es ist eventuell sinnvoll, die Legendenicongr\u00f6\u00dfe anzupassen. Da die Legendenicons vom jeweiligen Diagrammelement generiert werden (hier vom QwtPlotMultiBarChart), setzt man die Legendenicongr\u00f6\u00dfe auch dar\u00fcber:\n\n\nd_barChartItem-\nsetLegendIconSize( QSize( 10, 14 ) );\n\n\n\n\nDie Daten eines Balkendiagramms sind in Datenpunkte (engl. \nsamples\n) und Balken (engl. \nbars\n) organisiert.  Jeder Datenpunkt entspricht einem X-Achsenwert (bei vertikalen Balkendiagrammen) und f\u00fcr jeden Datenpunkt werden entsprechend viele Balken (nebeneinander/\u00fcbereinander) gezeichnet.\n\n\nDie Beschriftung auf der X-Achse (bzw. auf der Y-Achse bei horizontalen Balken) wird mit \nQwtPlotMultiBarChart::setTitles()\n gesetzt:\n\n\nQList\nQwtText\n titles;\ntitles \n \nFirst group\n;\ntitles \n \nSecond group\n;\ntitles \n \nThird group\n;\nd_barChartItem-\nsetBarTitles( titles );\n\n\n\n\nDas Erscheinungsbild der Balken definiert man durch Erstellen und Setzen von \nQwtColumnSymbol\n Objekten:\n\n\n// Balkenfarben definieren\nstatic const char *colors[] = { \nDarkOrchid\n, \nSteelBlue\n, \nGold\n };\nconst int numBars = 3;\n// F\u00fcr jeden Balken ein Symbol definieren\nfor ( int i = 0; i \n numBars; i++ )\n{\n    QwtColumnSymbol *symbol = new QwtColumnSymbol( QwtColumnSymbol::Box );\n    // Die Konfiguration ist \u00e4hnlich der regul\u00e4rer Widgets\n    symbol-\nsetLineWidth( 2 ); // Pixel-Dimension\n    symbol-\nsetFrameStyle( QwtColumnSymbol::Raised );\n    symbol-\nsetPalette( QPalette( colors[i] ) );\n\n    d_barChartItem-\nsetSymbol( i, symbol );\n}\n\n\n\n\nDie eigentlich Daten werden in einer Matrix definiert, welche zum Beispiel in einem Container \nQVector\n QVector\ndouble\n \n abgelegt werden k\u00f6nnen. Der erste Index ist die Nummer des \"Samples\" (der Gruppe), der zweite Index entspricht dem Balkenindex der jeweiligen Gruppe:\n\n\nint numSamples = 5; // 5 Gruppen\nQVector\n QVector\ndouble\n \n samples;\nfor ( int i = 0; i \n numSamples; i++ ) {\n    QVector\ndouble\n values(numBars);\n    // setzen der Werte\n    values[0] = barValue1;\n    values[1] = barValue2;\n    values[2] = barValue3;\n    // ...\n\n    // hinzuf\u00fcgen zur samples-Matrix\n    samples.append(values);\n}\n\n// Abschlie\u00dfend werden dem BarPlot die Daten \u00fcbergeben\nd_barChartItem-\nsetSamples( samples );\n\n\n\n\nEin derart erstelltes BarChart sieht zun\u00e4chst so aus:\n\n\n\nDie Samples sind standardm\u00e4\u00dfig ganzzahligen X-Koordinaten (0,1,2...) zugeordnet.\n\n\nDie Achsen werden ganz genauso wie bei anderen Diagrammtypen angepasst (siehe \nAchsen\n). \u00dcblicherweise werden bei Balkendiagrammen jedoch keine Ticks und Ticklabels angezeigt. Daher kann man diese ausstellen:\n\n\n// Zugriff auf das Zeichenobjekt f\u00fcr die Achsen holen\nQwtScaleDraw *scaleDraw1 = plot-\naxisScaleDraw( QwtPlot::xBottom );\n// Die Achsenlinie und die Ticks lassen sich individuell abschalten\nscaleDraw1-\nenableComponent( QwtScaleDraw::Backbone, false );\nscaleDraw1-\nenableComponent( QwtScaleDraw::Ticks, false );\n\n\n\n\n\n\nDie Balken jeder Gruppe werden zentriert um die zugeordnete Koordinate gezeichnet, wodurch effektiv eine Skale verwendet wird, die in den negativen Bereich geht. Wird die Zeichenfl\u00e4che auf die Koordinatenachse ausgerichtet, so werden die Balken am linken und rechten Rand abgeschnitten. F\u00fcr vertikale Balken l\u00e4sst sich das \u00fcber die folgenden Befehle ausschalten:\n\n\n// linksseitig nicht bei 0 abschneiden\nplotLayout()-\nsetAlignCanvasToScale( QwtPlot::yLeft, false );\n// rechtsseitig nicht beim Maximalwert der X-Achse aufh\u00f6ren\nplotLayout()-\nsetAlignCanvasToScale( QwtPlot::yRight, false );\n\n\n\n\nSpezielle Beschriftungen\n\n\nManchmal m\u00f6chte man die Balkengruppe besonders beschriften, wie in folgendem Beispiel:\n\n\n\nDieses ist mit Qwt 6.1.x und den eingebauten Eigenschaften so nicht m\u00f6glich. Kapitel \nBalkendiagramme mit Kategoriebeschriftungen\n beschreibt die Vorgehensweise, um mit eigens angepassten Klassen, diese Diagramme zu erstellen.\n\n\nBalken entfernen und wieder hinzuf\u00fcgen\n\n\nBalken k\u00f6nnen mittels \nQwtPlotMultiBarChart::setVisible()\n sichtbar oder unsichtbar geschaltet werden. Dabei bleibt jedoch der entsprechende Legendeneintrag in der Liste. M\u00f6chte man den Balken einschlie\u00dflich Legendenicon entfernen, so muss man das Balkendiagramm neu konfigurieren, d.h. neue Titel und neue Daten (mit passender Dimension des Samples-Matrix) setzen.\n\n\n\n\nTODO:\n eleganter Weg einzelne Balken auszublenden?\n\n\n\n\nSpektrogramme\n\n\n\n\nerste Anwendung der Re-Implementierungstechnik\n\n\nvalue() Berechnung\n\n\nspezielle Optimierungen\n\n\n\n\nVektorfelder\n\n\nab \n6.3.x_trunk\n\n\n\n\nEingangsdaten, Interpretation\n\n\nKonfiguration\n\n\n\n\nErscheinungsbild des Plots anpassen\n\n\nRahmen und Zeichenfl\u00e4che\n\n\nBeim QwtPlot k\u00f6nnen verschiedene Elemente angepasst werden. Nachfolgend ist ein QwtPlot zu sehen, welches in einem \u00e4u\u00dferen Widget (dunkelgray) eingebettet ist. Die hellgraue Fl\u00e4che ist das eigentliche \nQwtPlot\n:\n\n\n\n\nIm Screenshot sind die wichtigsten Attribute markiert:\n\n\n\n\nInnenabstand (siehe \nQWidget::setContentsMargins()\n)\n\n\nRahmen (haupts\u00e4chlich f\u00fcr den Druck wichtig)\n\n\nHintergrund des Plot-Widgets\n\n\nZeichenfl\u00e4che (engl. \nCanvas\n) (betrifft Hintergrundfarbe und Rahmen)\n\n\n\n\nFarbe und Rahmen des Plots\n\n\nDie Farbe des \u00e4u\u00dferen Bereichs des Plots wird \u00fcber die Paletteneigenschaft des \nQwtPlot\n kontrolliert. Standardm\u00e4\u00dfig wird der \u00e4u\u00dfere Rand des Plot-Widgets transparant gezeichnet, d.h. die Farbe des darunterliegenden Widgets ist sichtbar. Um eine eigene Farbe zu setzen, muss daher \nsetAutoFillBackground(true)\n aufgerufen werden:\n\n\nQPalette pal = plot.palette();\n// Die QPalette::Window Farbrolle definiert die Einf\u00e4rbung\n// des \u00e4u\u00dferen Plotbereichs\npal.setColor(QPalette::Window, QColor(196,196,220));\nplot-\nsetPalette(pal);\n// die Eigenschaft \nautoFillBackground\n muss daf\u00fcr eingeschaltet sein\nplot-\nsetAutoFillBackground(true);\n\n\n\n\n\n\n\n\nHinweis:\n In Abschnitt \nGradient als Plot-Hintergrund\n wird beschrieben, wie man einen Farbverlauf im Plothintergrund umsetzt, und diesen bei Gr\u00f6\u00dfen\u00e4nderung entsprechend anpasst.\n\n\n\n\nDer Rahmen wird wie bei einem normalen Widget angepasst:\n\n\nplot-\nsetFrameStyle(QFrame::Box | QFrame::Sunken);\n\n\n\n\nNormalerweise ist ein solcher Rahmen nicht notwendig f\u00fcr die Bildschirmdarstellung oder f\u00fcr das Einbetten des QwtPlot in eine Programmoberfl\u00e4che. Der Rahmen ist jedoch h\u00e4ufig beim \nExport/Druck\n des Widgets sinnvoll.\n\n\nZeichenfl\u00e4che\n\n\nDie Zeichenfl\u00e4che kann eingef\u00e4rbt werden:\n\n\nplot-\nsetCanvasBackground(Qt::darkGray);\n\n\n\n\n\n\nDer Randabstand zwischen Achsenbeschriftung und Titel zum Rand kann definiert werden:\n\n\nplot-\nsetContentsMargins(15,10,35,5);\n\n\n\n\n\n\nDie Rahmen um die Zeichenfl\u00e4che kann durch Anpassen des Zeichenfl\u00e4chenobjekts (\nQwtPlotCanvas\n) ver\u00e4ndert werden. \nQwtPlotCanvas\n ist von QFrame abgeleitet, wodurch es entsprechend angepasst werden kann. Es wird einfach neues Objekt erstellt, konfiguriert und dem Plot \u00fcbergeben (das QwtPlot wird neuer Besitzer des Zeichenfl\u00e4chenobjekts):\n\n\nQwtPlotCanvas * canvas = new QwtPlotCanvas(\nplot);\ncanvas-\nsetPalette(Qt::white);\ncanvas-\nsetFrameStyle(QFrame::Box | QFrame::Plain );\ncanvas-\nsetLineWidth(1);\nplot-\nsetCanvas(canvas);\n\n\n\n\n\n\nEinfacher geht es durch Setzen des Stylesheets f\u00fcr das Canvas-Widget (siehe Qt-Widgets Dokumentation, welche Attribute unterst\u00fctzt werden):\n\n\nplot-\ncanvas()-\nsetStyleSheet(\n    \nborder: 1px solid Black;\n\n    \nborder-radius: 15px;\n\n    \nbackground-color: qlineargradient( x1: 0, y1: 0, x2: 0, y2: 1,\n\n        \nstop: 0 LemonChiffon, stop: 1 PaleGoldenrod );\n\n);\n\n\n\n\n\n\nErweiterte Anpassungen\n\n\nWie das Layout der Achsen, Legende, Titel, Kopf- und Fu\u00dfzeile und die jeweiligen Abst\u00e4nde zus\u00e4tzlich angepasst werden k\u00f6nnen, ist in Kapitel \nDas Layout-System\n beschrieben.\n\n\nDiagrammelemente\n\n\nTitel, Kopf- und Fu\u00dfzeile\n\n\n\n\nwo sind die\n\n\nRichText-Unterst\u00fctzung (HTML Tags)\n\n\n\n\nKurven\n\n\n\n\nAttribute von Kurven\n\n\nErscheinungsbild und Wirkung von RenderHints\n\n\nZeichenreihenfolge (anpassen)\n\n\n\n\nLegenden\n\n\nGrunds\u00e4tzlich kann ein \nQwtPlot\n zwei Legenden haben, und diese sogar gleichzeitig:\n\n\n\n\neine au\u00dfenliegende Legende, und/oder\n\n\neine Legende innerhalb der Zeichenfl\u00e4che (\u00fcber oder unter den anderen Diagrammelementen)\n\n\n\n\nDie Eintr\u00e4ge der Legenden werden von den jeweiligen Diagrammtypen (Linen-, Balken-, Farbverlaufsdiagramme) beigesteuert und auch von diesen gezeichnet. Die Legende verwaltet nur deren Positionierung innerhalb der Legende.\n\n\nAu\u00dfenliegende Legenden\n\n\nEine au\u00dfenliegende Legende bedeutet, dass ein regul\u00e4res Widget die Legende h\u00e4lt und seitlich (oben, unten, links oder rechts) der Zeichenfl\u00e4che angeordnet ist.\n\n\nDieses Widget kann auch abseits des QwtPlot in einem anderen Teil des Layouts angeordnet werden. In diesem Fall spricht man von einer \nexternen Legende\n.\n\n\nDazu wird eine Instanz der Klasse \nQwtLegend\n erstellt und dem Diagramm hinzugef\u00fcgt:\n\n\nQwtLegend * d_legend = new QwtLegend;\ninsertLegend(d_legend, QwtPlot::RightLegend);\n\n\n\n\nDabei ist \nQwtLegend\n ein ganz regul\u00e4res Widget. Intern enthalten Sie ein dynamisches Rasterlayout (Klasse \nQwtDynGridLayout\n), welches die Legendeneintr\u00e4ge je nach verf\u00fcgbarem Platz mehrspaltig auslegt.\n\n\nMaximale Anzahl der Spalten in der Legende\n\n\nDie Anzahl der maximal zu verwendenden Spalten wird mittels \nQwtLegend::setMaxColumns( uint numColums )\n festgelegt. Ein Wert von 0 (Standard) definert keine Begrenzung. Das ist f\u00fcr Legenden unterhalb und oberhalb des Plots sinnvoll, da hier auch mitunter sehr viele Legendeneintr\u00e4ge nebeneinander gezeichnet werden sollen. Links- und rechtsseitig angeordnete Legenden haben aber \u00fcblicherweise nur eine Spalte:\n\n\n// links und rechtsseitige Legenden sollen nur eine Spalte verwenden\nd_legend-\nsetMaxColumns(1);\n\n\n\n\nPositionierung der Legende\n\n\nDie Positionierung der Legende wird beim Einf\u00fcgen der Legende festgelegt. \nQwtPlot::insertLegend()\n erwartet einen der vier m\u00f6glichen Parameter: \nQwtPlot::BottomLegend\n, \nQwtPlot::TopLegend\n, \nQwtPlot::RightLegend\n, \nQwtPlot::LeftLegend\n. Wird die Funktion \ninsertLegend()\n ein weiteres Mal aufgerufen, so wird zun\u00e4chst die alte Legende gel\u00f6scht (auch der Speicher wird freigegeben) und dann wird die neue Legende eingef\u00fcgt.\n\n\nLegende entfernen\n\n\nRuft man \nQwtPlot::insertLegend()\n mit einem NULL-Zeiger auf, so wird die bisherige Legende gel\u00f6scht, aber keine neue eingef\u00fcgt. Damit entfernt das Plot auch das Legendenwidget.\n\n\n\n\nHinweis\n: Der Abschnitt \nBesitz\u00fcbernahme von Objekten des Plots\n zeigt einen Trick, wie man z.B. eine Legende dem Plot tempor\u00e4r entnehmen kann und sp\u00e4ter wieder hinzuf\u00fcgen kann, ohne dass das Legendenobjekt neu im Speicher erstellt werden muss.\n\n\n\n\nAbst\u00e4nde zwischen Legendeneintr\u00e4gen\n\n\nBei einer au\u00dfenliegende Legende sind die eigentlichen Legendeneintr\u00e4ge selbst Widgets die in einem dynamischen GridLayout angeordnet sind. Das dynamische GridLayout steckt selbst in einer QScrollArea-Widget, weswegen die Legende bei zu wenig Platz mit Scrollbalken ausgestattet wird. Auf dieses QScrollArea-Widget kann man mittels \nQwtLegend::contentsWidget()\n zugreifen, und dar\u00fcber auf das dynamische GridLayout.\n\n\nWie bei anderen QLayout-Klassen lassen sich die Abst\u00e4nde zwischen den Widgets mit \nQLayout::setSpacing()\n anpassen. Interessant ist das vor allem bei \numschaltbaren/anklickbaren Legendeneintr\u00e4gen\n:\n\n\n// verkleinern der Abst\u00e4nde zwischen den Legendeneintr\u00e4gen\nd_legend-\ncontentsWidget()-\nlayout()-\nsetSpacing(1);\n\n\n\n\nSo lassen sich auch Legenden mit vielen Eintr\u00e4gen recht kompakt anzeigen:\n\n\n \n\n\nRahmen und farbiger Hintergrund bei der Legende\n\n\nDa QwtLegend-Objekte selber Widgets sind, l\u00e4sst sich das Erscheinungsbild entsprechend mit Qt-Standardmitteln anpassen, z.B. ein Rahmen setzen und die Hintergrundfarbe anpassen:\n\n\n// einfacher Rahmen\nd_legend-\nsetFrameStyle(QFrame::Box|QFrame::Sunken);\n// Hintergrundfarbe anpassen\nQPalette pal = d_legend-\npalette();\npal.setColor(QPalette::Window, backgroundColor);\nd_legend-\nsetPalette(pal);\n// Wichtig: Widget soll selbst den Hintergrund zeichnen\nd_legend-\nsetAutoFillBackground(true);\n\n\n\n\nGegen\u00fcber der Standardeinstellung (links) hebt sich die Legende dadurch optisch ab (rechts):\n\n\n \n\n\nTODO\n\n\n\n\nRatio Parameter\n\n\n\n\nLegendensymbole\n\n\nDie LegendIcons bzw. allgemein die Eintr\u00e4ge in der Legende werden vom jeweiligen PlotItem bzw. der Kurve generiert. Entsprechende Anpassungsfunktionen sind daher f\u00fcr die jeweiligen Diagrammtypklassen verf\u00fcgbar, d.h. in \nQwtPlotCurve\n, \nQwtPlotSpectrogram\n und \nQwtPlotMultiBarChart\n definiert.\n\n\nMan kann die Legendeneintr\u00e4ge auch komplett selbst zeichnen, wie im Kapitel \nEigene Legendeneintr\u00e4ge zeichnen\n beschrieben ist.\n\n\nDarstellung der Legendeneintr\u00e4ge bei Kurven: Linie, Rechteck oder Farbe?\n\n\n...\nQwtPlotCurve::setLegendAttribute()\n\n\nInnenliegende Legenden\n\n\n\n\nSkizze mit relevanten Abmessungen\n\n\nKonfiguration\n\n\nOffset (Version 6.1.x und 6.3.x_trunk)\n\n\n\n\nAchsen\n\n\n\n\nallgemeines zum Zusammenspiel zwischen ScaleDiv und ScaleDraw, wie werden diese von Achsen verwendet\n\n\nwoher erhalten Achsen die Werte\n\n\n\n\nSichtbarkeit der Achsen\n\n\nAchsen k\u00f6nnen individuell sichtbar oder versteckt geschaltet werden. Standardm\u00e4\u00dfig sind die xBottom-Achse und die yLeft-Achse sichtbar. Die Sichtbarkeit wird mit \nQwtPlot::enableAxis(axisID, on)\n umgeschaltet.\n\n\nAchsentitel\n\n\nAchsentitel werden mittels \nQwtPlot::setAxisTitle(int axisId, const QwtText \ntitle)\n gesetzt.\n\n\nAchsentitel invertieren/von rechts lesbar machen\n\n\nBei technischen Diagrammen ist es \u00fcblich, den Titel der rechten y-Achse von rechts lesbar zu zeichnen. Dies wird durch Setzen eines LayoutFlags des Achsenwidgets erreicht:\n\n\nplot-\naxisWidget(QwtPlot::yRight)-\nsetLayoutFlag(QwtScaleWidget::TitleInverted, false);\n\n\n\n\nAchsenbeschriftung (Zahlen/Datum/Zeit)\n\n\nDie Achsentitel k\u00f6nnen ferner rotiert und positioniert werden, wof\u00fcr die Funktionen\n\n\nvoid setAxisLabelAlignment( int axisId, Qt::Alignment );\nvoid setAxisLabelRotation( int axisId, double rotation );\n\n\n\n\nverwendet werden. Der Rotationswinkel wird hierbei in Grad angegeben. Je nach Rotation muss man den Abstand zwischen Label und Achse anpassen, bzw. die Ausrichtung (Alignment) ver\u00e4ndern.\n\n\nF\u00fcr die untere X-Achse sind folgende Einstellungen sinnvoll:\n\n\n// Senkrechte Beschriftung, von rechts lesbar\nplot-\nsetAxisLabelRotation(QwtPlot::xBottom, -90);\nplot-\nsetAxisLabelAlignment(QwtPlot::xBottom, Qt::AlignLeft | Qt::AlignVCenter);\n// 45\u00b0 Beschriftung\nplot-\nsetAxisLabelRotation(QwtPlot::xBottom, -45);\nplot-\nsetAxisLabelAlignment(QwtPlot::xBottom, Qt::AlignLeft | Qt::AlignBottom);\n\n\n\n\nLineare Achsen und deren Eigenschaften\n\n\n...\n\n\nLogarithmische Achsen und andere Transformationen\n\n\n...\nBeispiel: \nscaleengine\n\n\nDatums-/Zeit-Achsen\n\n\n\n\nWerte in ms (Epoche)\n\n\nFormatierung, Zoomstufen\n\n\n\n\n\n\nBereichsmarkierungen\n\n\nEin horizontales oder vertikales Band als Hervorherbung kann durch ein \nQwtPlotZoneItem\n erstellt werden:\n\n\nQwtPlotZoneItem* zone = new QwtPlotZoneItem();\nzone-\nsetPen( Qt::darkGray );\nzone-\nsetBrush( QColor( \n#834358\n ) );\n// Ausrichtung: vertikales oder horizontales Band\nzone-\nsetOrientation( Qt::Horizontal );\n// Der Bereich des Bandes in Koordinateneinheiten\nzone-\nsetInterval( 3.8, 5.7 );\n// Hinzuf\u00fcgen zum Diagramm\nzone-\nattach( this );\n\n\n\n\n\n\nZeichenreihenfolge\n\n\nAlle Elemente, die innerhalb der Zeichenfl\u00e4chte gezeichnet werden, sind von QwtPlotItem abgeleitet. Diese Klasse hat die Eigenschaft zValue, welche die Zeichenreihenfolge definiert. H\u00f6here Werte bedeuten\n\n\n\n\nwie kontrolliert man die Zeichenreihenfolge (zValues)\n\n\nStandardreihenfolge beim Zeichnen\n\n\n\n\n\n\nBasisdatentypen\n\n\nDie Qwt-Bibliothek bringt einige grundlegende Datentypen/Klassen mit, welche die Datentypen der Qt Bibliothek erweitert.\n\n\nQwtText\n\n\nDie Klasse \nQwtText\n ersetzt die \nQString\n Klasse und erlaubt die Definition von Texten, welche auf unterschiedliche Art und Weise interpretiert und damit gezeichnet werden k\u00f6nnen.\n\n\nMan kann mittels der \nQwtText\n Klasse unter anderem HTML-basierten RichText verwenden, z.B. f\u00fcr die Hoch- und Tiefstellung von Zahlen bei Einheiten:\n\n\n// Ein Achsentitel mit HTML-basierter Hochstellung\nQwtText axisTitle(tr(\nArea [m\nsup\n2\n/sup\n]\n), QwtText::RichText);\n\n\n\n\nNat\u00fcrlich k\u00f6nnen auf diese Weise auch beliebig in HTML formatierte Texte verwendet werden.\n\n\nQwtText\n wird bei allen Zugriffsfunktionen verwendet, bei dehnen eine Zeichenkette verlangt wird.\n\n\nTextEngine\n\n\nPaintAttributes and LayoutAttributes\n\n\nDatenhalteklassen\n\n\nQwtRasterData\n\n\nQwtIntervalSample\n\n\nQwtSetSample\n\n\nQwtOHLCSample\n\n\nQwtVectorSample (ab Qwt 6.3.x)", 
            "title": "Grundlagen"
        }, 
        {
            "location": "/basics/#kleine-einfuhrung-ins-qwtplot", 
            "text": "Ein paar kleinere Beispiele sollen zun\u00e4chst die grundlegende Funktionalit\u00e4t und Benutzung des  QwtPlot -Widgets zeigen.   Hinweis:  In den nachfolgenden Beispielen werden die in der Qwt-Bibliothek enthaltenen Klassen direkt verwendet und nur deren Attribute angepasst. Weiterf\u00fchrende Anpassungen durch Re-Implementierung von Funktionen in abgeleiteten Klassen werden im Kapitel  Anpassungen  beschrieben.", 
            "title": "Kleine Einf\u00fchrung ins QwtPlot"
        }, 
        {
            "location": "/basics/#ein-kurvendiagramm", 
            "text": "Beginnen wir mit einem einfachen X-Y-Diagramm welches eine Linie darstellt:  #include  QApplication \n#include  QwtPlot          // oder  qwt_plot.h \n#include  QwtPlotCurve     // oder  qwt_plot_curve.h \n\nint main( int argc, char **argv ) {\n    QApplication a( argc, argv );\n\n    // create plot as main widget\n    QwtPlot plot;\n    plot.setTitle(  Plot Demo  );\n    plot.setCanvasBackground( Qt::white );\n\n    // create a new curve to be shown in the plot and set some properties\n    QwtPlotCurve *curve = new QwtPlotCurve();\n    curve- setTitle(  Some Points  ); // will later be used in legend\n    curve- setPen( Qt::blue, 4 ), // color and thickness in pixels\n    curve- setRenderHint( QwtPlotItem::RenderAntialiased, true ); // use antialiasing\n\n    // data points\n    QPolygonF points;\n    points   QPointF( 0.0, 4.4 )   QPointF( 1.0, 3.0 )\n          QPointF( 2.0, 4.5 )   QPointF( 3.0, 6.8 )\n          QPointF( 4.0, 7.9 )   QPointF( 5.0, 7.1 );\n\n    // give some points to the curve\n    curve- setSamples( points );\n\n    // set the curve in the plot\n    curve- attach(  plot );\n\n    plot.resize( 600, 400 );\n    plot.show();\n\n    return a.exec();\n}  Dies ergibt ein (noch ziemlich langweiliges) Diagrammfenster:", 
            "title": "Ein Kurvendiagramm"
        }, 
        {
            "location": "/basics/#include-dateien", 
            "text": "Grunds\u00e4tzlich gibt es zwei unterschiedliche Varianten f\u00fcr Include-Dateinamen - entweder man verwendet die tats\u00e4chlichen Header-Dateinamen, also z.B.  #include  qwt_plot.h  f\u00fcr die Klasse  QwtPlot , oder man verwendet die klassenspezifischen Headerdateien  #include  QwtPlot  (das sind Verweise auf die eigentlichen Headerdateien, wie bei Qt5 \u00fcblich). Da manche Headerdateien die Deklarationen f\u00fcr verschiedene Qwt-Klassen enthalten, ist es h\u00e4ufig einfacher bei Kenntniss des Klassennames auch einfach die entsprechend gleichnamigen Headerdateien zu verwenden.   Hinweis:  In den nachfolgenden Beispielen werden die  neuen  Headerdateinamen (=Klassennamen) verwendet. In den Beispielen im  examples -Verzeichnis der Qwt-Bibliothek werden die eigentlichen Headerdateinamen eingebunden.", 
            "title": "Include-Dateien"
        }, 
        {
            "location": "/basics/#plot-widget-und-hintergrundfarbe-der-zeichenflache", 
            "text": "Im obigen Quelltext wird zun\u00e4chst das  QwtPlot  Widget erstellt und erh\u00e4lt einen Titel. Der   CanvasBackground  ist der Hintergrund der Zeichenfl\u00e4che. Der Befehl:  plot.setCanvasBackground( Qt::white );  legt nur die Hintergrundfarbe der eigentlichen Zeichenfl\u00e4che (engl.  Canvas ) fest (siehe auch  Erscheinungsbild des Plots anpassen ).", 
            "title": "Plot-Widget und Hintergrundfarbe der Zeichenfl\u00e4che"
        }, 
        {
            "location": "/basics/#kurve-als-zeichenobjekt-hinzufugen", 
            "text": "Als n\u00e4chstes wird ein Zeichenobjekt (engl.  PlotItem ) f\u00fcr eine Linie/Kurve erstellt und konfiguriert.  Es gibt viele verschiedene Arten von Zeichenobjekten. Alle haben gemeinsam, dass sie auf der Zeichenfl\u00e4che gezeichnet werden. Die Reihenfolge des Zeichnens ist dabei f\u00fcr die Sichtbarkeit der einzelnen Zeichenobjekte wichtig (dazu sp\u00e4ter mehr, siehe Abschnitt  Zeichenreihenfolge ).  Grunds\u00e4tzlich  werden alle Zeichenobjekte  auf dem Heap (im Hauptspeicher) erstellt  und sp\u00e4ter dem Plot \u00fcbereignet. Das passiert mit:  curve- attach(  plot );  wobei das Plot Besitzer des Zeichenobjekts (d.h. unserer Kurve) wird und sich sp\u00e4ter um das Speicheraufr\u00e4umen k\u00fcmmert.  Zu den sinnvoll anzupassenden Eigenschaften einer Kurve geh\u00f6ren die Farbe und die Linienst\u00e4rke, siehe  QwtPlotCurve::setPen() . Bei dicken Linien lohnt sich das Einschalten von Antialiasing f\u00fcr die Liniendarstellung.   Hinweis:  Das Setzen von Zeichenattributen via  setRenderHint()  wird von allen Zeichenobjekten unterst\u00fctzt. So kann man Eigenschaften wie Antialiasing individuell f\u00fcr verschiedene Zeichenobjekte setzen.   Die hinzugef\u00fcgte Kurve ist standardm\u00e4\u00dfig der unteren X-Achse und der linken Y-Achse zugeordnet, sodass die Daten der Kurve gleichzeitig zur automatischen Skalierung der Achsen verwendet werden.  Der Titel der Linie wird mittels  QwtPlotCurve::setTitle()  gesetzt und in der Legende verwendet, welche wir als n\u00e4chstes einf\u00fcgen (weitere Kurveneigenschaften werden sp\u00e4ter besprochen).", 
            "title": "Kurve als Zeichenobjekt hinzuf\u00fcgen"
        }, 
        {
            "location": "/basics/#legende-diagrammachsen-und-hauptgitterlinien", 
            "text": "", 
            "title": "Legende, Diagrammachsen und Hauptgitterlinien"
        }, 
        {
            "location": "/basics/#legende-hinzufugen", 
            "text": "Um eine Legende hinzuzuf\u00fcgen, braucht man lediglich eine Instanz der  QwtLegend -Klasse erstellen und im Plot einf\u00fcgen:  QwtLegend * legend = new QwtLegend();\nplot.insertLegend( legend , QwtPlot::BottomLegend);  Der dazugeh\u00f6riger Header wird mittels  #include  QwtLegend  eingebunden. Wie auch beim Zeichenobjekt (Kurve) wird das Plot Besitzer der Legende und verwaltet die Resource.   Hinweis:  Wird eine andere Legende gesetzt, so wird die alte zuerst gel\u00f6scht. Es ist daher nicht erlaubt, auf eine ersetzte Legende weiterhin zuzugreifen (um das zu umgehen, siehe auch  Besitz\u00fcbernahme von Objekten des Plots ).   Weitere Eigenschaften der Legende werden im Kapitel zur  Legendenformatierung  erl\u00e4utert.", 
            "title": "Legende hinzuf\u00fcgen"
        }, 
        {
            "location": "/basics/#diagrammachsen-konfigurieren", 
            "text": "Im Gegensatz zu Legende oder Kurven sind Achsen keine Zeichenobjekte sondern fest mit dem Diagramm verbunden. Die Sichtbarkeit der 4 Achsen (links, rechts, oben und unten) kann jedoch individuell festgelegt werden.  Achseneigenschaften legt man direkt \u00fcber Zugriffsfunktionen der  QwtPlot -Klasse fest, wie z.B. selbstgew\u00e4hlte min/max-Werte:  plot.setAxisScale( QwtPlot::yLeft, 0.0, 10.0 );  Die Achsen werden durch  QwtPlot::yLeft ,  QwtPlot::yRight ,  QwtPlot::xBottom  und  QwtPlot::xTop  identifiziert.", 
            "title": "Diagrammachsen konfigurieren"
        }, 
        {
            "location": "/basics/#gitterraster-einfugen", 
            "text": "Um in der Zeichenfl\u00e4che Gitterlinien zu zeichnen, f\u00fcgt man einfach ein entsprechendes Zeichenobjekt hinzu.  QwtPlotGrid *grid = new QwtPlotGrid();\ngrid- setMajorPen(QPen(Qt::DotLine));\ngrid- attach(  plot );  Wie schon bei der Legende wird die Instanz der Klasse  QwtPlotGrid  (einzubinden via  #include  QwtPlotGrid ) zun\u00e4chst im Hauptspeicher angelegt, konfiguriert (hier wird nur der QPen der Hauptgitterlinien ver\u00e4ndert) und schlie\u00dflich dem Plot hinzugef\u00fcgt.", 
            "title": "Gitterraster einf\u00fcgen"
        }, 
        {
            "location": "/basics/#liniensymbole-hinzufugen", 
            "text": "Als ein Beispiel etwas weiterf\u00fchrender Konfiguration der Linien ( QwtPlotCurve ) wird hier ein Liniensymbol hinzugef\u00fcgt. Diese Eigenschaft (konkret das Zeichnen des Symbols) ist wieder anpassungsf\u00e4hig ausgelegt und nicht fest in der Klasse  QwtPlotCurve  integriert.  F\u00fcr das Zeichnen von Symbolen existiert die Klasse  QwtSymbol , welche nicht direkt als Zeichenobjekt verwendet wird, sondern eine Hilfsimplementierung f\u00fcr verschiedene Anwendungszwecke darstellt. Liniensymbole werden folgenderma\u00dfen erstellt:  QwtSymbol *symbol = new QwtSymbol(\n    QwtSymbol::Ellipse,    // Form\n    QBrush( Qt::yellow ),  // F\u00fcllung\n    QPen( Qt::red, 2 ),    // Rand\n    QSize( 8, 8 ) );       // Gr\u00f6\u00dfe in Pixel\n\ncurve- setSymbol( symbol ); // Kurve wurde Besitzer  Mit diesen Anpassungen sieht das Diagramm schon besser aus (siehe auch Beispiel  examples/SimplePlot )", 
            "title": "Liniensymbole hinzuf\u00fcgen"
        }, 
        {
            "location": "/basics/#diagrammtypen", 
            "text": "allgemeines zu PlotItems/Curves", 
            "title": "Diagrammtypen"
        }, 
        {
            "location": "/basics/#liniendiagramme-und-punktwolken", 
            "text": "Liniendiagramme, Punktwolken oder sonstige X-Y-Datenreihen werden mittels  QwtPlotCurve  Diagrammtypen gezeichnet. Wie im Beispiel oben wird eine Instanz einer solchen PlotCurve erstellt und dem Diagramm angehangen. Die Attribute einer  QwtPlotCurve  sind vielf\u00e4ltigt:   CurveStyle  - legt fest, wie die Datenpunkte gezeichnet werden sollen  CurveAttribute - Zeichenattribute  LegendAttribute  - beinflusst die Darstellung der Legendensymbole  PaintAttribute  - Performance-bezogene Darstellungsoptionen   Symbole (Marker) werden via  QwtPlotCurve::setSymbol()  hinzugef\u00fcgt.", 
            "title": "Liniendiagramme und Punktwolken"
        }, 
        {
            "location": "/basics/#entfernen-von-kurven", 
            "text": "Kurven k\u00f6nnen Diagrammen entnommen oder nur ausgeblendet werden:   mittels  curve- detach()  wird die Kurve dem Diagramm  und  der Legende entnommen (der Speicher der Kurve wird  nicht  freigegeben!),  unsichtbar schalten mittels  curve- setVisible(false) , oder  alternativ Linientyp auf NoCurve und Symbol entfernen:   curve- setStyle(QwtPlotCurve::NoCurve);\ncurve- setSymbol(NULL);  Bei Variante (2) und (3) bleibt der Legendeneintrag aber bestehen. Da kann man dann aber immer noch den Legendeneintrag ausblenden:  // das LegendenWidget, d.h. Legendeneintrag von der Legende holen\nQWidget* legendWidget = d_legend- legendWidget(itemToInfo(plotCurve));\n// Standardm\u00e4\u00dfig ist das Widget des Legendeneintrags vom Typ QwtLegendLabel\nQwtLegendLabel* label = qobject_cast QwtLegendLabel* (legendWidget);\nlabel- setVisible(true);", 
            "title": "Entfernen von Kurven"
        }, 
        {
            "location": "/basics/#feststellen-ob-eine-kurve-hinzugefugt-ist", 
            "text": "QwtPlotCurve::plot()  liefert einen Zeiger auf das Diagramm, dem die Kurve hinzugef\u00fcgt wurde, oder  NULL , wenn die Kurven derzeit keinem Plot zugeordnet ist.", 
            "title": "Feststellen, ob eine Kurve hinzugef\u00fcgt ist"
        }, 
        {
            "location": "/basics/#balkendiagramme", 
            "text": "Balkendiagramme zeigen Datenreihen als Balken, entweder horizontal oder vertikal. Dabei k\u00f6nnen die Balken groupiert oder aufeinandergestapelt angezeigt werden:   Das Beispiel  barchart  demonstriert die Erstellung:  // zuerst ein PlotItem f\u00fcr Balkendiagramme erstellen\nQwtPlotMultiBarChart * d_barChartItem = new QwtPlotMultiBarChart(  Bar Chart   );\n// die Breite der Balken soll automatische anhand der Achsenskalierung\n// und Widgetbreite bestimmt werden\nd_barChartItem- setLayoutPolicy( QwtPlotMultiBarChart::AutoAdjustSamples );\n// man kann die Abst\u00e4nde zwischen den Balken konfigurieren\nd_barChartItem- setSpacing( 20 );\nd_barChartItem- setMargin( 3 );\n// und wie immer wir zuletzt das PlotItem dem Diagramm hinzugef\u00fcgt\nd_barChartItem- attach( this );  Eine Legende wird genau wie bei anderen Diagrammtypen hinzugef\u00fcgt (siehe auch  Legenden ). Es ist eventuell sinnvoll, die Legendenicongr\u00f6\u00dfe anzupassen. Da die Legendenicons vom jeweiligen Diagrammelement generiert werden (hier vom QwtPlotMultiBarChart), setzt man die Legendenicongr\u00f6\u00dfe auch dar\u00fcber:  d_barChartItem- setLegendIconSize( QSize( 10, 14 ) );  Die Daten eines Balkendiagramms sind in Datenpunkte (engl.  samples ) und Balken (engl.  bars ) organisiert.  Jeder Datenpunkt entspricht einem X-Achsenwert (bei vertikalen Balkendiagrammen) und f\u00fcr jeden Datenpunkt werden entsprechend viele Balken (nebeneinander/\u00fcbereinander) gezeichnet.  Die Beschriftung auf der X-Achse (bzw. auf der Y-Achse bei horizontalen Balken) wird mit  QwtPlotMultiBarChart::setTitles()  gesetzt:  QList QwtText  titles;\ntitles    First group ;\ntitles    Second group ;\ntitles    Third group ;\nd_barChartItem- setBarTitles( titles );  Das Erscheinungsbild der Balken definiert man durch Erstellen und Setzen von  QwtColumnSymbol  Objekten:  // Balkenfarben definieren\nstatic const char *colors[] = {  DarkOrchid ,  SteelBlue ,  Gold  };\nconst int numBars = 3;\n// F\u00fcr jeden Balken ein Symbol definieren\nfor ( int i = 0; i   numBars; i++ )\n{\n    QwtColumnSymbol *symbol = new QwtColumnSymbol( QwtColumnSymbol::Box );\n    // Die Konfiguration ist \u00e4hnlich der regul\u00e4rer Widgets\n    symbol- setLineWidth( 2 ); // Pixel-Dimension\n    symbol- setFrameStyle( QwtColumnSymbol::Raised );\n    symbol- setPalette( QPalette( colors[i] ) );\n\n    d_barChartItem- setSymbol( i, symbol );\n}  Die eigentlich Daten werden in einer Matrix definiert, welche zum Beispiel in einem Container  QVector  QVector double    abgelegt werden k\u00f6nnen. Der erste Index ist die Nummer des \"Samples\" (der Gruppe), der zweite Index entspricht dem Balkenindex der jeweiligen Gruppe:  int numSamples = 5; // 5 Gruppen\nQVector  QVector double    samples;\nfor ( int i = 0; i   numSamples; i++ ) {\n    QVector double  values(numBars);\n    // setzen der Werte\n    values[0] = barValue1;\n    values[1] = barValue2;\n    values[2] = barValue3;\n    // ...\n\n    // hinzuf\u00fcgen zur samples-Matrix\n    samples.append(values);\n}\n\n// Abschlie\u00dfend werden dem BarPlot die Daten \u00fcbergeben\nd_barChartItem- setSamples( samples );  Ein derart erstelltes BarChart sieht zun\u00e4chst so aus:  Die Samples sind standardm\u00e4\u00dfig ganzzahligen X-Koordinaten (0,1,2...) zugeordnet.  Die Achsen werden ganz genauso wie bei anderen Diagrammtypen angepasst (siehe  Achsen ). \u00dcblicherweise werden bei Balkendiagrammen jedoch keine Ticks und Ticklabels angezeigt. Daher kann man diese ausstellen:  // Zugriff auf das Zeichenobjekt f\u00fcr die Achsen holen\nQwtScaleDraw *scaleDraw1 = plot- axisScaleDraw( QwtPlot::xBottom );\n// Die Achsenlinie und die Ticks lassen sich individuell abschalten\nscaleDraw1- enableComponent( QwtScaleDraw::Backbone, false );\nscaleDraw1- enableComponent( QwtScaleDraw::Ticks, false );   Die Balken jeder Gruppe werden zentriert um die zugeordnete Koordinate gezeichnet, wodurch effektiv eine Skale verwendet wird, die in den negativen Bereich geht. Wird die Zeichenfl\u00e4che auf die Koordinatenachse ausgerichtet, so werden die Balken am linken und rechten Rand abgeschnitten. F\u00fcr vertikale Balken l\u00e4sst sich das \u00fcber die folgenden Befehle ausschalten:  // linksseitig nicht bei 0 abschneiden\nplotLayout()- setAlignCanvasToScale( QwtPlot::yLeft, false );\n// rechtsseitig nicht beim Maximalwert der X-Achse aufh\u00f6ren\nplotLayout()- setAlignCanvasToScale( QwtPlot::yRight, false );", 
            "title": "Balkendiagramme"
        }, 
        {
            "location": "/basics/#spezielle-beschriftungen", 
            "text": "Manchmal m\u00f6chte man die Balkengruppe besonders beschriften, wie in folgendem Beispiel:  Dieses ist mit Qwt 6.1.x und den eingebauten Eigenschaften so nicht m\u00f6glich. Kapitel  Balkendiagramme mit Kategoriebeschriftungen  beschreibt die Vorgehensweise, um mit eigens angepassten Klassen, diese Diagramme zu erstellen.", 
            "title": "Spezielle Beschriftungen"
        }, 
        {
            "location": "/basics/#balken-entfernen-und-wieder-hinzufugen", 
            "text": "Balken k\u00f6nnen mittels  QwtPlotMultiBarChart::setVisible()  sichtbar oder unsichtbar geschaltet werden. Dabei bleibt jedoch der entsprechende Legendeneintrag in der Liste. M\u00f6chte man den Balken einschlie\u00dflich Legendenicon entfernen, so muss man das Balkendiagramm neu konfigurieren, d.h. neue Titel und neue Daten (mit passender Dimension des Samples-Matrix) setzen.   TODO:  eleganter Weg einzelne Balken auszublenden?", 
            "title": "Balken entfernen und wieder hinzuf\u00fcgen"
        }, 
        {
            "location": "/basics/#spektrogramme", 
            "text": "erste Anwendung der Re-Implementierungstechnik  value() Berechnung  spezielle Optimierungen", 
            "title": "Spektrogramme"
        }, 
        {
            "location": "/basics/#vektorfelder", 
            "text": "ab  6.3.x_trunk   Eingangsdaten, Interpretation  Konfiguration", 
            "title": "Vektorfelder"
        }, 
        {
            "location": "/basics/#erscheinungsbild-des-plots-anpassen", 
            "text": "", 
            "title": "Erscheinungsbild des Plots anpassen"
        }, 
        {
            "location": "/basics/#rahmen-und-zeichenflache", 
            "text": "Beim QwtPlot k\u00f6nnen verschiedene Elemente angepasst werden. Nachfolgend ist ein QwtPlot zu sehen, welches in einem \u00e4u\u00dferen Widget (dunkelgray) eingebettet ist. Die hellgraue Fl\u00e4che ist das eigentliche  QwtPlot :   Im Screenshot sind die wichtigsten Attribute markiert:   Innenabstand (siehe  QWidget::setContentsMargins() )  Rahmen (haupts\u00e4chlich f\u00fcr den Druck wichtig)  Hintergrund des Plot-Widgets  Zeichenfl\u00e4che (engl.  Canvas ) (betrifft Hintergrundfarbe und Rahmen)", 
            "title": "Rahmen und Zeichenfl\u00e4che"
        }, 
        {
            "location": "/basics/#farbe-und-rahmen-des-plots", 
            "text": "Die Farbe des \u00e4u\u00dferen Bereichs des Plots wird \u00fcber die Paletteneigenschaft des  QwtPlot  kontrolliert. Standardm\u00e4\u00dfig wird der \u00e4u\u00dfere Rand des Plot-Widgets transparant gezeichnet, d.h. die Farbe des darunterliegenden Widgets ist sichtbar. Um eine eigene Farbe zu setzen, muss daher  setAutoFillBackground(true)  aufgerufen werden:  QPalette pal = plot.palette();\n// Die QPalette::Window Farbrolle definiert die Einf\u00e4rbung\n// des \u00e4u\u00dferen Plotbereichs\npal.setColor(QPalette::Window, QColor(196,196,220));\nplot- setPalette(pal);\n// die Eigenschaft  autoFillBackground  muss daf\u00fcr eingeschaltet sein\nplot- setAutoFillBackground(true);    Hinweis:  In Abschnitt  Gradient als Plot-Hintergrund  wird beschrieben, wie man einen Farbverlauf im Plothintergrund umsetzt, und diesen bei Gr\u00f6\u00dfen\u00e4nderung entsprechend anpasst.   Der Rahmen wird wie bei einem normalen Widget angepasst:  plot- setFrameStyle(QFrame::Box | QFrame::Sunken);  Normalerweise ist ein solcher Rahmen nicht notwendig f\u00fcr die Bildschirmdarstellung oder f\u00fcr das Einbetten des QwtPlot in eine Programmoberfl\u00e4che. Der Rahmen ist jedoch h\u00e4ufig beim  Export/Druck  des Widgets sinnvoll.", 
            "title": "Farbe und Rahmen des Plots"
        }, 
        {
            "location": "/basics/#zeichenflache", 
            "text": "Die Zeichenfl\u00e4che kann eingef\u00e4rbt werden:  plot- setCanvasBackground(Qt::darkGray);   Der Randabstand zwischen Achsenbeschriftung und Titel zum Rand kann definiert werden:  plot- setContentsMargins(15,10,35,5);   Die Rahmen um die Zeichenfl\u00e4che kann durch Anpassen des Zeichenfl\u00e4chenobjekts ( QwtPlotCanvas ) ver\u00e4ndert werden.  QwtPlotCanvas  ist von QFrame abgeleitet, wodurch es entsprechend angepasst werden kann. Es wird einfach neues Objekt erstellt, konfiguriert und dem Plot \u00fcbergeben (das QwtPlot wird neuer Besitzer des Zeichenfl\u00e4chenobjekts):  QwtPlotCanvas * canvas = new QwtPlotCanvas( plot);\ncanvas- setPalette(Qt::white);\ncanvas- setFrameStyle(QFrame::Box | QFrame::Plain );\ncanvas- setLineWidth(1);\nplot- setCanvas(canvas);   Einfacher geht es durch Setzen des Stylesheets f\u00fcr das Canvas-Widget (siehe Qt-Widgets Dokumentation, welche Attribute unterst\u00fctzt werden):  plot- canvas()- setStyleSheet(\n     border: 1px solid Black; \n     border-radius: 15px; \n     background-color: qlineargradient( x1: 0, y1: 0, x2: 0, y2: 1, \n         stop: 0 LemonChiffon, stop: 1 PaleGoldenrod ); \n);", 
            "title": "Zeichenfl\u00e4che"
        }, 
        {
            "location": "/basics/#erweiterte-anpassungen", 
            "text": "Wie das Layout der Achsen, Legende, Titel, Kopf- und Fu\u00dfzeile und die jeweiligen Abst\u00e4nde zus\u00e4tzlich angepasst werden k\u00f6nnen, ist in Kapitel  Das Layout-System  beschrieben.", 
            "title": "Erweiterte Anpassungen"
        }, 
        {
            "location": "/basics/#diagrammelemente", 
            "text": "", 
            "title": "Diagrammelemente"
        }, 
        {
            "location": "/basics/#titel-kopf-und-fuzeile", 
            "text": "wo sind die  RichText-Unterst\u00fctzung (HTML Tags)", 
            "title": "Titel, Kopf- und Fu\u00dfzeile"
        }, 
        {
            "location": "/basics/#kurven", 
            "text": "Attribute von Kurven  Erscheinungsbild und Wirkung von RenderHints  Zeichenreihenfolge (anpassen)", 
            "title": "Kurven"
        }, 
        {
            "location": "/basics/#legenden", 
            "text": "Grunds\u00e4tzlich kann ein  QwtPlot  zwei Legenden haben, und diese sogar gleichzeitig:   eine au\u00dfenliegende Legende, und/oder  eine Legende innerhalb der Zeichenfl\u00e4che (\u00fcber oder unter den anderen Diagrammelementen)   Die Eintr\u00e4ge der Legenden werden von den jeweiligen Diagrammtypen (Linen-, Balken-, Farbverlaufsdiagramme) beigesteuert und auch von diesen gezeichnet. Die Legende verwaltet nur deren Positionierung innerhalb der Legende.", 
            "title": "Legenden"
        }, 
        {
            "location": "/basics/#auenliegende-legenden", 
            "text": "Eine au\u00dfenliegende Legende bedeutet, dass ein regul\u00e4res Widget die Legende h\u00e4lt und seitlich (oben, unten, links oder rechts) der Zeichenfl\u00e4che angeordnet ist.  Dieses Widget kann auch abseits des QwtPlot in einem anderen Teil des Layouts angeordnet werden. In diesem Fall spricht man von einer  externen Legende .  Dazu wird eine Instanz der Klasse  QwtLegend  erstellt und dem Diagramm hinzugef\u00fcgt:  QwtLegend * d_legend = new QwtLegend;\ninsertLegend(d_legend, QwtPlot::RightLegend);  Dabei ist  QwtLegend  ein ganz regul\u00e4res Widget. Intern enthalten Sie ein dynamisches Rasterlayout (Klasse  QwtDynGridLayout ), welches die Legendeneintr\u00e4ge je nach verf\u00fcgbarem Platz mehrspaltig auslegt.", 
            "title": "Au\u00dfenliegende Legenden"
        }, 
        {
            "location": "/basics/#maximale-anzahl-der-spalten-in-der-legende", 
            "text": "Die Anzahl der maximal zu verwendenden Spalten wird mittels  QwtLegend::setMaxColumns( uint numColums )  festgelegt. Ein Wert von 0 (Standard) definert keine Begrenzung. Das ist f\u00fcr Legenden unterhalb und oberhalb des Plots sinnvoll, da hier auch mitunter sehr viele Legendeneintr\u00e4ge nebeneinander gezeichnet werden sollen. Links- und rechtsseitig angeordnete Legenden haben aber \u00fcblicherweise nur eine Spalte:  // links und rechtsseitige Legenden sollen nur eine Spalte verwenden\nd_legend- setMaxColumns(1);", 
            "title": "Maximale Anzahl der Spalten in der Legende"
        }, 
        {
            "location": "/basics/#positionierung-der-legende", 
            "text": "Die Positionierung der Legende wird beim Einf\u00fcgen der Legende festgelegt.  QwtPlot::insertLegend()  erwartet einen der vier m\u00f6glichen Parameter:  QwtPlot::BottomLegend ,  QwtPlot::TopLegend ,  QwtPlot::RightLegend ,  QwtPlot::LeftLegend . Wird die Funktion  insertLegend()  ein weiteres Mal aufgerufen, so wird zun\u00e4chst die alte Legende gel\u00f6scht (auch der Speicher wird freigegeben) und dann wird die neue Legende eingef\u00fcgt.", 
            "title": "Positionierung der Legende"
        }, 
        {
            "location": "/basics/#legende-entfernen", 
            "text": "Ruft man  QwtPlot::insertLegend()  mit einem NULL-Zeiger auf, so wird die bisherige Legende gel\u00f6scht, aber keine neue eingef\u00fcgt. Damit entfernt das Plot auch das Legendenwidget.   Hinweis : Der Abschnitt  Besitz\u00fcbernahme von Objekten des Plots  zeigt einen Trick, wie man z.B. eine Legende dem Plot tempor\u00e4r entnehmen kann und sp\u00e4ter wieder hinzuf\u00fcgen kann, ohne dass das Legendenobjekt neu im Speicher erstellt werden muss.", 
            "title": "Legende entfernen"
        }, 
        {
            "location": "/basics/#abstande-zwischen-legendeneintragen", 
            "text": "Bei einer au\u00dfenliegende Legende sind die eigentlichen Legendeneintr\u00e4ge selbst Widgets die in einem dynamischen GridLayout angeordnet sind. Das dynamische GridLayout steckt selbst in einer QScrollArea-Widget, weswegen die Legende bei zu wenig Platz mit Scrollbalken ausgestattet wird. Auf dieses QScrollArea-Widget kann man mittels  QwtLegend::contentsWidget()  zugreifen, und dar\u00fcber auf das dynamische GridLayout.  Wie bei anderen QLayout-Klassen lassen sich die Abst\u00e4nde zwischen den Widgets mit  QLayout::setSpacing()  anpassen. Interessant ist das vor allem bei  umschaltbaren/anklickbaren Legendeneintr\u00e4gen :  // verkleinern der Abst\u00e4nde zwischen den Legendeneintr\u00e4gen\nd_legend- contentsWidget()- layout()- setSpacing(1);  So lassen sich auch Legenden mit vielen Eintr\u00e4gen recht kompakt anzeigen:", 
            "title": "Abst\u00e4nde zwischen Legendeneintr\u00e4gen"
        }, 
        {
            "location": "/basics/#rahmen-und-farbiger-hintergrund-bei-der-legende", 
            "text": "Da QwtLegend-Objekte selber Widgets sind, l\u00e4sst sich das Erscheinungsbild entsprechend mit Qt-Standardmitteln anpassen, z.B. ein Rahmen setzen und die Hintergrundfarbe anpassen:  // einfacher Rahmen\nd_legend- setFrameStyle(QFrame::Box|QFrame::Sunken);\n// Hintergrundfarbe anpassen\nQPalette pal = d_legend- palette();\npal.setColor(QPalette::Window, backgroundColor);\nd_legend- setPalette(pal);\n// Wichtig: Widget soll selbst den Hintergrund zeichnen\nd_legend- setAutoFillBackground(true);  Gegen\u00fcber der Standardeinstellung (links) hebt sich die Legende dadurch optisch ab (rechts):", 
            "title": "Rahmen und farbiger Hintergrund bei der Legende"
        }, 
        {
            "location": "/basics/#todo", 
            "text": "Ratio Parameter", 
            "title": "TODO"
        }, 
        {
            "location": "/basics/#legendensymbole", 
            "text": "Die LegendIcons bzw. allgemein die Eintr\u00e4ge in der Legende werden vom jeweiligen PlotItem bzw. der Kurve generiert. Entsprechende Anpassungsfunktionen sind daher f\u00fcr die jeweiligen Diagrammtypklassen verf\u00fcgbar, d.h. in  QwtPlotCurve ,  QwtPlotSpectrogram  und  QwtPlotMultiBarChart  definiert.  Man kann die Legendeneintr\u00e4ge auch komplett selbst zeichnen, wie im Kapitel  Eigene Legendeneintr\u00e4ge zeichnen  beschrieben ist.", 
            "title": "Legendensymbole"
        }, 
        {
            "location": "/basics/#darstellung-der-legendeneintrage-bei-kurven-linie-rechteck-oder-farbe", 
            "text": "... QwtPlotCurve::setLegendAttribute()", 
            "title": "Darstellung der Legendeneintr\u00e4ge bei Kurven: Linie, Rechteck oder Farbe?"
        }, 
        {
            "location": "/basics/#innenliegende-legenden", 
            "text": "Skizze mit relevanten Abmessungen  Konfiguration  Offset (Version 6.1.x und 6.3.x_trunk)", 
            "title": "Innenliegende Legenden"
        }, 
        {
            "location": "/basics/#achsen", 
            "text": "allgemeines zum Zusammenspiel zwischen ScaleDiv und ScaleDraw, wie werden diese von Achsen verwendet  woher erhalten Achsen die Werte", 
            "title": "Achsen"
        }, 
        {
            "location": "/basics/#sichtbarkeit-der-achsen", 
            "text": "Achsen k\u00f6nnen individuell sichtbar oder versteckt geschaltet werden. Standardm\u00e4\u00dfig sind die xBottom-Achse und die yLeft-Achse sichtbar. Die Sichtbarkeit wird mit  QwtPlot::enableAxis(axisID, on)  umgeschaltet.", 
            "title": "Sichtbarkeit der Achsen"
        }, 
        {
            "location": "/basics/#achsentitel", 
            "text": "Achsentitel werden mittels  QwtPlot::setAxisTitle(int axisId, const QwtText  title)  gesetzt.", 
            "title": "Achsentitel"
        }, 
        {
            "location": "/basics/#achsentitel-invertierenvon-rechts-lesbar-machen", 
            "text": "Bei technischen Diagrammen ist es \u00fcblich, den Titel der rechten y-Achse von rechts lesbar zu zeichnen. Dies wird durch Setzen eines LayoutFlags des Achsenwidgets erreicht:  plot- axisWidget(QwtPlot::yRight)- setLayoutFlag(QwtScaleWidget::TitleInverted, false);", 
            "title": "Achsentitel invertieren/von rechts lesbar machen"
        }, 
        {
            "location": "/basics/#achsenbeschriftung-zahlendatumzeit", 
            "text": "Die Achsentitel k\u00f6nnen ferner rotiert und positioniert werden, wof\u00fcr die Funktionen  void setAxisLabelAlignment( int axisId, Qt::Alignment );\nvoid setAxisLabelRotation( int axisId, double rotation );  verwendet werden. Der Rotationswinkel wird hierbei in Grad angegeben. Je nach Rotation muss man den Abstand zwischen Label und Achse anpassen, bzw. die Ausrichtung (Alignment) ver\u00e4ndern.  F\u00fcr die untere X-Achse sind folgende Einstellungen sinnvoll:  // Senkrechte Beschriftung, von rechts lesbar\nplot- setAxisLabelRotation(QwtPlot::xBottom, -90);\nplot- setAxisLabelAlignment(QwtPlot::xBottom, Qt::AlignLeft | Qt::AlignVCenter);\n// 45\u00b0 Beschriftung\nplot- setAxisLabelRotation(QwtPlot::xBottom, -45);\nplot- setAxisLabelAlignment(QwtPlot::xBottom, Qt::AlignLeft | Qt::AlignBottom);", 
            "title": "Achsenbeschriftung (Zahlen/Datum/Zeit)"
        }, 
        {
            "location": "/basics/#lineare-achsen-und-deren-eigenschaften", 
            "text": "...", 
            "title": "Lineare Achsen und deren Eigenschaften"
        }, 
        {
            "location": "/basics/#logarithmische-achsen-und-andere-transformationen", 
            "text": "...\nBeispiel:  scaleengine", 
            "title": "Logarithmische Achsen und andere Transformationen"
        }, 
        {
            "location": "/basics/#datums-zeit-achsen", 
            "text": "Werte in ms (Epoche)  Formatierung, Zoomstufen", 
            "title": "Datums-/Zeit-Achsen"
        }, 
        {
            "location": "/basics/#bereichsmarkierungen", 
            "text": "Ein horizontales oder vertikales Band als Hervorherbung kann durch ein  QwtPlotZoneItem  erstellt werden:  QwtPlotZoneItem* zone = new QwtPlotZoneItem();\nzone- setPen( Qt::darkGray );\nzone- setBrush( QColor(  #834358  ) );\n// Ausrichtung: vertikales oder horizontales Band\nzone- setOrientation( Qt::Horizontal );\n// Der Bereich des Bandes in Koordinateneinheiten\nzone- setInterval( 3.8, 5.7 );\n// Hinzuf\u00fcgen zum Diagramm\nzone- attach( this );", 
            "title": "Bereichsmarkierungen"
        }, 
        {
            "location": "/basics/#zeichenreihenfolge", 
            "text": "Alle Elemente, die innerhalb der Zeichenfl\u00e4chte gezeichnet werden, sind von QwtPlotItem abgeleitet. Diese Klasse hat die Eigenschaft zValue, welche die Zeichenreihenfolge definiert. H\u00f6here Werte bedeuten   wie kontrolliert man die Zeichenreihenfolge (zValues)  Standardreihenfolge beim Zeichnen", 
            "title": "Zeichenreihenfolge"
        }, 
        {
            "location": "/basics/#basisdatentypen", 
            "text": "Die Qwt-Bibliothek bringt einige grundlegende Datentypen/Klassen mit, welche die Datentypen der Qt Bibliothek erweitert.", 
            "title": "Basisdatentypen"
        }, 
        {
            "location": "/basics/#qwttext", 
            "text": "Die Klasse  QwtText  ersetzt die  QString  Klasse und erlaubt die Definition von Texten, welche auf unterschiedliche Art und Weise interpretiert und damit gezeichnet werden k\u00f6nnen.  Man kann mittels der  QwtText  Klasse unter anderem HTML-basierten RichText verwenden, z.B. f\u00fcr die Hoch- und Tiefstellung von Zahlen bei Einheiten:  // Ein Achsentitel mit HTML-basierter Hochstellung\nQwtText axisTitle(tr( Area [m sup 2 /sup ] ), QwtText::RichText);  Nat\u00fcrlich k\u00f6nnen auf diese Weise auch beliebig in HTML formatierte Texte verwendet werden.  QwtText  wird bei allen Zugriffsfunktionen verwendet, bei dehnen eine Zeichenkette verlangt wird.", 
            "title": "QwtText"
        }, 
        {
            "location": "/basics/#textengine", 
            "text": "", 
            "title": "TextEngine"
        }, 
        {
            "location": "/basics/#paintattributes-and-layoutattributes", 
            "text": "", 
            "title": "PaintAttributes and LayoutAttributes"
        }, 
        {
            "location": "/basics/#datenhalteklassen", 
            "text": "", 
            "title": "Datenhalteklassen"
        }, 
        {
            "location": "/basics/#qwtrasterdata", 
            "text": "", 
            "title": "QwtRasterData"
        }, 
        {
            "location": "/basics/#qwtintervalsample", 
            "text": "", 
            "title": "QwtIntervalSample"
        }, 
        {
            "location": "/basics/#qwtsetsample", 
            "text": "", 
            "title": "QwtSetSample"
        }, 
        {
            "location": "/basics/#qwtohlcsample", 
            "text": "", 
            "title": "QwtOHLCSample"
        }, 
        {
            "location": "/basics/#qwtvectorsample-ab-qwt-63x", 
            "text": "", 
            "title": "QwtVectorSample (ab Qwt 6.3.x)"
        }, 
        {
            "location": "/interaction/", 
            "text": "Benutzer-Interaktion mit dem Diagramm\n\n\nWenn ein Diagramm erstellt wurde, gibt es verschiedene M\u00f6glichkeiten f\u00fcr den Nutzer, mit dem Diagramm zu interagieren:\n\n\n\n\nWerte unter dem Mauskursor anzeigen\n\n\nWerte der n\u00e4chstgelegenen Kurve anzeigen\n\n\nZoomen und Verschieben der Plotansicht\n\n\nund weitere...\n\n\n\n\nUm das umzusetzen, k\u00f6nnte man das QwtPlot ableiten und die entsprechenden Maus- und Tastaturevents von Qt in den jeweiligen Event-Funktionen behandelt. Die Qwt-Bibliothek bringt aber ein paar vorbereitete Funktionen mit. Diese registrieren sich \u00fcber EventFilter beim Diagramm und fangen entsprechende Ereignisse (Mausklick, Mausbewegungen, Tastaturanschl\u00e4ge,... ) ab.\n\n\nDie Implementierung erfolgt in den \nInteraktionskomponenten\n stets \u00e4hnlich - das entsprechende Objekt wird erstellt und im Konstruktor \u00fcbergibt man die Zeichenfl\u00e4che (canvas) des gew\u00e4hlten \nQwtPlot\n. Damit kann die Interaktionskomponente den EventFilter installieren.\n\n\n\n\nHinweis:\n F\u00fcr die meisten Komponenten ist die Reihenfolge, in der die Events abgearbeitet werden, unwichtig. In manchen F\u00e4llen m\u00f6chte man jedoch Seiteneffekte vermeiden, d.h. eine Interaktionskomponente akzeptiert und verarbeitet das Ereignis und die nachgeordneten EventFilter erhalten das Ereignis gar nicht mehr. In diesem Fall muss man die Reihenfolge der Erstellung der Interaktionskomponenten beachten.\n\n\n\n\nDatenanzeige (Tracker)\n\n\nDie Basisklasse f\u00fcr Interaktionskomponenten ist die Klasse \nQwtPicker\n. Diese implementiert die Behandlung von Enter, Leave, Mouse und Keyboard-Ereignissen und transformiert diese in ausgew\u00e4hlte Punkte. Dabei gibt es verschiedene Zustandsautomaten, welche man nachnutzen kann.\n\n\nF\u00fcr die Anzeige von\nQwtPicker *picker = new QwtPicker(widget);\n\n\nDie Klasse QwtTracker\n\n\n\n\nwie funktioniert der Tracker\n\n\npunkt, vertikal, horizontal\n\n\n\n\nVerschieben der Plotfl\u00e4che\n\n\nDas Verschieben der aktuellen Ansichtsfl\u00e4che des Diagramms erfolgt mit dem \nQwtPlotPanner\n.\n\n\n// Erstelle Objekt, welches sich gleich bei der Zeichenfl\u00e4che des\n// Plot registriert\nd_panner = new QwtPlotPanner(plot-\ncanvas());\nd_panner-\nsetMouseButton(Qt::MidButton);\n\n\n\n\nKurvenverlauf abfahren (CurveTracker)\n\n\n\n\nwie funktioniert der Tracker\n\n\n\n\nZoomen/Plotausschnitt verschieben (Zooming/Panning):\n\n\n\n\nzoomer einstellungen\n\n\nzoom rect\n\n\n\n\nBasiszoomstufe einstellen\n\n\n\n\nzoom base einstellen (maximale rauszoomgr\u00f6\u00dfe)\n\n\n\n\nMehrere Achsen zoomen\n\n\n\n\nR\u00fccktransformation zeigen\n\n\n\n\nLegendeneintr\u00e4ge ein/ausschalten\n\n\nBei einer au\u00dfenliegenden Legende sind die standardm\u00e4\u00dfig erstellen Legendeneintr\u00e4ge einfache Label vom Typ \nQwtLegendLabel\n. Diesen k\u00f6nnen an- und ausgeschaltet werden (checked). Ein typischer Anwendungsfall ist das Sichtbar-/Versteckt-Schalten von Diagrammkurven/Balken, um einen Teil der Informationen zu verbergen.\n\n\nZun\u00e4chst muss die entsprechende Legendeneigenschaft eingeschaltet werden:\n\n\n// Legendeneintr\u00e4ge \ncheckbar\n machen\nd_legend-\nsetDefaultItemMode(QwtLegendData::Checkable);\n\n\n\n\nAuf Checked/Unchecked-Ereignisse reagieren\n\n\nDamit man auf das Umschalten der Legendeintr\u00e4ge reagieren kann, muss man eine Signal-Slot-Verbindung zwischen Signal \nQwtLegendLabel::checked(bool)\n und einer eigenen Funktion herstellen. Das zu einer Kurve geh\u00f6rige LegendLabel findet man \u00fcber die Funktion \nQwtLegend::legendWidget()\n (wobei das eigentlich das Widget eines einzelnen Legendeneintrags ist). Das kann man dann in ein Label casten und via mit der entsprechenden Funktion verkn\u00fcpfen:\n\n\n// das zu einer Kurve geh\u00f6rige LegendLabel findet man \u00fcber die Funktion QwtLegend::legendWidget()\n// 'plotCurve1' ist ein Zeiger zu einer hinzugef\u00fcgten QwtPlotCurve\nQWidget* legendWidget = d_legend-\nlegendWidget(itemToInfo(plotCurve1));\nQwtLegendLabel* label = qobject_cast\nQwtLegendLabel*\n(legendWidget);\n// das Signal verkn\u00fcpfen\nconnect(label, SIGNAL(checked(bool)),\n        this, SLOT(onCurveVisibilityChanged(bool)) );\n\n\n\n\n\n\nHinweis:\n Statt \nqobject_cast\nQwtLegendLabel*\n k\u00f6nnte man auch `dynamic_cast\n verwenden, ersteres ist aber schneller und daher besser bei QObject-abgeleiteten Klassentypen.\n\n\n\n\nSichtbar/Unsichtbar-Schalten von Linien/Kurven im Diagramm (QwtPlotCurve)\n\n\nDie Implementierung bei Liniendiagrammen sieht so aus:\n\n\nvoid MyPlot::onCurveVisibilityChanged (bool on) {\n    QObject * origin = sender();\n    // cast pointer to QwtLegendItem\n    QwtLegendLabel * item = qobject_cast\nQwtLegendLabel *\n(origin);\n    // check that is was a valid sender\n    if (item == NULL)\n        return; // invalid origin\n\n    // now find out which curve belongs to this legend item\n    for (unsigned int i=0; i\nNumCurves; ++i) {\n        if (m_curves[i] == NULL)\n            continue; // skip empty curves\n        QWidget* legendWidget = m_legend-\nlegendWidget(itemToInfo(m_curves[i]));\n        QwtLegendLabel* label = qobject_cast\nQwtLegendLabel*\n(legendWidget);\n        if (label == item) {\n            // set visibility of curve based on function argument\n            m_curves[i]-\nsetVisible(on);\n            replot();\n            break;\n        }\n    }\n}\n\n\n\n\nLegendeneintr\u00e4ge alternativ schalten\n\n\nImplement show curve function such:\n\n\nvoid CpuPlot::showCurve(QwtPlotItem *item, bool on)\n{\n    // wenn eine Curve angeschaltet werden soll, vorher alle anderen ausschalten\n    if (on) {\n        const QwtPlotItemList \nlist = this-\nitemList();\n        for (QwtPlotItemIterator it = list.begin();it!=list.end();++it) {\n            QwtPlotItem *item2 = *it;\n            if (item2-\nrtti() == QwtPlotItem::Rtti_PlotCurve)\n            item2-\nsetVisible(false);\n        }\n    }\n    item-\nsetVisible(on);\n    // Legendenwidget aktualisieren\n    QWidget *w = legend()-\nfind(item);\n    if ( w \n w-\ninherits(\nQwtLegendItem\n) )\n        ((QwtLegendItem *)w)-\nsetChecked(on);\n    replot();\n}", 
            "title": "Diagramm-Interaktion"
        }, 
        {
            "location": "/interaction/#benutzer-interaktion-mit-dem-diagramm", 
            "text": "Wenn ein Diagramm erstellt wurde, gibt es verschiedene M\u00f6glichkeiten f\u00fcr den Nutzer, mit dem Diagramm zu interagieren:   Werte unter dem Mauskursor anzeigen  Werte der n\u00e4chstgelegenen Kurve anzeigen  Zoomen und Verschieben der Plotansicht  und weitere...   Um das umzusetzen, k\u00f6nnte man das QwtPlot ableiten und die entsprechenden Maus- und Tastaturevents von Qt in den jeweiligen Event-Funktionen behandelt. Die Qwt-Bibliothek bringt aber ein paar vorbereitete Funktionen mit. Diese registrieren sich \u00fcber EventFilter beim Diagramm und fangen entsprechende Ereignisse (Mausklick, Mausbewegungen, Tastaturanschl\u00e4ge,... ) ab.  Die Implementierung erfolgt in den  Interaktionskomponenten  stets \u00e4hnlich - das entsprechende Objekt wird erstellt und im Konstruktor \u00fcbergibt man die Zeichenfl\u00e4che (canvas) des gew\u00e4hlten  QwtPlot . Damit kann die Interaktionskomponente den EventFilter installieren.   Hinweis:  F\u00fcr die meisten Komponenten ist die Reihenfolge, in der die Events abgearbeitet werden, unwichtig. In manchen F\u00e4llen m\u00f6chte man jedoch Seiteneffekte vermeiden, d.h. eine Interaktionskomponente akzeptiert und verarbeitet das Ereignis und die nachgeordneten EventFilter erhalten das Ereignis gar nicht mehr. In diesem Fall muss man die Reihenfolge der Erstellung der Interaktionskomponenten beachten.", 
            "title": "Benutzer-Interaktion mit dem Diagramm"
        }, 
        {
            "location": "/interaction/#datenanzeige-tracker", 
            "text": "Die Basisklasse f\u00fcr Interaktionskomponenten ist die Klasse  QwtPicker . Diese implementiert die Behandlung von Enter, Leave, Mouse und Keyboard-Ereignissen und transformiert diese in ausgew\u00e4hlte Punkte. Dabei gibt es verschiedene Zustandsautomaten, welche man nachnutzen kann.  F\u00fcr die Anzeige von\nQwtPicker *picker = new QwtPicker(widget);  Die Klasse QwtTracker   wie funktioniert der Tracker  punkt, vertikal, horizontal", 
            "title": "Datenanzeige (Tracker)"
        }, 
        {
            "location": "/interaction/#verschieben-der-plotflache", 
            "text": "Das Verschieben der aktuellen Ansichtsfl\u00e4che des Diagramms erfolgt mit dem  QwtPlotPanner .  // Erstelle Objekt, welches sich gleich bei der Zeichenfl\u00e4che des\n// Plot registriert\nd_panner = new QwtPlotPanner(plot- canvas());\nd_panner- setMouseButton(Qt::MidButton);", 
            "title": "Verschieben der Plotfl\u00e4che"
        }, 
        {
            "location": "/interaction/#kurvenverlauf-abfahren-curvetracker", 
            "text": "wie funktioniert der Tracker", 
            "title": "Kurvenverlauf abfahren (CurveTracker)"
        }, 
        {
            "location": "/interaction/#zoomenplotausschnitt-verschieben-zoomingpanning", 
            "text": "zoomer einstellungen  zoom rect", 
            "title": "Zoomen/Plotausschnitt verschieben (Zooming/Panning):"
        }, 
        {
            "location": "/interaction/#basiszoomstufe-einstellen", 
            "text": "zoom base einstellen (maximale rauszoomgr\u00f6\u00dfe)", 
            "title": "Basiszoomstufe einstellen"
        }, 
        {
            "location": "/interaction/#mehrere-achsen-zoomen", 
            "text": "R\u00fccktransformation zeigen", 
            "title": "Mehrere Achsen zoomen"
        }, 
        {
            "location": "/interaction/#legendeneintrage-einausschalten", 
            "text": "Bei einer au\u00dfenliegenden Legende sind die standardm\u00e4\u00dfig erstellen Legendeneintr\u00e4ge einfache Label vom Typ  QwtLegendLabel . Diesen k\u00f6nnen an- und ausgeschaltet werden (checked). Ein typischer Anwendungsfall ist das Sichtbar-/Versteckt-Schalten von Diagrammkurven/Balken, um einen Teil der Informationen zu verbergen.  Zun\u00e4chst muss die entsprechende Legendeneigenschaft eingeschaltet werden:  // Legendeneintr\u00e4ge  checkbar  machen\nd_legend- setDefaultItemMode(QwtLegendData::Checkable);", 
            "title": "Legendeneintr\u00e4ge ein/ausschalten"
        }, 
        {
            "location": "/interaction/#auf-checkedunchecked-ereignisse-reagieren", 
            "text": "Damit man auf das Umschalten der Legendeintr\u00e4ge reagieren kann, muss man eine Signal-Slot-Verbindung zwischen Signal  QwtLegendLabel::checked(bool)  und einer eigenen Funktion herstellen. Das zu einer Kurve geh\u00f6rige LegendLabel findet man \u00fcber die Funktion  QwtLegend::legendWidget()  (wobei das eigentlich das Widget eines einzelnen Legendeneintrags ist). Das kann man dann in ein Label casten und via mit der entsprechenden Funktion verkn\u00fcpfen:  // das zu einer Kurve geh\u00f6rige LegendLabel findet man \u00fcber die Funktion QwtLegend::legendWidget()\n// 'plotCurve1' ist ein Zeiger zu einer hinzugef\u00fcgten QwtPlotCurve\nQWidget* legendWidget = d_legend- legendWidget(itemToInfo(plotCurve1));\nQwtLegendLabel* label = qobject_cast QwtLegendLabel* (legendWidget);\n// das Signal verkn\u00fcpfen\nconnect(label, SIGNAL(checked(bool)),\n        this, SLOT(onCurveVisibilityChanged(bool)) );   Hinweis:  Statt  qobject_cast QwtLegendLabel*  k\u00f6nnte man auch `dynamic_cast  verwenden, ersteres ist aber schneller und daher besser bei QObject-abgeleiteten Klassentypen.", 
            "title": "Auf Checked/Unchecked-Ereignisse reagieren"
        }, 
        {
            "location": "/interaction/#sichtbarunsichtbar-schalten-von-linienkurven-im-diagramm-qwtplotcurve", 
            "text": "Die Implementierung bei Liniendiagrammen sieht so aus:  void MyPlot::onCurveVisibilityChanged (bool on) {\n    QObject * origin = sender();\n    // cast pointer to QwtLegendItem\n    QwtLegendLabel * item = qobject_cast QwtLegendLabel * (origin);\n    // check that is was a valid sender\n    if (item == NULL)\n        return; // invalid origin\n\n    // now find out which curve belongs to this legend item\n    for (unsigned int i=0; i NumCurves; ++i) {\n        if (m_curves[i] == NULL)\n            continue; // skip empty curves\n        QWidget* legendWidget = m_legend- legendWidget(itemToInfo(m_curves[i]));\n        QwtLegendLabel* label = qobject_cast QwtLegendLabel* (legendWidget);\n        if (label == item) {\n            // set visibility of curve based on function argument\n            m_curves[i]- setVisible(on);\n            replot();\n            break;\n        }\n    }\n}", 
            "title": "Sichtbar/Unsichtbar-Schalten von Linien/Kurven im Diagramm (QwtPlotCurve)"
        }, 
        {
            "location": "/interaction/#legendeneintrage-alternativ-schalten", 
            "text": "Implement show curve function such:  void CpuPlot::showCurve(QwtPlotItem *item, bool on)\n{\n    // wenn eine Curve angeschaltet werden soll, vorher alle anderen ausschalten\n    if (on) {\n        const QwtPlotItemList  list = this- itemList();\n        for (QwtPlotItemIterator it = list.begin();it!=list.end();++it) {\n            QwtPlotItem *item2 = *it;\n            if (item2- rtti() == QwtPlotItem::Rtti_PlotCurve)\n            item2- setVisible(false);\n        }\n    }\n    item- setVisible(on);\n    // Legendenwidget aktualisieren\n    QWidget *w = legend()- find(item);\n    if ( w   w- inherits( QwtLegendItem ) )\n        ((QwtLegendItem *)w)- setChecked(on);\n    replot();\n}", 
            "title": "Legendeneintr\u00e4ge alternativ schalten"
        }, 
        {
            "location": "/advanced/", 
            "text": "Spezifische Anpassungen\n\n\nLayout hints\n\n\nRender hints\n\n\nPerformance-Optimierungen\n\n\n\n\nPunkte filtern (monotone x-Achsen)\n\n\nAntialiasing\n\n\n\n\nOverlays\n\n\n...\n\n\nSpline-Interpolation von Kurven\n\n\nab \n6.3.x_trunk\n\n...\n\n\nZeichenreihenfolge\n\n\n\n\nwie kontrolliert man die Zeichenreihenfolge (zValues)\n\n\nStandardreihenfolge beim Zeichnen\n\n\n\n\nTricks und Tipps\n\n\nBesitz\u00fcbernahme von Objekten des Plots\n\n\nUm einmal hinzugef\u00fcgte Elemente zu entnehmen, \nohne dass diese gel\u00f6scht werden\n, muss man zuerst deren parent-Attribut \u00e4ndern. Dazu ben\u00f6tigt man Schreibzugriff auf das jeweilige Element, welchen man eventuell \u00fcber einen \nconst_cast\n erhalten kann. Um z.B. ein Legendenobjekt zu entnehmen, um es sp\u00e4ter modifiziert wieder hinzuzuf\u00fcgen, kann man folgendes tun:\n\n\nQwtLegend * legend = const_cast\nQwtLegend *\n(plot-\nlegend());\nlegend-\nsetParent(anotherObject);\nplot-\ninsertLegend(NULL); // remove legend from plot", 
            "title": "Fortgeschrittenes"
        }, 
        {
            "location": "/advanced/#spezifische-anpassungen", 
            "text": "", 
            "title": "Spezifische Anpassungen"
        }, 
        {
            "location": "/advanced/#layout-hints", 
            "text": "", 
            "title": "Layout hints"
        }, 
        {
            "location": "/advanced/#render-hints", 
            "text": "", 
            "title": "Render hints"
        }, 
        {
            "location": "/advanced/#performance-optimierungen", 
            "text": "Punkte filtern (monotone x-Achsen)  Antialiasing", 
            "title": "Performance-Optimierungen"
        }, 
        {
            "location": "/advanced/#overlays", 
            "text": "...", 
            "title": "Overlays"
        }, 
        {
            "location": "/advanced/#spline-interpolation-von-kurven", 
            "text": "ab  6.3.x_trunk \n...", 
            "title": "Spline-Interpolation von Kurven"
        }, 
        {
            "location": "/advanced/#zeichenreihenfolge", 
            "text": "wie kontrolliert man die Zeichenreihenfolge (zValues)  Standardreihenfolge beim Zeichnen", 
            "title": "Zeichenreihenfolge"
        }, 
        {
            "location": "/advanced/#tricks-und-tipps", 
            "text": "", 
            "title": "Tricks und Tipps"
        }, 
        {
            "location": "/advanced/#besitzubernahme-von-objekten-des-plots", 
            "text": "Um einmal hinzugef\u00fcgte Elemente zu entnehmen,  ohne dass diese gel\u00f6scht werden , muss man zuerst deren parent-Attribut \u00e4ndern. Dazu ben\u00f6tigt man Schreibzugriff auf das jeweilige Element, welchen man eventuell \u00fcber einen  const_cast  erhalten kann. Um z.B. ein Legendenobjekt zu entnehmen, um es sp\u00e4ter modifiziert wieder hinzuzuf\u00fcgen, kann man folgendes tun:  QwtLegend * legend = const_cast QwtLegend * (plot- legend());\nlegend- setParent(anotherObject);\nplot- insertLegend(NULL); // remove legend from plot", 
            "title": "Besitz\u00fcbernahme von Objekten des Plots"
        }, 
        {
            "location": "/customization/", 
            "text": "Anpassung des QwtPlots durch \u00dcberladung\n\n\n\n\nGrundkonzepte: \u00dcberladung, Funktionalit\u00e4t anpassen durch Polymorphismus\n\n\n\n\n\u00dcberblick \u00fcber die API\n\n\n\n\nWo finde ich was; welche Klasse ist wof\u00fcr zust\u00e4ndig (Liste)\n\n\n\n\nDas Layout-System\n\n\n\n\nWie wird die konkrete Geometrie berechnet (Achsenlabels, Randabst\u00e4nde, Ticks, ...)\n\n\n\n\nAnpassung der Bildaufteilung\n\n\nQwtPlotLayout\n\n\n\n\nZeichenfl\u00e4che hat Abst\u00e4nde zum Rand:\n\n\nwenn \nsetAlignCanvasToScale()\n false ist\n\n\nAbstand entspricht: maximum aus canvasMargins (siehe setCanvasMargin) und borderDistHint des SkaleWidgets -\n damit Label noch hinpasst\n\n\n\n\nsetAlignCanvasToScale()\n\n\nAchsen\n\n\n\n\neigene ScaleDivs und ScaleDraws\n\n\n\n\nBalkendiagramme mit Kategoriebeschriftungen\n\n\n...\n\n\nProportionalit\u00e4t\n\n\n\n\nProportionalit\u00e4t zweier Achsen einfordern\n\n\n\n\nLegenden\n\n\n--\n Aktualisierung der Legende nach \u00c4nderungen: \nQwtPlotCurve::itemChanged()\n\n\n\u00c4u\u00dfere Legenden\n\n\n\n\nPlatzierung, Spalteanzahl, Abst\u00e4nde, ...\n\n\nKontrolle \u00fcber Sortierung der Eintr\u00e4ge\n\n\n\n\nInnere Legenden\n\n\n\n\nFormatierung\n\n\nReagieren auf Klicks\n\n\nVerschieben der Legende implementieren\n\n\n\n\nEigene Legendeneintr\u00e4ge zeichnen\n\n\nLinendiagramme (QwtPlotCurve)\n\n\nWenn die eingebauten Legendenicon-Typen (Linie oder gef\u00fclltes Rechteck) nicht ausreichend sind, dann kann man einfach die Funktion \nQwtPlotCurve::legendItem()\n re-implementieren.\n\n\nBeispiel: Die Legende soll Linien mittels gef\u00fcllter Rechtecke zeigen, aber umrandet mit einem schwarzen Rahmen\n\n\n\n\n\n\n(links original, rechts mit angepasster Zeichenroutine)\n\n\nQuelltext:\n\n\n// Ableiten der QwtPlotCurve Klasse (z.B. direkt in der cpp-Datei,\n// wo die Instanzen der QwtPlotCurve erstellt werden)\nclass PlotCurveWithBlackFrameInLegend : public QwtPlotCurve {\npublic:\n  PlotCurveWithBlackFrameInLegend(const QString \n desc) :\n    QwtPlotCurve(desc)\n  {}\n\n  // Re-implementierung der legendIcon()-Funktion\n  QwtGraphic legendIcon( int index, const QSizeF \n size) const {\n    Q_UNUSED( index );\n\n    if ( size.isEmpty() )\n      return QwtGraphic();\n\n    QwtGraphic graphic;\n    graphic.setDefaultSize( size );\n    graphic.setRenderHint( QwtGraphic::RenderPensUnscaled, true );\n\n    QPainter painter( \ngraphic );\n    painter.setRenderHint( QPainter::Antialiasing,\n    testRenderHint( QwtPlotItem::RenderAntialiased ) );\n    QRectF r( 0, 0, size.width(), size.height() );\n\n    // zeichne gef\u00fclltes Rechteck\n    painter.setPen(Qt::black);\n    painter.setBrush(pen().color());\n    painter.drawRect( r);\n    return graphic;\n  }\n};\n\n\n\n\nStatt \nQwtPlotCurve\n Objekten kann man nun einfach Instanzen von \nPlotCurveWithBlackFrameInLegend\n erstellen und dem \nQwtPlot\n \u00fcbergeben.\n\n\nPicker/zoomer\n\n\n\n\nPickertext anpassen\n\n\nZoomrect anders zeichnen (Beispiel: \"marching ants\")\n\n\n\n\nBalkendiagramme anpassen\n\n\nBalken mit schwarzen Trennlinien zeichnen\n\n\nErster Versuch:\n\n\nQwtColumnSymbol* symbol = new QwtColumnSymbol(QwtColumnSymbol::Box);\nsymbol-\nsetFrameStyle(QwtColumnSymbol::Plain);\nsymbol-\nsetLineWidth(1);\nQPalette palette;\npalette.setColor(QPalette::Window, barColor); // barColor ist die F\u00fcllfarbe\npalette.setBrush(QPalette::Dark, Qt::black);\nsymbol-\nsetPalette(palette);\n\n\n\n\nAber: doppelte schwarze Linien sehen unelegant aus.\n\n\nNeue Variante: \nQwtPlotMultiBarChart::specialSymbol()\n\nF\u00fcr stacked bars - links und rechts eine Linie und nur oben eine Linie.\n\n\nIn der Legende was anderes?\n\n\nPlot Darstellung\n\n\nGradient als Plot-Hintergrund\n\n\nBeispiel: SinusPlot", 
            "title": "Anpassungen"
        }, 
        {
            "location": "/customization/#anpassung-des-qwtplots-durch-uberladung", 
            "text": "Grundkonzepte: \u00dcberladung, Funktionalit\u00e4t anpassen durch Polymorphismus", 
            "title": "Anpassung des QwtPlots durch \u00dcberladung"
        }, 
        {
            "location": "/customization/#uberblick-uber-die-api", 
            "text": "Wo finde ich was; welche Klasse ist wof\u00fcr zust\u00e4ndig (Liste)", 
            "title": "\u00dcberblick \u00fcber die API"
        }, 
        {
            "location": "/customization/#das-layout-system", 
            "text": "Wie wird die konkrete Geometrie berechnet (Achsenlabels, Randabst\u00e4nde, Ticks, ...)", 
            "title": "Das Layout-System"
        }, 
        {
            "location": "/customization/#anpassung-der-bildaufteilung", 
            "text": "QwtPlotLayout   Zeichenfl\u00e4che hat Abst\u00e4nde zum Rand:  wenn  setAlignCanvasToScale()  false ist  Abstand entspricht: maximum aus canvasMargins (siehe setCanvasMargin) und borderDistHint des SkaleWidgets -  damit Label noch hinpasst   setAlignCanvasToScale()", 
            "title": "Anpassung der Bildaufteilung"
        }, 
        {
            "location": "/customization/#achsen", 
            "text": "eigene ScaleDivs und ScaleDraws", 
            "title": "Achsen"
        }, 
        {
            "location": "/customization/#balkendiagramme-mit-kategoriebeschriftungen", 
            "text": "...", 
            "title": "Balkendiagramme mit Kategoriebeschriftungen"
        }, 
        {
            "location": "/customization/#proportionalitat", 
            "text": "Proportionalit\u00e4t zweier Achsen einfordern", 
            "title": "Proportionalit\u00e4t"
        }, 
        {
            "location": "/customization/#legenden", 
            "text": "--  Aktualisierung der Legende nach \u00c4nderungen:  QwtPlotCurve::itemChanged()", 
            "title": "Legenden"
        }, 
        {
            "location": "/customization/#auere-legenden", 
            "text": "Platzierung, Spalteanzahl, Abst\u00e4nde, ...  Kontrolle \u00fcber Sortierung der Eintr\u00e4ge", 
            "title": "\u00c4u\u00dfere Legenden"
        }, 
        {
            "location": "/customization/#innere-legenden", 
            "text": "Formatierung  Reagieren auf Klicks  Verschieben der Legende implementieren", 
            "title": "Innere Legenden"
        }, 
        {
            "location": "/customization/#eigene-legendeneintrage-zeichnen", 
            "text": "", 
            "title": "Eigene Legendeneintr\u00e4ge zeichnen"
        }, 
        {
            "location": "/customization/#linendiagramme-qwtplotcurve", 
            "text": "Wenn die eingebauten Legendenicon-Typen (Linie oder gef\u00fclltes Rechteck) nicht ausreichend sind, dann kann man einfach die Funktion  QwtPlotCurve::legendItem()  re-implementieren.  Beispiel: Die Legende soll Linien mittels gef\u00fcllter Rechtecke zeigen, aber umrandet mit einem schwarzen Rahmen    (links original, rechts mit angepasster Zeichenroutine)  Quelltext:  // Ableiten der QwtPlotCurve Klasse (z.B. direkt in der cpp-Datei,\n// wo die Instanzen der QwtPlotCurve erstellt werden)\nclass PlotCurveWithBlackFrameInLegend : public QwtPlotCurve {\npublic:\n  PlotCurveWithBlackFrameInLegend(const QString   desc) :\n    QwtPlotCurve(desc)\n  {}\n\n  // Re-implementierung der legendIcon()-Funktion\n  QwtGraphic legendIcon( int index, const QSizeF   size) const {\n    Q_UNUSED( index );\n\n    if ( size.isEmpty() )\n      return QwtGraphic();\n\n    QwtGraphic graphic;\n    graphic.setDefaultSize( size );\n    graphic.setRenderHint( QwtGraphic::RenderPensUnscaled, true );\n\n    QPainter painter(  graphic );\n    painter.setRenderHint( QPainter::Antialiasing,\n    testRenderHint( QwtPlotItem::RenderAntialiased ) );\n    QRectF r( 0, 0, size.width(), size.height() );\n\n    // zeichne gef\u00fclltes Rechteck\n    painter.setPen(Qt::black);\n    painter.setBrush(pen().color());\n    painter.drawRect( r);\n    return graphic;\n  }\n};  Statt  QwtPlotCurve  Objekten kann man nun einfach Instanzen von  PlotCurveWithBlackFrameInLegend  erstellen und dem  QwtPlot  \u00fcbergeben.", 
            "title": "Linendiagramme (QwtPlotCurve)"
        }, 
        {
            "location": "/customization/#pickerzoomer", 
            "text": "Pickertext anpassen  Zoomrect anders zeichnen (Beispiel: \"marching ants\")", 
            "title": "Picker/zoomer"
        }, 
        {
            "location": "/customization/#balkendiagramme-anpassen", 
            "text": "", 
            "title": "Balkendiagramme anpassen"
        }, 
        {
            "location": "/customization/#balken-mit-schwarzen-trennlinien-zeichnen", 
            "text": "Erster Versuch:  QwtColumnSymbol* symbol = new QwtColumnSymbol(QwtColumnSymbol::Box);\nsymbol- setFrameStyle(QwtColumnSymbol::Plain);\nsymbol- setLineWidth(1);\nQPalette palette;\npalette.setColor(QPalette::Window, barColor); // barColor ist die F\u00fcllfarbe\npalette.setBrush(QPalette::Dark, Qt::black);\nsymbol- setPalette(palette);  Aber: doppelte schwarze Linien sehen unelegant aus.  Neue Variante:  QwtPlotMultiBarChart::specialSymbol() \nF\u00fcr stacked bars - links und rechts eine Linie und nur oben eine Linie.  In der Legende was anderes?", 
            "title": "Balken mit schwarzen Trennlinien zeichnen"
        }, 
        {
            "location": "/customization/#plot-darstellung", 
            "text": "", 
            "title": "Plot Darstellung"
        }, 
        {
            "location": "/customization/#gradient-als-plot-hintergrund", 
            "text": "Beispiel: SinusPlot", 
            "title": "Gradient als Plot-Hintergrund"
        }, 
        {
            "location": "/export/", 
            "text": "QwtPlot exportieren und drucken\n\n\nThis section discusses various aspects related to exporting a QwtPlot to images\n(or image files) and printing charts with good quality to different sources.\n\n\nThe basics\n\n\nThe process of drawing the actual QwtPlot is called \nrendering\n the plot. There are\nseveral different functions available for that, which we discuss later.\n\n\nWhen a QwtPlot is rendered on a raster-based paint device (see QPaintDevice), the\nresult will be a pixel buffer (e.g. image/pixmap), which can be stored, for example,\nin PNG files.\n\n\nWhen the plot is rendered on a vector paint device (PDF, SVG, ...) the result will\nbe a vector graphic and it depends on the viewer (or printer) to show/print it. As\na vector graphic, all items are drawn within some coordinate system which can\nrepresent either real distances (mm or inch) or pixels or anything. Conversion\nbetween these coordinate systems is typically done by some factor.\n\n\nResolution\n\n\nA typical way to relate between real distances to pixels/points is the resolution,\nexpressed as DotsPerInch (DPI). Printers have typically a resolution of 600 DPI or\n1200 DPI. The resolution of a monitor depends on the screen resolution\n(e.g. FullHD 1920x1080) and the monitor size, with typical values between 72 and\n120 DPI. Above that (for 4K laptop screens) such displays are sometimes termed\nHighDPI displays.\n\n\nIt is important to keep this resolution in mind, because viewers of the plot have\ndifferent expectations when whatching a plot on the monitor or on paper or in\na PDF. Here, you can zoom in to see details (same as using magnifying glass for the\nprinted plot).\n\n\nThe equation for converting from distance in mm to pixel is:\n\n\nresolution / 25.4 mm/inch = pixel / mm\nsizePixel = sizeMM * resolution / 25.4\n\n\n\nFor example, on a monitor with resolution of 85 DPI a single pixel has a width of:\n\n\n1 pixel * 25.4 / 85 = 0.3 mm\n\n\n\nLine widths and the 'cosmetic' property\n\n\nFor example, if you have a 15'' screen with full HD resolution, you may want to\nuse exactly 1 pixel-wide lines for the plot grid or the curves. Such a single\npixel line then has about 0.2...0.3 mm width (see above) - good to see without\ntoo much effort.\n\n\nUsing the same screen size but with 4k display, a single-pixel line may be already\ntoo thin to see. Still, 1 pixel wide lines are typically good for drawing on\ncomputer screens. Since drawing single-pixel lines is very common, Qt such\nlines can be drawn using a QPen with pen width of 0 (Note: in previous Qt versions\nthis was the default, since Qt 5 the default is 1 pixel wide). A pen with 0 width\nis also termed a \ncosmetic\n pen, meaning that regardless on the resolution of the\npaint device, always only 1 pixel is used for drawing.\n\n\nHowever, the cosmetic property can be also set for pens with other widths:\n\n\n    QPen::setCosmetic(bool)\n\n\n\n\nGenerally, all lines with cosmetic pens shall be drawn with exactly the\nspecified number of pixels, regardless of target paint device resolution and\npossible \ntransformations\n.\n\n\nTransformations and their impact on plot items\n\n\nWhen rendering the plot to a painting device, the plot items are drawn with\ncoordinates which are transformed to the target coordinate system. Part of this\ntransformation is also the scaling of plot item properties, such as font sizes\nand line widths. Normally, all plot items are drawn scaled to the coordinate\nsystem (and resolution) of the target paint device. The scale factor is\ndetermined by various factors, as we will see below.\n\n\nOnly cosmetic pens are exempt from the scaling. This may lead to surprising\nresults, when a cosmetic pen with width of 1 is rendered onto a 1200 DPI\nprinter page. Indeed, the printer will only print a single dot as line width,\nleading to a tiny and hard to see line. Apparently, the cosmetic pen size\nshould somehow be aligned with the target resolution to get an expected\nphysical width. Different options on how to do this are shown below.\n\n\nExporting bitmaps\n\n\nRendering a QwtPlot onto a bitmap is fairly easy. However, there are three\ndifferent options to consider:\n\n\n\n\nhardcopy of the plot as shown on the screen\n\n\nrendering on different pixel size yet same scaling\n\n\nrendering on different pixel size yet keep appearance and simply scale chart\n\n\n\n\nBitmap hardcopy\n\n\nBasically, the same as a screenshot, good for copying the QwtPlot to the\nclipboard, simply use:\n\n\n    pixmap = plot-\ngrab();              // Qt 5 or newer\n    pixmap = QPixmap::grabWidget(plot); // Qt 4\n\n\n\n\nBitmap with different size yet same scaling\n\n\nThis is basically the same as resizing a QwtPlot widget - there will be\nmore space for the coordinate axes, there will be more canvas area for the plot\nitems and more space for labels and text.\n\n\nUse:\n\n\n  QwtPlotRenderer renderer; // the renderer\n    QRect imageRect( 0.0, 0.0, imageWidth, imageHeight ); // target size in pixels\n    QImage image( imageRect.size(), QImage::Format_ARGB32 );\n    image.fill( Qt::white ); // fill with uniform background color, usually white\n\n    QPainter painter( \nimage );\n    renderer.render( plot, \npainter, imageRect );\n    painter.end();\n\n\n\n\nFor this variant, all pens and fonts will remain exactly the same as in the\nQwtPlot widget.\n\n\nExport bitmap with proportional scaling\n\n\nThis type of export can be thought of as method to shrink/expand the current\nplot to a new size. Major difference to the method above is that the proportions\nwithin the chart stay the same. For example, the ratio of grid lines distance to\nlabel text lengths and curve distances stays (approximately) the same.\n\n\nUse:\n\n\n    QwtPlotRenderer renderer; // the renderer\n\n    QRect imageRect( 0.0, 0.0, imageWidth, imageHeight ); // target size in pixels\n    QImage image( imageRect.size(), QImage::Format_ARGB32 );\n\n    int resolution = 96; // in DPI, 24'' Monitor with 1920x1080 screen resolution\n    const double mmToInch = 1.0 / 25.4;\n    const int dotsPerMeter = qRound( resolution * mmToInch * 1000.0 );\n    image.setDotsPerMeterX( dotsPerMeter );\n    image.setDotsPerMeterY( dotsPerMeter );\n\n    image.fill( Qt::white ); // fill with uniform background color, usually white\n\n    QPainter painter( \nimage );\n    renderer.render( plot, \npainter, imageRect );\n    painter.end();\n\n\n\n\nIt is now possible to generate a bitmap with the same dimensions, yet different\nlevel of detail, by adjusting the resolution. \nHigher resolution\n means effectively\n\nmore pixels per item\n, e.g larger fonts, larger line width etc.\n\n\n\n\nNote:\n The scaling properties (cosmetic!) have already an impact. When curve pens\nand grid pens have a cosmetic pen assigned (e.g. 1 or 2 pixels), they will be drawn\nwith exactly this amount of pixels onto the bitmap.\n\n\n\n\nTo summarize: \nwhen exporting bitmaps, use cosmetic pens\n\n\nBitmap export for screen presentation\n\n\nWhen exporting bitmaps for use in a presentation and the resolution is\nknown (e.g. 1024x786 on old projectors), typically the task is to generate\na plot with a given maximum resolution (to fit on screen), without any\nscaling in the presentation software (pixel = pixel) when the presentation\nis shown on screen, and yet enough detail of the plot.\n\n\nSuppose your plot is configured to look nicely\nin the QwtPlot widget with a resolution of 1980x1080 pixels (full HD).\nIn your presentation you have only about 600x450 pixels. When exporting,\nselect the target size as image size and adjust the DPI value until you have a good\ncompromise between level of detail and size of fonts in the diagram. Thanks\nto the cosmetic pens (if used), the lines and grid will always be drawn\nnicely with good contrast and without blurring.\n\n\nExporting vector images/printing\n\n\nExporting a vector image or printing a plot works essentially the same. The\nplot is simply rendered on a vector-based paint device. Such a paint device has\nproperties such as size and resolution, something\nthat is, for example, provided by a QPrinter.\n\n\nExpectations on plot results/differences to screen view\n\n\nWhen exporting a plot to a vector graphic, some expectations can be formulated:\n\n\n\n\n\n\nwhen looking at the vector graphic in a viewer (e.g. in a PDF viewer) it\n  should look similar to the plot in the QwtPlot widget\n\n\n\n\n\n\nwhen zooming in, there should be more details visible; for example, when the\n  original 100% view shows high frequency oscillations in the diagram such that\n  many lines are drawn next to/over each other, zooming in into the vector graphic\n  should reveal more details\n\n\n\n\n\n\nwhen \nlooking\n at a PDF/Vector graphic in a viewer, some lines (grid,\n   coordinates and label ticks) should be drawn with 1-pixel-wide lines, yet\n   when \nprinting\n the plot, the same lines should be drawn with\n   a meaningful thickness (e.g. 0.2 mm thick lines), so that they appear\n   nicely on the page\n\n\n\n\n\n\nexporting a plot with 40x30 mm size or 80x60 mm size should result in the\n   same line ticknesses to be used (e.g. curve line thickness should be 0.6 mm\n   as selected)\n\n\n\n\n\n\nApparently, there is no single correct solution and different options have to be\nused depending on the desired scenario.\n\n\n\n\nNote:\n A general misconception may be, that a vector graphic output format\ncan be used to emulate the zooming features of QwtPlot. Instead, the general\npurpose of a vector plot is to \nmaintain the general appearance\n (incl. line\nthicknesses) regardless of target resolution. For example, when exploiting\na PDF viewer to zoom into a chart, one may \nnot\n expect the same functionality as\nzooming into a QwtPlot, i.e. more samples being drawn with line widths kept\nthe same regardless of zoom level (see discussion of cosmetic property treatment\nbelow).\n\n\n\n\nExport formats\n\n\nPDF specifics\n\n\nA common understanding of the PDF requirement is, that zooming into the PDF\nscales \nall elements\n in correct\nproportions. Hence, if a plot shown at 100% zoom hides some details (because curve\nline thickness is too large), zooming in will not help at all, since curve line\nthicknesses scale just the same.\n\n\nFor cosmetic pens the property has only an impact on the \ninitial\ncomposition\n of the vector graphic. A viewer will nonetheless scale line width\nduring zoom.\n\n\nTricky is the situation for PDFs with cosmetic, 1-pixel wide lines (pen-width = 0).\nFor viewing PDFs in a pdf viewer this may be quite neat, yet when printing such\na PDF with 600 DPI or higher, the extremely thin lines will almost vanish. So when\nexporting, one should distinguish between \"screen viewing\" and \"printing\", which\nmay be quite confusing to the user of the PDF.\n\n\nTherefore, for \ngenerally\n usable PDFs, it is recommended to \navoid cosmetic 1-pixel\nlines (i.e. pen-width = 0) in PDFs\n, altogether.\n\n\n\n\nNote:\n for Qt 5.10 and probably other versions as well there appears to be a bug\nthat prevents the pdf paint engine of Qt to consider the cosmetic property when\na solid line with full opaque color is plotted with pen width != 0. Workaround\nis to set the alpha value of the curve pen to 254. However, there is generally\na better way to handle line widths, see below. Do not use cosmetic pens for\nPDF export.\n\n\n\n\nSVG features\n\n\nSVG files (at least with SVG version 1.2 or newer) have a property for path elements\n\nvector-effect=\"non-scaling-stroke\"\n\n\nIn a viewer that supports this feature (and with certain additional requirements:\nviewport attribute must exist, width and height attribute must \nnot\n exist),\nthe cosmetic lines will be shown indeed with constant width regardless of the zoom\nlevel. However, this feature is far from being universally supported. At the\ncurrent state, using cosmetic pens will not even work for SVG export.\n\n\nDo not rely on the cosmetic property to work when exporting SVG images.\n\n\nPS/EPS export\n\n\nPostscript/Encapsulated Postscript export has been removed from Qt with version 5,\nso there is no paint device available anylonger that generates this. However,\nusing a postscript printer driver and storing the result to file will\ngenerally work (see printing section below).\n\n\nEMF export\n\n\nEMF export is important for Windows users, but relies on translating\nQt paint engine drawing commands into Windows drawing API commands. To export\nthe plot to emf format (either cliboard or *.emf file), a third-party\nlibrary (e.g. EmfLibary) is needed that generates EMF commands from\npaint device commands.\n\n\n\n\nNote:\n It is important that the EMF library implements a paint device, that is\nrecognized by its type as a vector-based paint device (greater or equal to\nUser-type). QwtPlot distinguishes between raster and vector based paint devices,\nso if characteristic steps appear in lines within the EMF output, it is likely\nthat the paint device type is reported/recognized wrong.\n\n\n\n\nTarget paint device resolution\n\n\nThe target paint device resolution is usually given. A printer will report\nthe resolution selected by the printer driver. For PDF or SVG export, the resolution\ncan be arbitrarily selected. However, it should be selected such, that enough\npoints remain to render a plot without data loss. For example, if 10000 samples/data\npoints are equally spaced over the canvas area, the resulting width of\ngenerated plot (=total number of points) should be well above 10000,\nif chart should be plotted without data loss. If the line thickness is selected\nfine enough, zooming into the vector graphic will eventually yield\n\n\nAdjusting line width\n\n\nWhen configuring a QwtPlot for viewing a diagram in the widget, the curve pen widths\nare typically selected based on pixels on the screen. For FullHD displays, pen widths\nof 1-3 pixels are common, for 3K and 4K displays (HighDPI displays), pen widths up\nto 6 pixels are used.\n\n\nHowever, when printing charts, typical pen widths should in the magnitude\nof 0.2 ... 1 mm (where 1 mm is already a fairly thick line). Marker symbols are often\ndrawn with less than 0.3 mm thick lines.\n\n\nThere are generally two approaches on how to achieve this:\n\n\n\n\n\n\nselect export DPI such, that the desired mm widths are achieved based on the current pen widths already used for the widget (requires \nnon-cosmetic\n pens to be used)\n\n\n\n\n\n\nmodify pen widths of all plot items prior to printing to get the desired width (this works with cosmetic and non-cosmetic pens, though the calculation of the\nactual pen width to use will be different)\n\n\n\n\n\n\nAdjusting DPI\n\n\nIt is important to note that a change of the DPI settings will affect not only\nline width but also font heights.\n\n\nThe required DPI can be calculated based on the equation shown above in\nsection \nPrint Resolution\n.\n\n\n\\subsubsection exportingVectorLineWidthPenAdjustment Adjusting pen width\n\n\nThe advantage of this approach is, that the overall appearance of the vector image\nlooks very close to that rendered on the QwtPlot widget.\n\n\nSuppose the resolution (in DPI) of the target device is known and a given, i.e.\nthe plot should be rendered with exactly this resolution. This avoids print-time\nscaling and may give best quality (though I wonder if someone can really see\nthe difference between a 300 DPI plot upscaled to 1200 DPI or a natively\nrendered 1200 DPI plot. The effect on antialiasing will be minor, but maybe\nworth a try).\n\n\nAgain, we rearrage the equation from section \\ref printingResolution.\n\n\nAdditional topics\n\n\nrenderer.setLayoutFlag(QwtPlotRenderer::FrameWithScales, true);\n\n\n\nSample reduction\n\n\n...\n\n\n*/", 
            "title": "Drucken/Exportieren"
        }, 
        {
            "location": "/export/#qwtplot-exportieren-und-drucken", 
            "text": "This section discusses various aspects related to exporting a QwtPlot to images\n(or image files) and printing charts with good quality to different sources.", 
            "title": "QwtPlot exportieren und drucken"
        }, 
        {
            "location": "/export/#the-basics", 
            "text": "The process of drawing the actual QwtPlot is called  rendering  the plot. There are\nseveral different functions available for that, which we discuss later.  When a QwtPlot is rendered on a raster-based paint device (see QPaintDevice), the\nresult will be a pixel buffer (e.g. image/pixmap), which can be stored, for example,\nin PNG files.  When the plot is rendered on a vector paint device (PDF, SVG, ...) the result will\nbe a vector graphic and it depends on the viewer (or printer) to show/print it. As\na vector graphic, all items are drawn within some coordinate system which can\nrepresent either real distances (mm or inch) or pixels or anything. Conversion\nbetween these coordinate systems is typically done by some factor.", 
            "title": "The basics"
        }, 
        {
            "location": "/export/#resolution", 
            "text": "A typical way to relate between real distances to pixels/points is the resolution,\nexpressed as DotsPerInch (DPI). Printers have typically a resolution of 600 DPI or\n1200 DPI. The resolution of a monitor depends on the screen resolution\n(e.g. FullHD 1920x1080) and the monitor size, with typical values between 72 and\n120 DPI. Above that (for 4K laptop screens) such displays are sometimes termed\nHighDPI displays.  It is important to keep this resolution in mind, because viewers of the plot have\ndifferent expectations when whatching a plot on the monitor or on paper or in\na PDF. Here, you can zoom in to see details (same as using magnifying glass for the\nprinted plot).  The equation for converting from distance in mm to pixel is:  resolution / 25.4 mm/inch = pixel / mm\nsizePixel = sizeMM * resolution / 25.4  For example, on a monitor with resolution of 85 DPI a single pixel has a width of:  1 pixel * 25.4 / 85 = 0.3 mm", 
            "title": "Resolution"
        }, 
        {
            "location": "/export/#line-widths-and-the-cosmetic-property", 
            "text": "For example, if you have a 15'' screen with full HD resolution, you may want to\nuse exactly 1 pixel-wide lines for the plot grid or the curves. Such a single\npixel line then has about 0.2...0.3 mm width (see above) - good to see without\ntoo much effort.  Using the same screen size but with 4k display, a single-pixel line may be already\ntoo thin to see. Still, 1 pixel wide lines are typically good for drawing on\ncomputer screens. Since drawing single-pixel lines is very common, Qt such\nlines can be drawn using a QPen with pen width of 0 (Note: in previous Qt versions\nthis was the default, since Qt 5 the default is 1 pixel wide). A pen with 0 width\nis also termed a  cosmetic  pen, meaning that regardless on the resolution of the\npaint device, always only 1 pixel is used for drawing.  However, the cosmetic property can be also set for pens with other widths:      QPen::setCosmetic(bool)  Generally, all lines with cosmetic pens shall be drawn with exactly the\nspecified number of pixels, regardless of target paint device resolution and\npossible  transformations .", 
            "title": "Line widths and the 'cosmetic' property"
        }, 
        {
            "location": "/export/#transformations-and-their-impact-on-plot-items", 
            "text": "When rendering the plot to a painting device, the plot items are drawn with\ncoordinates which are transformed to the target coordinate system. Part of this\ntransformation is also the scaling of plot item properties, such as font sizes\nand line widths. Normally, all plot items are drawn scaled to the coordinate\nsystem (and resolution) of the target paint device. The scale factor is\ndetermined by various factors, as we will see below.  Only cosmetic pens are exempt from the scaling. This may lead to surprising\nresults, when a cosmetic pen with width of 1 is rendered onto a 1200 DPI\nprinter page. Indeed, the printer will only print a single dot as line width,\nleading to a tiny and hard to see line. Apparently, the cosmetic pen size\nshould somehow be aligned with the target resolution to get an expected\nphysical width. Different options on how to do this are shown below.", 
            "title": "Transformations and their impact on plot items"
        }, 
        {
            "location": "/export/#exporting-bitmaps", 
            "text": "Rendering a QwtPlot onto a bitmap is fairly easy. However, there are three\ndifferent options to consider:   hardcopy of the plot as shown on the screen  rendering on different pixel size yet same scaling  rendering on different pixel size yet keep appearance and simply scale chart", 
            "title": "Exporting bitmaps"
        }, 
        {
            "location": "/export/#bitmap-hardcopy", 
            "text": "Basically, the same as a screenshot, good for copying the QwtPlot to the\nclipboard, simply use:      pixmap = plot- grab();              // Qt 5 or newer\n    pixmap = QPixmap::grabWidget(plot); // Qt 4", 
            "title": "Bitmap hardcopy"
        }, 
        {
            "location": "/export/#bitmap-with-different-size-yet-same-scaling", 
            "text": "This is basically the same as resizing a QwtPlot widget - there will be\nmore space for the coordinate axes, there will be more canvas area for the plot\nitems and more space for labels and text.  Use:    QwtPlotRenderer renderer; // the renderer\n    QRect imageRect( 0.0, 0.0, imageWidth, imageHeight ); // target size in pixels\n    QImage image( imageRect.size(), QImage::Format_ARGB32 );\n    image.fill( Qt::white ); // fill with uniform background color, usually white\n\n    QPainter painter(  image );\n    renderer.render( plot,  painter, imageRect );\n    painter.end();  For this variant, all pens and fonts will remain exactly the same as in the\nQwtPlot widget.", 
            "title": "Bitmap with different size yet same scaling"
        }, 
        {
            "location": "/export/#export-bitmap-with-proportional-scaling", 
            "text": "This type of export can be thought of as method to shrink/expand the current\nplot to a new size. Major difference to the method above is that the proportions\nwithin the chart stay the same. For example, the ratio of grid lines distance to\nlabel text lengths and curve distances stays (approximately) the same.  Use:      QwtPlotRenderer renderer; // the renderer\n\n    QRect imageRect( 0.0, 0.0, imageWidth, imageHeight ); // target size in pixels\n    QImage image( imageRect.size(), QImage::Format_ARGB32 );\n\n    int resolution = 96; // in DPI, 24'' Monitor with 1920x1080 screen resolution\n    const double mmToInch = 1.0 / 25.4;\n    const int dotsPerMeter = qRound( resolution * mmToInch * 1000.0 );\n    image.setDotsPerMeterX( dotsPerMeter );\n    image.setDotsPerMeterY( dotsPerMeter );\n\n    image.fill( Qt::white ); // fill with uniform background color, usually white\n\n    QPainter painter(  image );\n    renderer.render( plot,  painter, imageRect );\n    painter.end();  It is now possible to generate a bitmap with the same dimensions, yet different\nlevel of detail, by adjusting the resolution.  Higher resolution  means effectively more pixels per item , e.g larger fonts, larger line width etc.   Note:  The scaling properties (cosmetic!) have already an impact. When curve pens\nand grid pens have a cosmetic pen assigned (e.g. 1 or 2 pixels), they will be drawn\nwith exactly this amount of pixels onto the bitmap.   To summarize:  when exporting bitmaps, use cosmetic pens", 
            "title": "Export bitmap with proportional scaling"
        }, 
        {
            "location": "/export/#bitmap-export-for-screen-presentation", 
            "text": "When exporting bitmaps for use in a presentation and the resolution is\nknown (e.g. 1024x786 on old projectors), typically the task is to generate\na plot with a given maximum resolution (to fit on screen), without any\nscaling in the presentation software (pixel = pixel) when the presentation\nis shown on screen, and yet enough detail of the plot.  Suppose your plot is configured to look nicely\nin the QwtPlot widget with a resolution of 1980x1080 pixels (full HD).\nIn your presentation you have only about 600x450 pixels. When exporting,\nselect the target size as image size and adjust the DPI value until you have a good\ncompromise between level of detail and size of fonts in the diagram. Thanks\nto the cosmetic pens (if used), the lines and grid will always be drawn\nnicely with good contrast and without blurring.", 
            "title": "Bitmap export for screen presentation"
        }, 
        {
            "location": "/export/#exporting-vector-imagesprinting", 
            "text": "Exporting a vector image or printing a plot works essentially the same. The\nplot is simply rendered on a vector-based paint device. Such a paint device has\nproperties such as size and resolution, something\nthat is, for example, provided by a QPrinter.", 
            "title": "Exporting vector images/printing"
        }, 
        {
            "location": "/export/#expectations-on-plot-resultsdifferences-to-screen-view", 
            "text": "When exporting a plot to a vector graphic, some expectations can be formulated:    when looking at the vector graphic in a viewer (e.g. in a PDF viewer) it\n  should look similar to the plot in the QwtPlot widget    when zooming in, there should be more details visible; for example, when the\n  original 100% view shows high frequency oscillations in the diagram such that\n  many lines are drawn next to/over each other, zooming in into the vector graphic\n  should reveal more details    when  looking  at a PDF/Vector graphic in a viewer, some lines (grid,\n   coordinates and label ticks) should be drawn with 1-pixel-wide lines, yet\n   when  printing  the plot, the same lines should be drawn with\n   a meaningful thickness (e.g. 0.2 mm thick lines), so that they appear\n   nicely on the page    exporting a plot with 40x30 mm size or 80x60 mm size should result in the\n   same line ticknesses to be used (e.g. curve line thickness should be 0.6 mm\n   as selected)    Apparently, there is no single correct solution and different options have to be\nused depending on the desired scenario.   Note:  A general misconception may be, that a vector graphic output format\ncan be used to emulate the zooming features of QwtPlot. Instead, the general\npurpose of a vector plot is to  maintain the general appearance  (incl. line\nthicknesses) regardless of target resolution. For example, when exploiting\na PDF viewer to zoom into a chart, one may  not  expect the same functionality as\nzooming into a QwtPlot, i.e. more samples being drawn with line widths kept\nthe same regardless of zoom level (see discussion of cosmetic property treatment\nbelow).", 
            "title": "Expectations on plot results/differences to screen view"
        }, 
        {
            "location": "/export/#export-formats", 
            "text": "", 
            "title": "Export formats"
        }, 
        {
            "location": "/export/#pdf-specifics", 
            "text": "A common understanding of the PDF requirement is, that zooming into the PDF\nscales  all elements  in correct\nproportions. Hence, if a plot shown at 100% zoom hides some details (because curve\nline thickness is too large), zooming in will not help at all, since curve line\nthicknesses scale just the same.  For cosmetic pens the property has only an impact on the  initial\ncomposition  of the vector graphic. A viewer will nonetheless scale line width\nduring zoom.  Tricky is the situation for PDFs with cosmetic, 1-pixel wide lines (pen-width = 0).\nFor viewing PDFs in a pdf viewer this may be quite neat, yet when printing such\na PDF with 600 DPI or higher, the extremely thin lines will almost vanish. So when\nexporting, one should distinguish between \"screen viewing\" and \"printing\", which\nmay be quite confusing to the user of the PDF.  Therefore, for  generally  usable PDFs, it is recommended to  avoid cosmetic 1-pixel\nlines (i.e. pen-width = 0) in PDFs , altogether.   Note:  for Qt 5.10 and probably other versions as well there appears to be a bug\nthat prevents the pdf paint engine of Qt to consider the cosmetic property when\na solid line with full opaque color is plotted with pen width != 0. Workaround\nis to set the alpha value of the curve pen to 254. However, there is generally\na better way to handle line widths, see below. Do not use cosmetic pens for\nPDF export.", 
            "title": "PDF specifics"
        }, 
        {
            "location": "/export/#svg-features", 
            "text": "SVG files (at least with SVG version 1.2 or newer) have a property for path elements vector-effect=\"non-scaling-stroke\"  In a viewer that supports this feature (and with certain additional requirements:\nviewport attribute must exist, width and height attribute must  not  exist),\nthe cosmetic lines will be shown indeed with constant width regardless of the zoom\nlevel. However, this feature is far from being universally supported. At the\ncurrent state, using cosmetic pens will not even work for SVG export.  Do not rely on the cosmetic property to work when exporting SVG images.", 
            "title": "SVG features"
        }, 
        {
            "location": "/export/#pseps-export", 
            "text": "Postscript/Encapsulated Postscript export has been removed from Qt with version 5,\nso there is no paint device available anylonger that generates this. However,\nusing a postscript printer driver and storing the result to file will\ngenerally work (see printing section below).", 
            "title": "PS/EPS export"
        }, 
        {
            "location": "/export/#emf-export", 
            "text": "EMF export is important for Windows users, but relies on translating\nQt paint engine drawing commands into Windows drawing API commands. To export\nthe plot to emf format (either cliboard or *.emf file), a third-party\nlibrary (e.g. EmfLibary) is needed that generates EMF commands from\npaint device commands.   Note:  It is important that the EMF library implements a paint device, that is\nrecognized by its type as a vector-based paint device (greater or equal to\nUser-type). QwtPlot distinguishes between raster and vector based paint devices,\nso if characteristic steps appear in lines within the EMF output, it is likely\nthat the paint device type is reported/recognized wrong.", 
            "title": "EMF export"
        }, 
        {
            "location": "/export/#target-paint-device-resolution", 
            "text": "The target paint device resolution is usually given. A printer will report\nthe resolution selected by the printer driver. For PDF or SVG export, the resolution\ncan be arbitrarily selected. However, it should be selected such, that enough\npoints remain to render a plot without data loss. For example, if 10000 samples/data\npoints are equally spaced over the canvas area, the resulting width of\ngenerated plot (=total number of points) should be well above 10000,\nif chart should be plotted without data loss. If the line thickness is selected\nfine enough, zooming into the vector graphic will eventually yield", 
            "title": "Target paint device resolution"
        }, 
        {
            "location": "/export/#adjusting-line-width", 
            "text": "When configuring a QwtPlot for viewing a diagram in the widget, the curve pen widths\nare typically selected based on pixels on the screen. For FullHD displays, pen widths\nof 1-3 pixels are common, for 3K and 4K displays (HighDPI displays), pen widths up\nto 6 pixels are used.  However, when printing charts, typical pen widths should in the magnitude\nof 0.2 ... 1 mm (where 1 mm is already a fairly thick line). Marker symbols are often\ndrawn with less than 0.3 mm thick lines.  There are generally two approaches on how to achieve this:    select export DPI such, that the desired mm widths are achieved based on the current pen widths already used for the widget (requires  non-cosmetic  pens to be used)    modify pen widths of all plot items prior to printing to get the desired width (this works with cosmetic and non-cosmetic pens, though the calculation of the\nactual pen width to use will be different)", 
            "title": "Adjusting line width"
        }, 
        {
            "location": "/export/#adjusting-dpi", 
            "text": "It is important to note that a change of the DPI settings will affect not only\nline width but also font heights.  The required DPI can be calculated based on the equation shown above in\nsection  Print Resolution .  \\subsubsection exportingVectorLineWidthPenAdjustment Adjusting pen width  The advantage of this approach is, that the overall appearance of the vector image\nlooks very close to that rendered on the QwtPlot widget.  Suppose the resolution (in DPI) of the target device is known and a given, i.e.\nthe plot should be rendered with exactly this resolution. This avoids print-time\nscaling and may give best quality (though I wonder if someone can really see\nthe difference between a 300 DPI plot upscaled to 1200 DPI or a natively\nrendered 1200 DPI plot. The effect on antialiasing will be minor, but maybe\nworth a try).  Again, we rearrage the equation from section \\ref printingResolution.", 
            "title": "Adjusting DPI"
        }, 
        {
            "location": "/export/#additional-topics", 
            "text": "renderer.setLayoutFlag(QwtPlotRenderer::FrameWithScales, true);", 
            "title": "Additional topics"
        }, 
        {
            "location": "/export/#sample-reduction", 
            "text": "...  */", 
            "title": "Sample reduction"
        }, 
        {
            "location": "/porting/", 
            "text": "Wesentliche \u00c4nderungen\n\n\n...\n\n\nLegenden\n\n\n\n\nexterne Legenden...\n\n\n\n\nSpektrogramme\n\n\nColorMaps\n\n\n\n\nFactoryPattern verwenden", 
            "title": "von Qwt 5.x zu 6.x"
        }, 
        {
            "location": "/porting/#wesentliche-anderungen", 
            "text": "...", 
            "title": "Wesentliche \u00c4nderungen"
        }, 
        {
            "location": "/porting/#legenden", 
            "text": "externe Legenden...", 
            "title": "Legenden"
        }, 
        {
            "location": "/porting/#spektrogramme", 
            "text": "", 
            "title": "Spektrogramme"
        }, 
        {
            "location": "/porting/#colormaps", 
            "text": "FactoryPattern verwenden", 
            "title": "ColorMaps"
        }
    ]
}